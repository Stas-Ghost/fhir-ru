<!DOCTYPE HTML>

      
[%settitle Ссылки в ресурсах%]
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
[%file newheader%]
</head>
<body>
[%file newnavbar%]

<div class="col-9">

<%refheader base%>

<a name="Reference"> </a>
<a name="reference"> </a>
<a name="Resource"> </a>
<a name="references"> </a>
<a name="Identification"> </a>
<h2>Ссылки между ресурсами</h2>

<p>
Большинство определенных в ресурсе элементов являются ссылками на другие ресурсы. С помощью этих ссылок ресурсы комбинируются для построения сети информации о здравоохранении. 
</p>
<p>
Ресурсы содержат два типа ссылок:
</p>
<ul>
 <li><b>Внутренние "вложенные" ссылки</b> - ссылки на другие ресурсы, заключенные внутри исходного ресурса</li>
 <li><b>Внешние ссылки</b> - ссылки из ресурсов, находящихся в другом месте</li>
<!--  <li><b>Internal "contained" references</b> - references to other resources packaged inside the source resource</li>
 <li><b>External references</b> - references from resources found elsewhere</li> -->
</ul>
<p>
Ссылки всегда определяются и представляются в одном конкретном направлении - от одного ресурса (источника) к другому (цели). Ссылки указываются в виде URL-адресов, которые могут быть абсолютными или относительными. Алгоритм разрешения ссылок обсуждается ниже.
</p>
<p>
Соответствующая обратная связь от цели к источнику существует в логическом смысле, но не представлена в ресурсе явно. Для внешних ссылок перемещение по таким обратным связям требует от некоторой внешней инфраструктуры отслеживания связей между ресурсами (<a href="http.html">REST API</a> предоставляет такую инфраструктуру, обеспечивая возможность <a href="http.html#search">поиска</a> обратной связи с помощью именования параметров поиска для ссылок).
</p>
<p>
Т. к. ресурсы обрабатываются независимо, взаимосвязи не считаются переходными. Например, если ресурс <a href="condition.html">Condition</a> ссылается на конкретного 
<a href="patient.html">Patient</a> в качестве своего объекта и ссылается на ресурс <a href="procedure.html">Procedure</a>
в качестве его основания, то нет автоматического правила или вывода, что эта процедура в качестве своего объекта ссылается на того же самого пациента. Напротив, объект процедуры должен устанавливаться непосредственно в самой процедуре. 
Другими словами, контекст объекта не "наследуется" и не "вытекает" из связи с процедурой. Единственное исключение этому - случай вложенных ресурсов (см. ниже). Обратите внимание, что на практике эти взаимосвязи действительно должны описывать логическую и не противоречивую запись, и в описанном здесь примере с Condition и Procedure они, как правило, должны будут  иметь одного пациента в качестве объекта.
</p>

<p>
В ресурсе ссылки обозначаются ссылкой и текстовым описанием. Ключевым элементом является <i>reference</i>: ресурсы идентифицируются и адресуются с помощью URL-ссылок. Реальная ссылка выглядит так:
</p>

[%dt Reference 1%]

<p>&nbsp;</p>

<p>Примечания:</p>
<ul>
 <li>Элемент <i>reference</i> содержит URL, являющийся либо:
   <ul>
     <li>абсолютным URL</li>
     <li>относительным URL по отношению к <a href="http.html#root">служебному базовому URL</a> или, в комплекте, <a href="#bundle-refs">контекстом комплекта</a></li>
     <li>внутренней ссылкой на фрагмент (см. "Вложенные ресурсы" ниже)</li>
   </ul>
 </li>
 <li>Использование абсолютных URL адресов обеспечивает стабильный масштабируемый подход, подходящий для облачного/веб окружения, в то время как использование относительных/логических ссылок обеспечивает гибкий подход, подходящий для использования при торговле через границы закрытых экосистем (см. <a href="implementation.html#identity">проблемы реализации</a> для дальнейшего обсуждения)</li>
 <li>Абсолютные URL-адреса не обязательно должны указывать на  <a href="http.html">FHIR RESTful сервер</a>, хотя это и предпочтительный подход. Ведет ли ссылка на FHIR RESTful сервер или нет, она ДОЛЖНА указывать на Ресурс как определено в данной спецификации.
	<br/>Примечание: данное регулярное выражение будет выполняться, если ссылка на ресурс соответствует FHIR API: 
	<!-- Note: This regex is true if the reference to a resource is consistent with a FHIR API: -->
   <pre>
   ((http|https)://([A-Za-z0-9\\\/\.\:\%\$])*)?([%piperesources%])\/[%id_regex%](\/_history\/[%id_regex%])?
   </pre>
   <br/>
   Однако соответствие этому регулярному выражению не является гарантией того, что конечной точкой будет сервер FHIR
  <!--  However conformance with this regex is no guarantee that the end point is a FHIR server -->
	</li>
 <li>URL-адреса всегда считаются чувствительными к регистру.</li>
 <li>Элемент <i>display</i>, если заполнен, в основном не имеет идентичного содержимого в Resource.text ссылаемого ресурса. Его цель  - обозначить, на что идет ссылка, а не более полно описать это.</li>
</ul>

<div class="example">
<p>Относительная ссылка на <a href="patient.html">пациента</a> "034AB16"  в элементе "context" на FHIR RESTful сервере:</p>
<pre class="xml" fragment="Reference">
  &lt;context&gt;
    &lt;reference value="Patient/034AB16" /&gt;
  &lt;/context&gt;
</pre>
<p>Абсолютная ссылка на <a href="structuredefinition.html">Structure Definition</a> в элементе "profile":</p>
<pre class="xml" fragment="Reference">
  &lt;profile&gt;
    &lt;reference value="http://fhir.hl7.org/svc/StructureDefinition/c8973a22-2b5b-4e76-9c66-00639c99e61b" /&gt;
  &lt;/profile&gt;
</pre>
<p><i>Обратите внимание, что в действительности HL7 пока что не создал ни реестр профилей, ни URL-адрес для него</i>.</p>
<p>
В элементе display можно задать короткий текст с человекочитаемым описанием ресурса:
</p>
<pre class="xml" fragment="Reference">
  &lt;custodian&gt;
    &lt;reference value="Organization/123" /&gt;
    &lt;display value="HL7, Inc" /&gt;
  &lt;/custodian&gt;
</pre>
<p>
Этот текст может использоваться системой, которая не в состоянии разрешить ссылку непосредственно на сам ресурс.
</p>
</div>

<a name="contained"> </a>
<h3>Вложенные ресурсы</h3>
<p>
В некоторых обстоятельствах содержимое, на которое ссылаются в ссылке на ресурс, не существует отдельно от ресурса, в который оно вложено: оно не может быть идентифицировано независимо и не может иметь своей собственной независимой области транзакций. Обычно такие ситуации случаются, когда ресурс собирается вторичным пользователем источника данных, таким как межплатформенный механизм (middleware engine). Если данные, доступные во время построения ресурса, не содержат ключей записи или информации об абсолютной идентификации, тогда не возможно собрать правильно идентифицированный ресурс, и даже если с ним была ассоциирована свободная идентификация, ресурс никогда не сможет быть объектом транзакции вне контекста ресурса, который на него ссылается.
</p>
<p>
Например рассмотрим ситуацию, когда механизм интерфейса создает запись <a href="condition.html">Condition</a>
для пациента из сообщения HL7 v2, и единственная информация о главном хирурге (primary surgeon) - это ее имя и фамилия (REL-7.2 и RES-7.3). В отсутствие контролируемого каталога врачей этой информации не достаточно для создания идентифицированного ресурса <a href="practitioner.html">Practitioner</a>: несколько врачей могут иметь одинаковые имена. 
</p>
<p>
В таком случае ресурс помещается прямо внутрь другого ресурса. <b>Этого не следует делать, когда содержимое может быть должным образом идентифицировано, поскольку однажды потеряв возможность его идентифицировать, будет чрезвычайно сложно (и контекстно-зависимо) снова восстановить ее.</b>
</p>
<div class="example">
<p>
Пример вложенного ресурса:
</p>
<pre class="xml"> <!-- Can't fragment test this - too incomplete -->
 &lt;Composition xmlns="http://hl7.org/fhir"&gt;
  &lt;extension&gt;...&lt;/extension&gt;
  &lt;text&gt;...&lt;/text&gt;
  &lt;contained&gt;
    &lt;Organization&gt;
      &lt;id value=&quot;org1&quot;/&gt;
      &lt;!-- whatever information is available --&gt;
    &lt;/Organization&gt;
  &lt;/contained&gt;
  &lt;information&gt;
    &lt;!-- other attributes --&gt;
    &lt;custodian&gt;
      &lt;reference value="#org1" /&gt;
    &lt;/custodian&gt;
    &lt;!-- other attributes --&gt;
  &lt;information&gt;
 &lt;/Composition&gt;
</pre>
<p>
Этот же пример в JSON-формате:
</p>
<pre class="json"> 
{ "resourceType" : "Composition",
  "extension" : { ... },
  "text" : { .. },
  "contained: [
    {
      "resourceType" : "Organization",
      "id" : "org1",
      .. whatever information is available ...
	}  ]
  "information: {
    ... other attributes ...
    "custodian" : {
      "reference" : "#org1"
	}
    ... other attributes ...
  }
}
</pre>
</div>
<blockquote>
<div class="design-note">
<p>
Примечание разработчика: Вложенные ресурсы по-прежнему остаются ссылками, вместо того чтобы встраиваться непосредственно в элемент-ссылку (например "custodian" выше), чтобы гарантировать возможность использования единого подхода к разрешению ссылок на ресурсы. Хотя прямое включение и кажется проще, было бы все еще необходимо поддерживать внутренние ссылки, где на один и тот же содержащийся внутри ресурс могут ссылаются более одного раза. В конечном счете всё, чего бы мы достигли этим, это создание дополнительных опций синтаксиса. Для пользователей, применяющих XPath для обработки ресурса, следующий фрагмент XPath разрешается во внутреннюю ссылку:
</p>
<pre>
ancestor::f:*[not(parent::f:*)]/f:contained/*[@id=substring-after(<b>current()</b>/f:reference/@value, '#')]
</pre>
</div>
</blockquote>
<p>
Некоторые примечания к использованию и интерпретации вложенных ресурсов:
</p>

<ul>
  <li>The "contained" element SHALL NOT have extensions on it (though contained resources can still contain extensions)</li>
  <li>Вложенные ресурсы разделяют одно пространство разрешения внутренних id, что и родительский ресурс (for id attributes, see below)</li>
  <li>Вложенные ресурсы НЕ ДОЛЖНЫ содержать других вложенных ресурсов</li>
  <li>Вложенные ресурсы НЕ ДОЛЖНЫ содержать описательную часть (narrative)</li>
  <li>Вложенный ресурс может быть включен в другой ресурс, только если в этом ресурсе есть непосредственная отсылка к нему:
<!--
A contained resource can only be included in another resource if something in the resource actually refers to it:
-->
</li>
</ul>
<div class="use">
<p><b>Ограничения (Constraints)</b></p>
<p>
[%dt.constraints Reference%]
</p>

</div>

<h4>Контекст внутри ресурса<!-- Context Inside a Resource --></h4>
<p>
Ресурсы, которые вложены непосредственно, могут также "наследовать" контекст своего родительского ресурса. К примеру, если родительский ресурс содержит "subject", и у вложенного ресурса также есть элемент "subject", но его значение не задано, обрабатывающее приложение может сделать вывод, что эти значения совпадают.
<!-- Resources that are contained inline may also "inherit" context from their parent resource. For instance, if
the parent resource contains a "subject", and the contained resource also has a "subject" element defined,
but does not specify any subject, a processing application might infer that the subject is the same. -->
</p>
<p>
Однако FHIR не предоставляет никакого механизма задания или ограничения вывода "эквивалентных" свойств из родительского ресурса во вложенный - даже объявлением использования определенного профиля.
Рекомендуется явно включать все известные свойства вложенных ресурсов, даже если это будет избыточно вместе со свойствами родительского ресурса. Например если родительский и вложенный ресурсы оба содержат элемент "subject", оба элемента должны присутствовать, даже если они ссылаются на один и тот же ресурс. Приложения, которые решат опускать избыточные элементы вложенных ресурсов, не должны ожидать от других приложений делать вывод (или корректно заключать) намеченное значение в таких случаях. Приложения не могут безопасно полагать, что опущенные элементы во вложенных ресурсах могут быть безопасно выводиться как совпадающие с родительским ресурсом. 
Любая попытка оптимизировать содержимое ресурса "проведением" значения из родительского во вложенный ресурс должна управляться через внешнее соглашение и должна выполняться с признанием того факта, что любой получатель, не являющийся участником этого соглашения, может не выполнить правильных (или вообще каких-либо) выводов.
<!-- However FHIR provides no mechanism for defining or constraining any conduction of "equivalent" properties 
from a containing resource into any contained resource - not even by declaring the use of a particular profile.
Best practice is to explicitly include all known properties on contained resources, even if redundant with 
properties on the containing resource.  E.g. If the containing resource and contained resource both have a 
"subject" element, both elements should be present, even if they reference the same resource.  Applications that 
choose to omit redundant elements on contained resources should not expect other applications to infer 
(or correctly infer) the intended meaning in this case.  Applications cannot safely presume that omitted 
elements in contained resources can safely be inferred to be the same as the containing resource.  
Any attempt to optimize resource content by 'conducting' meaning from containing to contained resources must 
be managed through out-of-band agreement and must be done with the recognition that any receiver not party 
to that agreement may not make correct (or any) inferences. -->
</p>
    
<a name="bundle-refs"> </a>
<h3>Разрешение ссылок на ресурсы в комплектах (Bundles)</h3>
<p>
При обработке комплектов приложениям при обнаружении <a href="#Resource">ссылки на ресурс</a> всегда следует искать ресурсы сначала в этом комплекте.
</p>
<div class="example">
<pre class="xml" fragment="Reference">
  &lt;institution&gt;
    &lt;reference value="Organization/23" /&gt;
  &lt;/institution&gt;
  &lt;institution&gt;
    &lt;reference value="Organization/ex/_history/2" /&gt;
  &lt;/institution&gt;
</pre>
</div>
<p>
тогда приложению следует искать любую запись в комплекте, где entry.id точно совпадает с URL-ссылкой:
</p>
<div class="example">
<pre class="xml">
   .. bundle ..
  &lt;>base value="http://acme.com/fhir"/&gt;
  &lt;entry>
    &lt;resource>
    &lt;Organization xmlns="http://hl7.org/fhir">
       &lt;id value="23"/&gt;
       &lt;!-- Content for the resource --&gt;
    &lt;/Organization>
    &lt;/resource>
  &lt;entry>

  &lt;entry>
    &lt;resource>
    &lt;Organization xmlns="http://hl7.org/fhir">
      &lt;id value="ex"/&gt;
      &lt;meta&gt;
        &lt;versionId value="2"/&gt;
      &lt;/meta&gt;
      &lt;!-- Content for the resource --&gt;
    &lt;/Organization>
    &lt;/resource>
  &lt;entry>
    ... bundle ...
</pre>
</div>
<p>
Во втором случае совпадение основано на конкретной версии ресурса. Note that the matching is based on full URLs by prepending
the base for the entry (see <a href="bundle.html#resolving">"Bundles" for further information</a>).
Если ссылка на ресурс не может быть разрешена внутри комплекта, приложение ДОЛЖНО иметь возможность получить ресурс, следуя прямо по приведенной URL-ссылке. Если это невозможно, ему придется использовать некоторый другой, специфичный для реализации, метод поиска ресурса.
</p>
<p>
Если ссылка на ресурс является абсолютным URL, применяется тот же базовый принцип: сначала попытка разрешить ссылку в комплекте, затем поиск вне его. Однако перед тем, как это можно будет сделать, абсолютный URL must 
be compared to the stated based URL, in <a href="bundle-definitions.html#Bundle.base">Bundle.base</a>;
if these do not match, the resource is not in the bundle. <i>todo-bundle: how to mix content?</i>
</p>
<!--
<p>
Note that the application SHOULD not assume that the base
service root is actually resolvable. In some circumstances, it will. 
If the bundle has just been received from a server as a result of 
a search or a history operation, the service root URL SHOULD match
the URL that the client used (it is allowed not to in order to 
cater for proxies of various kinds). However in other 
circumstances, where the bundle itself has been exchanged onwards
from the point of origin, and/or stored as an entity in its own 
right (e.g. a <a href="documents.html">clinical document</a>) the 
service root URL is merely a logical construct that holds within the 
bundle when resolving resources, and will have no meaning outside 
the bundle. 
</p>
-->

<p>
Обратите внимание, что некоторые элементы имеют тип "<a href="datatypes.html#uri">uri</a>", а не "Reference". 
URIs могут вести либо на ресурсы, элементы внутри ресурса по их свойству "id", либо (наиболее часто) некоторое другое содержимое, не являющееся ресурсом. Тип Reference используется только чтобы ссылаться непосредственно на ресурсы по их логическому id.
</p>


<!--
<li>
<a name="Ids"> </a>
FHIR resources make use of id attributes as targets for <a href="references.html#id">internal references with resources</a>. 
These id attributes are unique and resolved within the context of a single resource. When resources are 
combined into a bundle, different resources may contain duplicate id attributes. Thus it is important to limit
the scope of resolution of an id attribute to the resource in which the <i>id</i> attribute is declared.
</li>

-->
</div>

[%file newfooter%]

  <script src="external/jquery/jquery.js"> </script>
<script src="jquery-ui.min.js"> </script>
<script>
 try {
   var currentTabIndex = sessionStorage.getItem('fhir-resource-tab-index');
 } catch(exception){ 
 }
 if (!currentTabIndex)
   currentTabIndex = '0';

$( '#tabs-Reference' ).tabs({ active: currentTabIndex, activate: function( event, ui ) { store(ui.newTab.index()); } });
     
     
function store(currentTab) {
  document.activeElement.blur();
  try {
    sessionStorage.setItem('fhir-resource-tab-index', currentTab);
  } catch(exception){ 
  }
  $( '#tabs-Reference' ).tabs('option', 'active', currentTab);
}     
</script>


</body>
</html>
