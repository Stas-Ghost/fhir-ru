<!DOCTYPE HTML>

      
[%settitle Ссылки в ресурсах%]
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
[%file newheader%]
</head>
<body>
[%file newnavbar%]

<div class="col-9">

<%refheader base%>

<a name="Reference"> </a>
<a name="reference"> </a>
<a name="Resource"> </a>
<a name="references"> </a>
<a name="Identification"> </a>
<h2>Ссылки между ресурсами</h2>

<p>
Большинство определенных в ресурсе элементов являются ссылками на другие ресурсы. С помощью этих ссылок ресурсы комбинируются для построения сети информации о здравоохранении. 
</p>
<p>
Ресурсы содержат два типа ссылок:
</p>
<ul>
 <li><b>Internal "contained" references</b> - references to other resources packaged inside the source resource</li>
 <li><b>External references</b> - references from resources found elsewhere</li>
</ul>
<p>
Ссылки всегда определяются и представляются в одном конкретном направлении - от одного ресурса (источника) к другому (цели). Ссылки указываются в виде URL-адресов, которые могут быть абсолютными или относительными. Алгоритм разрешения ссылок обсуждается ниже.
</p>
<p>
Соответствующая обратная связь от цели к источнику существует в логическом смысле, но не представлена в ресурсе явно. Для внешних ссылок перемещение по таким обратным связям требует от некоторой внешней инфраструктуры отслеживания связей между ресурсами (<a href="http.html">REST API</a> предоставляет такую инфраструктуру, обеспечивая возможность <a href="http.html#search">поиска</a> обратной связи с помощью именования параметров поиска для ссылок).
</p>
<p>
Т. к. ресурсы обрабатываются независимо, взаимосвязи не считаются переходными. Например, если ресурс <a href="condition.html">Condition</a> ссылается на конкретного 
<a href="patient.html">Patient</a> в качестве своего объекта и связан с ресурсом <a href="procedure.html">Procedure</a>
в качестве его основания, то нет автоматического правила или вывода, что эта процедура в качестве своего объекта ссылается на того же самого пациента. Напротив, объект процедуры должен устанавливаться непосредственно в самой процедуре. 
Другими словами, контекст объекта не "наследуется" и не "вытекает" из связи с процедурой. Единственное исключение этому - в случае вложенных ресурсов (см. ниже). Обратите внимание, что на практике эти взаимосвязи действительно должны описывать логическую и не противоречивую запись, и в описанном здесь примере с Condition и Procedure они, как правило, должны будут  иметь одного пациента в качестве объекта.
</p>

<p>
В ресурсе ссылки обозначаются ссылкой и текстовым описанием. Ключевым элементом является <i>reference</i>: ресурсы идентифицируются и адресуются с помощью URL-ссылок. Реальная ссылка выглядит так:
</p>

[%dt Reference%]

<p>&nbsp;</p>

<p>Примечания:</p>
<ul>
 <li>Элемент <i>reference</i> содержит URL, являющийся либо:
   <ul>
     <li>абсолютным URL</li>
     <li>относительным URL по отношению к <a href="http.html#root">служебному базовому URL</a> или, в комплекте, <a href="#atom-refs">контекстом комплекта</a></li>
     <li>внутренней ссылкой на фрагмент (см. "Вложенные ресурсы" ниже)</li>
   </ul>
 </li>
 <li>Использование абсолютных URL адресов обеспечивает стабильный масштабируемый подход, подходящий для облачного/веб окружения, в то время как использование относительных/логических ссылок обеспечивает гибкий подход, подходящий для использования при торговле через границы закрытых экосистем (см. <a href="implementation.html#identity">проблемы реализации</a> для дальнейшего обсуждения)</li>
 <li>Абсолютные URL-адреса не обязательно должны указывать на  <a href="http.html">FHIR RESTful сервер</a>, хотя это и предпочтительный подход. Ведет ли ссылка на FHIR RESTful сервер или нет, она ДОЛЖНА указывать на Ресурс как определено в данной спецификации.</li>
 <li>URL-адреса всегда считаются чувствительными к регистру.</li>
 <li>Элемент <i>display</i>, если заполнен, в основном не имеет идентичного содержимого в Resource.text ссылаемого ресурса. Его цель  - обозначить, на что идет ссылка, а не более полно описать это.</li>
</ul>

<div class="example">
<p>Относительная ссылка на <a href="patient.html">пациента</a> "034AB16"  в элементе "context" на FHIR RESTful сервере:</p>
<pre class="xml" fragment="Reference">
  &lt;context&gt;
    &lt;reference value="Patient/034AB16" /&gt;
  &lt;/context&gt;
</pre>
<p>Абсолютная ссылка на <a href="profile.html">профиль ресурса</a> в элементе "profile":</p>
<pre class="xml" fragment="Reference">
  &lt;profile&gt;
    &lt;reference value="http://fhir.hl7.org/svc/Profile/c8973a22-2b5b-4e76-9c66-00639c99e61b" /&gt;
  &lt;/profile&gt;
</pre>
<p><i>Обратите внимание, что в действительности HL7 пока что не создал ни реестр профилей, ни URL-адрес для него</i>.</p>
<p>
В элементе display можно задать короткий текст с человекочитаемым описанием ресурса:
</p>
<pre class="xml" fragment="Reference">
  &lt;custodian&gt;
    &lt;reference value="Organization/123" /&gt;
    &lt;display value="HL7, Inc" /&gt;
  &lt;/custodian&gt;
</pre>
<p>
Этот текст может использоваться системой, которая не в состоянии разрешить ссылку непосредственно на сам ресурс.
</p>
</div>

<a name="contained"> </a>
<h3>Вложенные ресурсы</h3>
<p>
В некоторых обстоятельствах содержимое, на которое ссылаются в ссылке на ресурс, не существует отдельно от ресурса, в который оно вложено: оно не может быть идентифицировано независимо и не может иметь своей собственной независимой области транзакций. Обычно такие ситуации случаются, когда ресурс собирается вторичным пользователем источника данных, таким как межплатформенный механизм (middleware engine). Если данные, доступные во время построения ресурса, не содержат ключей записи или информации об абсолютной идентификации, тогда не возможно собрать правильно идентифицированный ресурс, и даже если с ним была ассоциирована свободная идентификация, ресурс никогда не сможет быть объектом транзакции вне контекста ресурса, который на него ссылается.
</p>
<p>
Например рассмотрим ситуацию, когда механизм интерфейса создает запись <a href="condition.html">Condition</a>
для пациента из сообщения HL7 v2, и единственная информация о главном хирурге (primary surgeon) - это ее имя и фамилия (REL-7.2 и RES-7.3). В отсутствие контролируемого каталога врачей этой информации не достаточно для создания идентифицированного ресурса <a href="practitioner.html">Practitioner</a>: несколько врачей могут иметь одинаковые имена. 
</p>
<p>
В таком случае ресурс помещается прямо внутрь другого ресурса. <b>Этого не следует делать, когда содержимое может быть должным образом идентифицировано, поскольку однажды потеряв возможность его идентифицировать, будет чрезвычайно сложно (и контекстно-зависимо) снова восстановить ее.</b>
</p>
<div class="example">
<p>
Пример вложенного ресурса:
</p>
<pre class="xml"> <!-- Can't fragment test this - too incomplete -->
 &lt;Composition xmlns="http://hl7.org/fhir"&gt;
  &lt;extension&gt;...&lt;/extension&gt;
  &lt;text&gt;...&lt;/text&gt;
  &lt;contained&gt;
    &lt;Organization&gt;
      &lt;id value=&quot;org1&quot;/&gt;
      &lt;!-- whatever information is available --&gt;
    &lt;/Organization&gt;
  &lt;/contained&gt;
  &lt;information&gt;
    &lt;!-- other attributes --&gt;
    &lt;custodian&gt;
      &lt;reference value="#org1" /&gt;
    &lt;/custodian&gt;
    &lt;!-- other attributes --&gt;
  &lt;information&gt;
 &lt;/Composition&gt;
</pre>
<p>
Этот же пример в JSON-формате:
</p>
<pre class="json"> 
{ "resourceType" : "Composition",
  "extension" : { ... },
  "text" : { .. },
  "contained: [
    {
      "resourceType" : "Organization",
      "id" : "org1",
      .. whatever information is available ...
	}  ]
  "information: {
    ... other attributes ...
    "custodian" : {
      "reference" : "#org1"
	}
    ... other attributes ...
  }
}
</pre>
</div>
<blockquote>
<div class="design-note">
<p>
Примечание разработчика: Вложенные ресурсы по-прежнему остаются ссылками, вместо того чтобы встраиваться непосредственно в элемент-ссылку (например "custodian" выше), чтобы гарантировать возможность использования единого подхода к разрешению ссылок на ресурсы. Хотя прямое включение и кажется проще, было бы все еще необходимо поддерживать внутренние ссылки, где на один и тот же содержащийся внутри ресурс могут ссылаются более одного раза. В конечном счете всё, чего бы мы достигли этим, это создание дополнительных опций синтаксиса. Для пользователей, применяющих XPath для обработки ресурса, следующий фрагмент XPath разрешается во внутреннюю ссылку:
</p>
<pre>
ancestor::f:*[not(parent::f:*)]/f:contained/*[@id=substring-after(<b>current()</b>/f:reference/@value, '#')]
</pre>
</div>
</blockquote>
<p>
Некоторые примечания к использованию и интерпретации вложенных ресурсов:
</p>

<ul>
  <li>The "contained" element SHALL NOT have extensions on it (though contained resources can still contain extensions)</li>
  <li>Вложенные ресурсы разделяют одно пространство разрешения внутренних id, что и родительский ресурс (for id attributes, see below)</li>
  <li>Вложенные ресурсы НЕ ДОЛЖНЫ содержать других вложенных ресурсов</li>
  <li>Вложенные ресурсы НЕ ДОЛЖНЫ содержать описательную часть (narrative)</li>
  <li>Ресурсы, содержащиеся внутри, также "наследуют" контекст от их родительского ресурса. Например, если родительский ресурс содержит "subject", и вложенный ресурс также имеет определенный элемент subject, но не указывает никакого объекта, обрабатывающее приложение может заключить, что объект тот же самый. Обратите внимание, однако, что подобные заключения являются специфичными для конкретной ситуации. Нет правила, к примеру, что значение элемента "subject" совпадает в родительском и вложенном ресурсах</li>
  <li>A contained resources can only be included in another resource if something in the resource actually refers to it:</li>
</ul>
<div class="use">
<p><b>Ограничения (Constraints)</b></p>
<p>
[%dt.constraints Reference%]
</p>

</div>

<a name="bundle-refs"> </a>
<h3>Разрешение ссылок на ресурсы в комплектах (Bundles)</h3>
<p>
При обработке комплектов приложениям при обнаружении <a href="#Resource">ссылки на ресурс</a> всегда следует искать ресурсы сначала в этом комплекте.
</p>
<div class="example">
<pre class="xml" fragment="Reference">
  &lt;institution&gt;
    &lt;reference value="Organization/23" /&gt;
  &lt;/institution&gt;
  &lt;institution&gt;
    &lt;reference value="Organization/ex/_history/2" /&gt;
  &lt;/institution&gt;
</pre>
</div>
<p>
тогда приложению следует искать любую запись в комплекте, где либо entry.id, либо entry.link[self] точно совпадает с URL-ссылкой:
</p>
<div class="example">
<pre class="xml">
   .. bundle ..
  &lt;item>
    &lt;Organization xmlns="http://hl7.org/fhir">
       &lt;id value="23"/&gt;
       &lt;!-- Content for the resource --&gt;
    &lt;/Organization>
  &lt;item>

  &lt;item>
    &lt;Organization xmlns="http://hl7.org/fhir">
      &lt;id value="ex"/&gt;
      &lt;meta&gt;
        &lt;versionId value="2"/&gt;
      &lt;/meta&gt;
      &lt;!-- Content for the resource --&gt;
    &lt;/Organization>
  &lt;item>
    ... bundle ...
</pre>
</div>
<p>
Во втором случае совпадение основано на конкретной версии ресурса. Если ссылка на ресурс не может быть разрешена внутри комплекта, приложение ДОЛЖНО иметь возможность получить ресурс, следуя прямо по приведенной URL-ссылке. Если это невозможно, ему придется использовать некоторый другой, специфичный для реализации, метод поиска ресурса.
</p>
<p>
Если ссылка на ресурс является абсолютным URL, применяется тот же базовый принцип: сначала попытка разрешить ссылку в комплекте, затем поиск вне его. Однако перед тем, как это можно будет сделать, абсолютный URL must 
be compared to the stated based URL, in <a href="bundle-definitions.html#Bundle.base">Bundle.base</a>;
if these do not match, the resource is not in the bundle. <i>todo-bundle: how to mix content?</i>
</p>
<!--
<p>
Note that the application SHOULD not assume that the base
service root is actually resolvable. In some circumstances, it will. 
If the bundle has just been received from a server as a result of 
a search or a history operation, the service root URL SHOULD match
the URL that the client used (it is allowed not to in order to 
cater for proxies of various kinds). However in other 
circumstances, where the bundle itself has been exchanged onwards
from the point of origin, and/or stored as an entity in its own 
right (e.g. a <a href="documents.html">clinical document</a>) the 
service root URL is merely a logical construct that holds within the 
bundle when resolving resources, and will have no meaning outside 
the bundle. 
</p>
-->

<p>
Обратите внимание, что некоторые элементы имеют тип "<a href="datatypes.html#uri">uri</a>", а не "Reference". 
URIs могут вести либо на ресурсы, элементы внутри ресурса по их свойству "id", либо (наиболее часто) некоторое другое содержимое, не являющееся ресурсом. Тип Reference используется только чтобы ссылаться непосредственно на ресурсы по их логическому id.
</p>


<!--
<li>
<a name="Ids"> </a>
FHIR resources make use of id attributes as targets for <a href="references.html#id">internal references with resources</a>. 
These id attributes are unique and resolved within the context of a single resource. When resources are 
combined into a bundle, different resources may contain duplicate id attributes. Thus it is important to limit
the scope of resolution of an id attribute to the resource in which the <i>id</i> attribute is declared.
</li>

-->
</div>

[%file newfooter%]

  <script src="external/jquery/jquery.js"> </script>
<script src="jquery-ui.min.js"> </script>
<script>
 try {
   var currentTabIndex = sessionStorage.getItem('fhir-resource-tab-index');
 } catch(exception){ 
  if (navigator.userAgent.toLowerCase().indexof('msie') == -1)
    alert(exception);
 }
 if (!currentTabIndex)
   currentTabIndex = '0';

$( '#tabs-Reference' ).tabs({ active: currentTabIndex, activate: function( event, ui ) { store(ui.newTab.index()); } });
     
     
function store(currentTab) {
  try {
    sessionStorage.setItem('fhir-resource-tab-index', currentTab);
  } catch(exception){ 
  if (navigator.userAgent.toLowerCase().indexof('msie') == -1)
    alert(exception);
  }
  $( '#tabs-Reference' ).tabs('option', 'active', currentTab);
}     
</script>


</body>
</html>
