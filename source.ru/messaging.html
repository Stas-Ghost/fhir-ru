<!DOCTYPE HTML>


[%settitle Обмен сообщениями с помощью FHIR-ресурсов%]
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
[%file newheader%]
</head>
<body>
[%file newnavbar%]

<div class="col-9">

<h1>Обмен сообщениями с помощью FHIR-ресурсов</h1>

<p>
FHIR-ресурсы могут использоваться в контексте традиционного обмена сообщениями подобно HL7 v2. Приложения, декларирующие соответствие этому фреймворку, заявляют о совместимости с "обменом сообщениями в FHIR".
</p>

<p>
В FHIR-обмене сообщениями "сообщение-запрос (request message)" отправляется из приложения-источника в приложение-получатель, когда происходит некоторое событие. События в основном соответствуют явлениям реального мира. Сообщение-запрос состоит из <a href="bundle.html">Bundle</a> с указанным <a href="bundle-definitions.html#Bundle.type">типом</a> "message", первым в комплекте идет ресурс <a href="messageheader.html">MessageHeader</a>. Ресурс MessageHeader содержит код - событие сообщения - который определяет природу происхождения сообщения-запроса, а также несет в себе дополнительные метаданные запроса. Остальные ресурсы в комплекте зависят от типа этого запроса.
</p>
<p>
События, поддержанные спецификацией FHIR наряду с ресурсами, которые в них входят, описаны ниже.
</p>
<p>
Приложение-получатель обрабатывает запрос и возвращает один или несколько ответных сообщений, также являющихся <a href="bundle.html">комплектом</a> ресурсов с указанным <a href="bundle-definitions.html#Bundle.type">типом</a> "message", первым в комплекте идет ресурс <a href="messageheader.html">MessageHeader</a> с разделом для ответа, в котором передаются результаты обработки сообщения и все требуемые дополнительные ответные ресурсы.
</p>
<ul>
 <li>Пример сообщения-запроса (Request Message): <a href="query-example-request.xml.html">XML</a> или <a href="query-example-request.json.html">JSON</a></li>
 <li>Пример сообщения-ответа (Response Message): <a href="query-example-response.xml.html">XML</a> или <a href="query-example-response.json.html">JSON</a></li>
</ul>

<h2>Основные допущения при передаче сообщений (Basic Messaging Assumptions)</h2>

<p>
Данная спецификация предполагает, что содержимое будет доставлено из одного приложения в другое некоторым механизмом доставки, а затем один или несколько ответов будут возвращены приложению-источнику. Описание самого механизма передачи неуместно в данной спецификации, но может включать передачу файлов, передачу на основе HTTP, MLLP (HL7-протокол минимального нижнего уровня), серию сообщений MQ или любые другие. Единственное требование к уровню передачи состоит в том, чтобы запросы отправлялись в указанное место, а ответы возвращались к источнику запроса. Данная спецификация рассматривает приложение-источник и приложение-приемник в качестве логических сущностей, а нахождение соответствия между логическими источником и приемником и специфичными для реализаций адресами лежит вне этой спецификации, хотя спецификация и предоставляет прямой механизм доставки ниже.
</p>
<p>
Соглашения о содержимом сообщений и поведении двух приложений образуют "контракт", который описывает этот обмен. Такой контракт будет добавлять региональные и локальные соглашения к правилам, установленным в этой спецификации.
</p>
<p>
Данная спецификация игнорирует существование интерфейсных механизмов и агентов передачи сообщений, которые существуют между <i>источником</i> и <i>назначением</i>. 
Либо они прозрачны для содержимого сообщения/транзакции и независимы от данной спецификации, либо они активно вовлечены в оперирование содержимым сообщений (в частности, заголовки источника и назначения часто меняются). Если эти промежуточные агенты модифицируют содержимое сообщения, тогда они становятся ответственными за исполнение контракта, который применяется (включая подходящие профили) в обоих направлениях.
</p>
<p>
Ключевой аспект сообщения составляет влияние его содержания:
</p>
[%codelist MessageSignificanceCategory%]
<p>
Некоторые события, определенные FHIR, отнесены к одной из описанных категорий, но остальные не возможно категоризировать заранее, поэтому категория должна определяться содержимым или контекстом.
</p>

<a name="synchronous"> </a>
<a name="patterns"> </a>
<h3>Message Exchange Patterns</h3>
<p>
Каждый FHIR-запрос имеет одно или несколько ответных сообщений. Должно быть по крайней мере одно ответное сообщение, чтобы отправитель мог узнать, что сообщение было должным образом получено. Множественный ответ НЕ ДОЛЖЕН возвращаться для сообщений типа consequence, и его НЕ СЛЕДУЕТ возвращать для уведомлений.
</p>
<p>
В принципе, приложениям-источникам не требуется дожидаться ответа на транзакцию для запуска новой транзакции. Однако во многих случаях сообщения в данном потоке зависят друг от друга и должны отправляться и обрабатываться по порядку.  К тому же некоторые методы передачи могут требовать последовательной доставки сообщений.
</p>
<p>
По этой причине схема синхронного обмена - где отправитель отсылает сообщение и ждет на этом же канале одиночного ответа, а затем высылает новое сообщение - самая простая для понимания и управления. Таким образом работает <a href="#mailbox">mailbox</a>, описанный ниже.
</p>
<p>
Однако синхронный обмен сообщениями не обслуживает множественные ответные сообщения, которые может возникнуть при обработке запросов, а также налагает ограничения пропускной способности, которые при высоких объемах могут стать значительными. К тому же ожидание ответных сообщений может быть непрактично или неуместно. В таких случаях следует использовать асинхронную схему обмена сообщениями, <a href="#async">описанную ниже</a>.
</p>


<h3>MessageHeader.identifiers</h3>
<p>
Входящее сообщение имеет два идентификатора: Bundle.id и <a href="messageheader.html">MessageHeader</a>.identifier. 
Каждый раз при создании нового сообщения ему ДОЛЖЕН быть присвоен идентификатор (MessageHeader.identifier), являющийся уникальным в потоке этого сообщения. Обратите внимание, что так как потоки сообщений часто объединяются с другими потоками, рекомендуется, чтобы этот идентификатор был глобально уникальным. Этого можно достигнуть использованием  UUID или OID. Каждый раз, как сообщение отправляется, значение Bundle.id следует менять на новое.
</p>
<p>
 Когда получатель получает и обрабатывает сообщение, он отвечает новым сообщением с новым идентификатором, обернутым в комплект, который также имеет новый идентификатор. Ответное сообщение также цитирует MessageHeader.identifier запроса, для того чтобы система-источник могла установить связь между ответом и его запросом.
</p>

<a name="reliable"> </a>
<h3>Absence of Reliable Messaging</h3>
<p>
Некоторые из упомянутых выше механизмов доставки сообщений являются надежными системами доставки - сообщение всегда доставляется, либо источнику возвращается соответствующая ошибка. Однако большинство реализаций используют методы, которые не обеспечивают надежного обмена сообщениями, и либо запрос, либо ответ могут потеряться при передаче. Обмен сообщениями в FHIR описывает простой подход,  которому СЛЕДУЕТ соответствовать получателям, чтобы справляться с отсутствием надежного обмена сообщениями, поддерживающего предсказуемую функциональность.
</p>
<p>
Если отправитель сообщения применяет надежный обмен сообщениями, он ДОЛЖЕН сделать следующее, если не получил ответа на сообщение в течение заданного времени ожидания:
</p>
<table class="grid">
 <tr><td>Consequence</td><td>Послать это же сообщение повторно (с тем же идентификатором) с тем же Bundle.id</td></tr>
 <tr><td>Currency</td><td>Послать это же сообщение повторно (с тем же идентификатором) с другим Bundle.id</td></tr>
 <tr><td>Notification</td><td>Послать это же сообщение повторно (с тем же идентификатором) с другим Bundle.id</td></tr>
</table>
<p>
Когда получатель использует надежный обмен сообщениями, он ДОЛЖЕН проверять входящие Bundle.id и MessageHeader.identifier на наличие среди кешированных предыдущих полученных сообщений. Корректное действие, которое ему следует предпринять, зависит от результатов этой проверки:
</p>
<table class="grid">
 <tr><td>Такие Bundle.id и MessageHeader.identifier ещё не были получены</td><td>Это нормальный случай, и сообщение следует обработать</td></tr>
 <tr><td>Такие обертка (envelope) и сообщение уже были получены</td><td>Первоначальный ответ был потерян (не удалось вернуть отправителю запроса), и первоначальный ответ ДОЛЖЕН быть выслан повторно</td></tr>
 <tr><td>Такой MessageHeader.identifier уже был получен, а Bundle.id новый</td><td>Предыдущее полученное сообщение было отправлено на обработку еще раз. Сервер может либо повторно обработать, либо отклонить это сообщение</td></tr>
 <tr><td>Такой Bundle.id уже был получен, а MessageHeader.identifier новый</td><td>Это ошибка - значения Bundle.id никогда не должны использоваться повторно</td></tr>
</table>
<p>
Очень длинная продолжительность периода кеширования обычно не требуется. он может быть как минимум на 1 минуту больше тайм-аута системы отправки, хотя, возможно, потребуется его увеличить в зависимости от политики повторной отправки системы-отправителя.
</p>
<p>
Приложения, реализующие надежный обмен сообщениями, объявляют свой достоверный период кеширования в своих <a href="conformance.html">заявлениях о соответствии</a>.
</p>

<h4>Example: Consequence</h4>
<p>
В этом первом примере Clinical EHR выпускает ордер на совершение пациенту определенного томографического обследования. Полагается, что это будет сообщение типа Следствие (Consequence): не следует создавать многочисленные ордера (на практике имеются обычно процессы обзора человеком, которые охватывают несколько ордеров, но повторяющиеся ордера создают энтропию в системе, что является опасным). EHR отправляет сообщение, где Bundle.id - это UUID 1 (72edc4e0-6708-42ab-9734-f56721882c10) и
MessageHeader.identifier - это UUID 2 (dad53a57-dcb4-4f18-b066-7239eb4b5229).
</p>
<p>
EHR-система так и не получает ответа на это сообщение; она не знает, либо запрос потерялся, либо система управления изображениями не смогла обработать запрос, либо она успешно обработала сообщение, а ответ потерялся. В этом случает EHR-система отправляет сообщение повторно с этими же двумя идентификаторами.
</p>
<p>
В этом случае система управления изображениями успешно получает сообщение и обрабатывает его. Так как она получает повторный ордер через 1 минуту (что в пределах её 15-минутного времени кеширования), и оба UUID 1 и 2 совпадают с сообщением, которое она уже обработала, она знает, что уже обработала этот ордер и просто возвращает предыдущий ответ. В случае дополнительно высланных повторных запросов приложение продолжает отправлять первоначальный ответ, хотя может также сообщить системным администраторам о том, что одно и тоже первоначальное сообщение продолжает пересылаться, так как потерянные сообщения должны быть редким явлением.
</p>
<p>
Когда EHR-система наконец получает сообщение, она понимает, как ответила система управления изображениями; она может быть уверена в этом, потому что идентификатор сообщения из первоначального запроса отражается в ответной части возвращенного сообщения.
</p>


<h4>Example: Currency</h4>
<p>
В этом втором примере Clinical EHR необходимо узнать, какие интервалы приема доступны для определенной процедуры исследования. Это сообщение типа <b>Currency</b>: доступные слоты в любой момент могут исчезнуть, и заказ слота, который только что стал недоступным, является пустой тратой времени для вовлеченных людей и систем. EHR высылает сообщение с Bundle.id - UUID 3 (4c7f5cb2-5964-4d42-b719-e0227461818c), с MessageHeader.identifier - UUID 4 (63ed7d68-b2cc-421d-ba1c-a6c7785581f2).
</p>
<p>
EHR-система так и не получает ответа на это сообщение; она не знает, либо запрос потерялся, либо система управления изображениями не смогла обработать запрос, либо она успешно обработала сообщение, а ответ потерялся. В этом случает EHR-система отправляет повторно сообщение с тем же MessageHeader.identifier (UUID 4), но создает новый Bundle.id: (c7c17fe4-9560-49c7-b2ae-42636476fb86).
</p>
<p>
В этом случае система управления изображениями (imaging system) успешно получает сообщение и обрабатывает его. Когда она получает повторный ордер через 1 минуту (что  в пределах её 15-минутного времени кеширования), она видит, что, хотя идентификатор сообщения тот же самый, Bundle.id изменился, обрабатывает сообщение снова и отправляет новый ответ.
</p>
<p>
Когда EHR-система наконец получает сообщение, она узнает о текущей доступности слотов в ответившей системе управления изображениями ( imaging management system).
</p>
<p>
Обратите внимание, что существование активных посредников (или промежуточного программного обеспечения) создает необходимость в таком протоколе - исходный отправитель подбирает ответ на запрос на основе MessageHeader.id, поэтому активный посредник, который решит повторно инициировать запрос, который он ранее ретранслировал, не может менять MessageHeader.identifier. В этом протоколе избегается необходимость изменения MessageHeader.identifier, и требуется менять только Bundle.id, что никогда не является основой для контекстного связывания вне непосредственного протокола обмена сообщениями, описанного здесь.
</p>


<h2>Conformance Statement</h2>
<p>
Приложения могут утверждать о соответствии "FHIR-обмену сообщениями", только если они публикуют заявление о соответствии, чтобы это утверждение можно было подтвердить. Заявление о соответствии перечисляет все поддерживаемые события обмена сообщениями (либо как отправитель, либо получатель) и для каждого события профиль, который указывает, какие ресурсы будут собраны в комплект (отправитель), либо должны войти в комплект (получатель), и все правила об информационном содержимом каждого ресурса. Заявление о соответствии представляет собой <a href="conformance.html">ресурс с именем "Conformance"</a>. 
</p>

<a name="mailbox"></a>
<h2>Mailbox: Synchronous Messaging</h2>
<p>
Mailbox (почтовый ящик) - это стандартное имя сервиса, размещенного на <a href="http.html">RESTful-сервере</a>, который принимает сообщения и обрабатывает их синхронным образом как транзакции и возвращает ответные сообщения, соответствующие полученным.  Сервер не обязан делать что-либо конкретное с ресурсами, кроме того, что требует семантика кода события в ресурсе сообщения. В дополнение к обработке события сообщения, сервер может  сохранить ресурсы и сделать их доступными через RESTful-интерфейс, но не обязан делать это.
</p>
<p>
При обработке сообщений сервер может возвращать статус-код 200 OK, либо код обработки/ошибки (300+). 
Если сервер возвращает 200 OK, он ДОЛЖЕН вернуть комплект, который является ответом на сообщение.
Все остальные коды ответа указывают на то, что сообщение не было обработано. Сервер МОЖЕТ вернуть <a href="operationoutcome.html">OperationOutcome</a>, содержащий дополнительную информацию, и ДОЛЖЕН сделать это, если код ответа 400 или больше.
Клиент ДОЛЖЕН интерпретировать ответ вида 4xx как указание, что нет смысла повторно отправлять то же самое сообщение без изменений, а ответ вида 5xx - как неожиданную ошибку на стороне сервера, означающую, что стоит отправить сообщение повторно (и это не должно вызвать ошибку дублирования сообщения).
Повторяющиеся неудачи указывают либо на фатальную проблему с отправкой, либо проблему с приложением-получателем.
</p>
<p>
К почтовому ящику применяются следующие правила:
</p>
<ul>
 <li>Почтовый ящик принимает только POST-транзакции - любой другой HTTP-метод приведет к HTTP-ошибке</li>
 <li>Тип содержимого переданного запроса - это всегда <a href="bundle.html">комплект</a> с типом "message" , содержащий первым ресурсом <a href="messageheader.html">MessageHeader</a></li>
 <li>Тип содержимого возвращаемого ответа - это всегда либо HTTP-ошибка, либо <a href="bundle.html">комплект</a> с типом "message", содержащий первым ресурсом <a href="messageheader.html">Message Header</a></li>
 <li>Если ответом является ошибка, телом ДОЛЖЕН быть ресурс <a href="operationoutcome.html">Errors &amp; Warning</a> со всеми подробностями</li> 
 <li>URL никогда не принимает параметры</li>
 <li>Почтовый ящик может быть аутентифицирован с помощью стандартных HTTP-методов аутентификации, включая OAuth</li>
</ul>
<p>
Этот профиль простого почтового ящика может использоваться любой HTTP-точкой взаимодействия, которая принимает FHIR-сообщения, а не только FHIR RESTful-серверами.
</p>
<p>
Когда сообщения обрабатываются с помощью почтового ящика, для гарантии непротиворечивости обработки необходимо следовать <a href="#reliable">логическим правилам касательно обработки Bundle.id и идентификатора сообщения, описанным выше</a>. 
Серверы ДОЛЖНЫ принимать многократные одновременные (concurrent) отправки сообщений и обрабатывать их корректно.
</p>

<h2>Асинхронный обмен сообщениями</h2>
<p>
Асинхронный обмен сообщениями может быть реализован с помощью RESTful-интерфейса и точки взаимодействия комплекта, следуя этой общей схеме взаимодействия систем "отправитель" и "получатель" и используя "MTA" (агент передачи сообщений (message transfer agent)):
</p>
<ol>
 <li>Отправитель составляет комплект с типом "message" и первым ресурсом в комплекте <a href="messageheader.html">Message Header</a> с известным MessageHeader.identifier ("src-id")</li>
 <li>Отправитель создает это сообщение на MTA, используя точку взаимодействия своего <a href="bundle.html">комплекта</a></li>
 <li>Система-получатель получает уведомление о создании этого сообщения. The receiver system is notified of the creation of the message. Она может делать это следующими способами:
   <ul>
     <li>используя операцию <a href="http.html#history">history</a> для отслеживания новых сообщений</li>
     <li><a href="http.html#search">поиском</a> в точке взаимодействия комплекта (например GET [base]/Bundle?message.source.endpoint=http://acme.com/systems/pas для поиска сообщений из этой системы в точке взаимодействия "http://acme.com/systems/pas")</li>
     <li>подпиской на обновления комплекта с помощью ресурса <a href="subscription.html">Subscription</a></li>
   </ul>
   В первых двух подходах получатель опрашивает (polls) MTA, а в третьем MTA доставляет (pushes) событие получателю
 </li>
 <li>Получатель извлекает сообщение, обрабатывает его как указано в event.code и формирует одно или несколько ответных сообщений</li>
 <li>Для каждого ответного сообщения получатель составляет комплект с типом "message" и первым ресурсом в комплекте <a href="messageheader.html">Message Header</a> с <i>src-id</i> в MessageHeader.response.identifier</li>
 <li>Когда получатель закончил обрабатывать это сообщение, он помечает его как обработанное с помощью тега ?? и метаоперации (POST в [base]/[type]/[id]/_meta, где [id] - это идентификатор MTA для исходного сообщения)</li>
 <li>Исходная система может проверять статус сообщений и отслеживать ответы с помощью тех же самых подходов, перечисленных выше для системы-получателя.
 Для поискового механизма этой операцией будет GET [base]/Bundle?message.response-id=[src-id]</li>
</ol>
<p>
MTA может быть размещен либо на отправителе, либо получателе, либо на сервере третьей стороны.
</p>




<a name="endpoints"></a>
<h2>Связь между обменом сообщениями и REST</h2>

<p>
Помимо системы обмена сообщениями, описанной здесь, FHIR также определяет <a href="http.html">RESTful API</a>. Система обмена сообщениями и RESTful-система связаны тем, что оба разделяют один и тот же набор ресурсов, которым они оперируют.
По сути, базовый ресурс <a href="messageheader.html">MessageHeader</a>, на котором построена система обмена сообщениями, сам по себе является ресурсом, который может обрабатываться в RESTful-подходе.

</p>
<p>
Функциональные возможности, которые предлагают RESTful API и система обмена сообщениями, очень похожи; их основное различие носит архитектурный характер.
</p>
<p>
К примеру, система обмена сообщениями определяет событие по оповещению о том, что ресурс administration был создан или обновлен, так же как и REST API.
С другой стороны, имеются и различия в предлагаемых возможностях: в то время как слияние записей пациента может быть реализовано в виде серии RESTful-операций, совершаемых клиентом, который обновляет все ресурсы, связанные с этим пациентом, а при обработке сообщения-команды на слияние записей пациента всю работу выполнит сервер, притом он сможет выполнить слияние в таких областях, которые не доступны RESTful API.
Однако REST API предоставляет набор базовых операций для всех ресурсов, которые не предоставлены в системе обмена сообщениями и потребовали бы особых определений.
</p>
<p>
Не ожидается, что RESTful-системам потребуется поддерживать систему обмена сообщениями или наоборот, хотя системам может оказаться полезным поддерживать оба набора функциональностей, чтобы удовлетворять более широкому спектру реализаторов.
</p>
<p>
Как ресурс, который может использоваться в RESTful-системе, MessageHeader имеет обычную точку взаимодействия (/MessageHeader), которая используется для управления набором статических ресурсов сообщений. Её можно использовать для создания архива доступных прошлых сообщений. <b>Создание или обновление таким образом ресурсов MessageHeader не отражает фактического наступления никакого события и не может привести в действие никакую логику, связанную с реальным событием.</b> Это только для управления набором ресурсов заголовков сообщений.
</p>
<p>
Кроме того, что описано выше, данная спецификация определяет точку взаимодействия /Mailbox, для того чтобы RESTful-серверы могли предлагать как обмен сообщениями, так и RESTful-сервисы одновременно.
В качестве альтернативы, сообщения можно передавать между системами с помощью любого другого метода, по которому поток байтов (комплект сообщения) может быть перемещен из одного места в другое.
Требование использовать HTTP отсутствует.
</p>



<a name="Events"></a>
<a name="events"></a>
<h2>Перечень событий</h2>

<p>
Элемент <i>message.code</i> передает <a href="datatypes.html#Coding">Coding</a>, который идентифицирует событие, которое передает сообщение.
В данной таблице перечислены коды событий сообщений, определенные в этой спецификации (значением системы для них является "<a href="message-events.html">http://hl7.org/fhir/message-events</a>"):
</p>

[%events%]

<p>
Описание колонок "запрос" и "ответ": значением этих колонок является либо ресурс, который входит в состав ответа, либо элемент, который ссылается на другой ресурс, что означает, что цель таких ссылок ДОЛЖНА также присутствовать в этом сообщении. 
</p>

<a name="dstu"> </a>
<p>
В этой таблице колонки "запрос" и "ответ" перечисляют центровой ресурс для события наряду с другими ресурсами, которые также должны передаваться в сообщении непосредственно (если они существуют). Дополнительные события могут быть определены где угодно, хотя данная спецификация еще не определила, каким образом. DSTU: За время пробного использования ожидается сбор информации на эту тему.
</p>



</div>

[%file newfooter%]
    
    
</body>
</html>


