<!DOCTYPE HTML>
[%settitle Terminology Service%]
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
[%file newheader%]
</head>
<body>
[%file newnavbar%]

<div class="col-12">

<h2>Терминологические сервисы<!-- Terminology Service --></h2>
<table class="cols"><tr><td id="wg"><a _target="blank" href="[%wg fhir%]">[%wgt fhir%]</a> Рабочая группа</td><td id="fmm"><a href="resource.html#maturity">Уровень готовности</a>: N/A</td><td id="ballot"><a href="help.html#status">Статус голосования</a>: <a href="history.html#pubs">DSTU 2</a></td></tr></table>

<p>
Данная спецификация включает в себя поддержку предоставления терминологического сервиса - это сервис, который позволяет медицинским приложениям использовать коды и наборы значений без необходимости становиться экспертами в тонких деталях ресурсов code system, value set и concept map, и лежащих в их основе кодовых систем и терминологических принципах.
Сервер, который поддерживает полную функциональность, приведённую здесь, может быть описан как "FHIR Terminology Service" и ДОЛЖЕН соответствовать <a href="conformance-terminology-server.html">этому заявлению о соответствии</a>.
<!-- This specification includes support for the provision of a terminology service - that is, a
service that lets healthcare applications make use of codes and value sets without having to become
experts in the fine details of the code system, value set and concept map resources, and the underlying 
code systems and terminological principles. A server that supports all the functionality described here 
can be described as a "FHIR Terminology Service", and SHALL conform to <a href="conformance-terminology-server.html">this 
conformance statement</a>. -->
</p>

<h3>Безопасность<!-- Security --></h3>
<p>
SSL, как правило, СЛЕДУЕТ использовать для любого обмена медицинскими данными в рабочем режиме.
Несмотря на то, что терминологические сервисы обычно не оперируют непосредственно информацией пациентов, хакеры всё же могут вывести информацию о пациентах, наблюдая за кодами и концептами, о которых запрашивают терминологический сервис, поэтому шифрование всё же рекомендуется.
<!-- Generally, SSL SHOULD be used for all production health care data exchange. 
Even though terminology servers do not generally handle patient information directly, 
hackers may still be able to infer information about patients by observing 
the codes and concepts that the terminology service is asked about, so 
encryption is still recommended. --> 
</p>
<p>
Терминологический сервер может работать без аутентификации клиентов/пользователей, однако он может делать это в порядке ограничения или учета использования.
Для сервера, поддерживающего набор значений, который разрешает редактирование справочников, будет уместно использование некоторой формы <a href="security.html">авторизации и/или аутентификации</a>.
Данная спецификация не требует какого-то определенного подхода к безопасности.
<!-- A terminology server may choose not to authenticate the clients/users in any fashion,
but can do so in order to limit or account for usage. 
For a value set maintenance server that allows terminologies to be edited, 
some form of <a href="security.html">authorization and/or authentication would be appropriate</a>.
This specification does not require any particular approach to security. --> 
</p>


<h3>Основные понятия<!-- Basic Concepts --></h3>
<p>
Терминологический сервис FHIR - это просто набор функций, построенный на определениях, предоставленных коллекцией ресурсов <a href="codesystem.html">CodeSystem</a>,  <a href="valueset.html">ValueSet</a> и <a href="conceptmap.html">ConceptMap</a>, с обеспечивающими поддержку дополнительными внутренними справочниками.
<!-- A FHIR terminology service is simply a set of functions built on the definitions
provided by a collection of <a href="codesystem.html">CodeSystem</a>,  <a href="valueset.html">ValueSet</a> and
<a href="conceptmap.html">ConceptMap</a> resources, with additional inherently known terminologies providing support. -->
</p>
<p>
Этот терминологический сервис основывается на базовых принципах использования справочников в FHIR. Реализаторам следует ознакомиться с: 
<!-- The terminology service builds on the basic principles for using terminologies
in FHIR. Implementers should be familiar with: -->
</p>
<ul>
 <li><a href="terminologies.html">Использование кодов в FHIR</a></li>
 <li>The <a href="codesystem.html">CodeSystem</a> resource</li>
 <li>Ресурс <a href="valueset.html">ValueSet</a></li>
 <li>Ресурс <a href="conceptmap.html">ConceptMap</a></li>
</ul>
<p>
Кроме того, реализаторам следует ознакомиться с <a href="operations.html">фреймворком операций</a>. Дополнительную полезную информацию о справочниках можно найти в:
<!-- In addition, implementers should be familiar with the <a href="operations.html">operations
framework</a>. Further useful information about terminologies may be found in: -->
</p>
<ul>
 <li>Основные принципы: <a href="http://www.hl7.org/documentcenter/public/standards/V3/core_principles/infrastructure/coreprinciples/v3modelcoreprinciples.html">HL7 v3 Core Principles</a></li>
 <li><a href="http://ihtsdo.org/fileadmin/user_upload/doc/">Техническая документация</a> SNOMED CT. Примечание: понятие "namespace" используется здесь несколько иначе, чем в IHTSDO (см. обсуждение <a href="terminologies.html">здесь</a>)</li>
</ul>

<h4>Внешние кодовые системы<!-- External Code Systems --></h4>
<p>
Чтобы использоваться в наборе значений, кодовые системы и их содержимое должны быть где-то определены. Они могут быть определены явным образом с помощью ресурса <a href="codesystem.html">CodeSystem</a>, либо где-то ещё, и затем использоваться в наборе значений, ссылаясь на url-адрес нужной системы. Спецификация FHIR определяет <a href="terminologies-systems.html">ряд пространств имён</a> для часто встречающихся кодовых систем и описывает, как некоторые из них работают с FHIR (например <a href="snomedct.html">SNOMED CT</a>, <a href="loinc.html">LOINC</a>, <a href="rxnorm.html">RxNorm</a>).
Обычно это большие кодовые системы с большим количеством определённых внутри свойств, являющихся частью их формальных описаний. Ресурс CodeSystem не являются подходящим способом для распространения содержимого этих кодовых систем; ресурс CodeSystem стандарта FHIR представляет собой всего лишь свойства кодовой системы. Вместо этого эти справочники предлагают свои собственные форматы распространения, и предполагается, что содержимое этих кодовых систем известно терминологическому серверу и является внешним по отношению к нему.
<!-- In order to be used with a value set, code systems and their content must be defined somewhere. They can be defined explicitly
using the <a href="codesystem.html">code system resource</a>, or they can be defined elsewhere, and then used in a value set 
by quoting the correct system url. The FHIR specification defines a <a href="terminologies-systems.html">set of
namespaces</a> for commonly encountered code systems, and defines how some work with FHIR (e.g. 
<a href="snomedct.html">SNOMED CT</a>, <a href="loinc.html">LOINC</a>, <a href="rxnorm.html">RxNorm</a>).
These code systems are often large, and have many internally defined properties that are part of their 
formal definitions. The code systems resource is not an appropriate way to distribute the contents of 
these code systems; the standard FHIR code system resource simply represents the properties of 
the code system. Instead, these terminologies provide their own distribution formats, and it is assumed that the
content of these code systems are externally known to the terminology server. -->
</p>
<p>
Терминологические серверы сделают одну или несколько таких внешних кодовых систем доступными для использования в наборах значений, которыми они управляют. Перечень дополнительных справочников, которые поддерживает терминологический сервер сверх тех, что определены в его наборах значений, публикуется для клиентов с помощью ссылок на ресурсы CodeSystem в <a href="conformance.html">Заявлении о соответствии</a> сервера.
<!-- Most useful terminology servers will make one or more of these external code systems available for use
within the value sets that they manage. The list of additional terminologies that a terminology server supports 
beyond those defined in its value sets is published to clients by referencing code system resources in 
the server's <a href="conformance.html">Conformance Statement</a>. -->
</p>
<pre class="json">
{
 "resourceType" : "Conformance",
 "extension" : [
   { 
     "url" : "http://hl7.org/fhir/StructureDefinition/conformance-supported-system",
     "valueUri" : "http://loinc.org" 
   }]  
}
</pre>
<p>
Это расширение добавляется в корневой <a href="conformance.html">Conformance Statement</a>.
<!-- This extension is added to the root <a href="conformance.html">Conformance Statement</a>. -->
</p>

<h4>Примечание к реализации<!-- Implementation Note --></h4>
<p>
Когда терминологический сервер взаимодействует с внешней кодовой системой, он делает доступными ряд внутренних сервисов, которые служат интерфейсами операций. Внутренний сервер зависит от следующей логической информации справочника:
<!-- When a terminology server exposes an external code system, it makes a set of services available 
internally that serve the operational interfaces below. The internal server depends on the following 
logical information for a terminology: -->
</p>
<ul>
  <li> его URL (пространство имён, и как работает версионирование)</li>
  <li> какие коды считаются допустимыми  </li>
  <li> какие свойства могут использоваться для выборки кодов </li>
  <li> какие неявные наборы значений существуют </li>
</ul>
<p>
Спецификация FHIR сама определяет эти данные для распространенных справочников (включая
<a href="snomedct.html">SNOMED CT</a>, <a href="loinc.html">LOINC</a>, <a href="rxnorm.html">RxNorm</a>),
и предлагает инфраструктуру <a href="valueset.html">ValueSet</a> для поддержки типовых, относительно простых, маленьких кодовых систем.
</p>
<p>
<i>Примечание реализаторам: Реализаторам, заинтересованным в работе с существующими опубликованными 
справочниками, для которых инфраструктура Value Set не подходит, следует обсудить свои требования с HL7 для получения расширенного списка.
<!-- <i>Implementers Note: Implementers interested in working with existing published terminologies for
which the Value Set infrastructure is not suitable should discuss their needs with HL7 to get the
list above extended.--></i>
</p>

<p>
Примечание: терминологический сервис может получить доступ к дополнительной специфичной 
связанной функциональности внешней кодовой системы, например суммирование или структурированный 
поиск, однако эти сервисы выходят за рамки терминологического сервиса FHIR.
<!-- Note: A terminology service may choose to expose additional external code system specific
related functionality such as summation, or structured search, but these services are 
outside the scope of the FHIR terminology service. -->
</p>

<a name="all"> </a>
<h4>Операции для всех наборов значений<!-- Operations across all value sets --></h4>
<p>
Для некоторых операций, приведенных ниже, может оказаться удобным их выполнение сразу над всеми наборами значений, известными системе.
Например, используя текстовый фильтр, искать сразу по всем наборам значений с помощью операции $expand. Для этого определен особый набор значений "все наборы значений, известные серверу":
<!-- For some of the operations below, it can be useful to perform them across all value sets known to the system.
For example, $expand using a text filter, and searching all value sets at once. A special value set is 
defined that means "all value sets known to the server": -->
</p>
<pre>
http://hl7.org/fhir/ValueSet/@all
</pre>
<p>
Технически, этот набор значений автоматически делает импорт всех существующих на сервере наборов значений. Обратите внимание, что у этого URL нет фиксированного значения - его интерпретация зависит от сервера. Этот URL может использоваться только в качестве параметра операций, описанных на данной странице.
<!-- Technically, this value set automatically imports all the existing value sets on the server.
Note that this URL has no fixed meaning - its interpretation is server specific. This URL 
can only be used as a parameter to the operations described on this page.  -->
</p>

<h4>Поддержка справочников<!-- Terminology Maintenance --></h4>
<p>
Терминологический сервис использует ресурсы value set, определенные в системе - как
неявные, ассоциированные с внешними кодовыми системами, так и явно 
доступными в точках взаимодействия /CodeSystem и /ValueSet - в качестве управляющего интерфейса, определенного ниже.
Когда кодовые системы и наборы значений создаются, обновляются или удаляются, результаты управляющих сервисов 
меняются. Терминологический сервер следует валидировать входящие ресурсы и гарантировать целостность
терминологических сервисов. Обычно серверы предлагают тестовое и рабочее окружение, но нет явного обозначения этого в самом интерфейсе.
<!-- The terminology service uses the value set resources defined on the system - both 
the implicit ones associated with the external code systems and those explicitly 
available at the /CodeSystem and /ValueSet endpoints - to serve the operational interface defined below. 
As code systems and value sets are created, updated or deleted, the outcomes of the operational 
services change. A terminology server should validate incoming resources, and ensure integrity 
of the terminology services. Typically, servers provide a test and production 
environment, but there is no explicit notion of this in the interface itself.  -->
</p>

<h3>Развёртывание набора значений<!-- Value Set Expansion --></h3>
<p>
Набор значений описывает свод правил о том, какие коды или концепты будут входить в этот набор значений.
Эти правила могут быть как простыми (например непосредственно перечень кодов из кодовой системы определенной версии), так и
достаточно сложными (например все коды с определенным свойством из кодовой системы неопределенной версии).
<!-- A value set describes a set of rules for what codes or concepts are considered to be in the value set.
These rules might be simple (e.g. a direct list of codes from a specified version of a code system), or 
they might be quite complex (e.g. all codes with a particular property from an unspecified version of 
a code system).  -->
</p>
<p>
FHIR-приложение может просто запросить сервер выяснить все детали и вернуть список текущих кодов в наборе значений. Это называется
<a href="valueset-operations.html#expand">"развёртывание" набора значений</a>. 
 В итоге клиент передает серверу следующую информацию:
<!-- A FHIR enabled application can simply ask the server to figure out all the details, and return it a list
of the current codes in the value set. This is known as <a href="valueset-operations.html#expand">"expanding" the valueset</a>. 
As a summary, the client passes the server the following information: -->
</p>
<ul> 
 <li>набор значений (либо по его URL в RESTful-интерфейсе, либо по его логическому идентификатору <a href="valueset-definitions.html#ValueSet.url">(ValueSet.url)</a>, либо непосредственно в виде параметра вызова) <!-- the value set (either by its URL on the RESTful interface, by its logical identifier <a href="valueset-definitions.html#ValueSet.url">(ValueSet.url)</a>, or directly as a parameter to the call) --></li>
 <li>(Необязательно) текстовый фильтр для ограничения возвращаемых кодов (например текст, введенный пользователем). Как применить этот текстовый фильтр - остается на усмотрение сервера<!--  (Optionally) a text filter to use to restrict the codes that are returned (e.g. user input text). It is left to server discretion to choose how to apply the text filter --></li>
 <li>(Необязательно) дата, когда развёртывание должно быть выполнено (обычно это текущая дата/время, но есть обстоятельства, где это не подходит) <!-- (Optionally) a date at which the expansion should be evaluated (usually, this is the current date/time, but there are circumstances where that is not appropriate) --></li>
 <li> (Optionally) which page to retrieve - asking the server to break the expansion into a set of chunks</li>
</ul>

<p>
Сервер возвращает набор значений, который содержит текущий список кодов, которые соответствуют критериям фильтра (либо
<a href="operationoutcome.html">OperationOutcome</a> с ошибкой, если попытка развёртывания была неудачной).
Обратите внимание, что некоторые наборы значений расширяются на много тысяч кодов, или даже бесконечное количество,
и для них серверу СЛЕДУЕТ возвращать <a href="valueset-issue-type.html#too-costly">код ошибки 
<i>too-costly</i></a>. В таких случаях клиент может попытаться снова с уточняющим текстовым фильтром
для уменьшения количества возвращаемых кодов - это может привести к получению валидной развёртки.
<!-- The server returns a value set that contains the current list of codes that meet the filter criteria (or an
<a href="operationoutcome.html">OperationOutcome</a> with an error if the expansion fails). 
Note that some value sets expand to many thousands of codes, or even an infinite number, 
and for these, the server SHOULD return an <a href="valueset-issue-type.html#too-costly">error code
<i>too-costly</i></a>. In these cases the client can try again with a more specific text filter
to reduce the number of codes returned - this may result in a valid expansion. -->
</p>
<p>
Более подробную информацию можно получить на странице <a href="valueset-operations.html#expand">определения этой операции</a>.
<!-- For further information, consult the <a href="valueset-operations.html#expand">definition of the operation</a>. -->
</p>
<p>
The $expand operation has support for paging - for a client to retrieve a big expansion 
in a set of partial views, in order to present the most optimal user experience. 
The client specifies both an offset and a count - how many codes per page, and where in the sequence 
to start. The return expansion specifies the number of concepts in the expansion, and the offset 
at which this partial view starts. Note that all expansions SHOULD include the total code count,
but the offset element SHALL only exist when paging is being used. Expansions that are hierarchical 
trees of concepts are not subject to paging and the server simply returns the entire expansion.
</p>
<p>
Несколько примеров использования операции развёртывания:
<!-- Some example uses for the expansion operation: -->
</p>
<ul>
 <li>получить перечень кодов для отображения с пользовательском интерфейсе (например в выпадающем списке) <!-- get a list of codes to display in a User interface (e.g. a drop down interface) --></li>
 <li>другой вариант - предложить пользователю поле для ввода текста. По мере ввода вызывать операцию развёртывания для показа пользователю списка соответствующих кодов/концептов (наподобие поиска в браузере) <!-- a variation on this is to offer the user a text box to type in. As the user types, call the expand operation to provide the user with a list of matching codes/concepts (like a browser search)  --></li> 
 <li>извлечь список кодов для использования при создании программных инструкций программного обеспечения <!-- fetch a list of codes to use when generating software programming instructions --></li>
 <li>получить список кодов, чтобы программное обеспечение могло проверить, является ли код допустимым или нет в конкретном контексте <!-- get a list of codes so that software can check whether a code is valid or not in a particular context --></li>
</ul>


<div class="example">
<p><b>Примеры<!-- Examples --></b></p>
<p>
Развёртывание набора значений, который уже зарегистрирован на сервере с именем "23", применяя текстовый фильтр "abdo":
<!-- Expanding a value set that is already registered on the server as "23", with a text filter of "abdo" : -->
</p>
<pre class="http">
GET [base]/ValueSet/23/$expand?filter=abdo
</pre>
<p>
Развёртывание набора значений, указанного клиентом (с помощью JSON):
<!-- Expanding a value set that is specififed by the client (using JSON): -->
</p>
<pre class="http">
POST [base]/ValueSet/23/$expand
[other headers]

{
  "resourceType" : "Parameters",
  "parameter" : [
     {
     "name" : "valueSet",
     "resource" : {
       "resourceType" : "ValueSet",
     [value set details]
     }
   }
  ]
}
</pre>
<p>
Сервер отвечает набором значений (этот пример в XML):
<!-- The server responds with a value set (this example in XML): -->
</p>
<pre class="http">
HTTP/1.1 200 OK
[other headers]

&lt;ValueSet xmlns=&quot;http://hl7.org/fhir&quot;&gt;
  &lt;!-- the server SHOULD populate the id with a newly created UUID 
    so clients can easily track a particular expansion  --&gt;
  &lt;id value=&quot;43770626-f685-4ba8-8d66-fb63e674c467&quot;/&gt;
  &lt;!-- no need for meta, though it is allowed for security labels, profiles --&gt;

  &lt;!-- other value set details --&gt;
  &lt;expansion&gt;
    &lt;!-- when expanded --&gt;
    &lt;timestamp value=&quot;20141203T08:50:00+11:00&quot;/&gt;
  &lt;contains&gt;
    &lt;!-- expansion contents --&gt;
  &lt;/contains&gt;
  &lt;/expansion&gt;
&lt;/ValueSet&gt;
</pre>
</div>

<h3>Поиск концепта<!-- Concept Lookup --></h3>
<p>
Система может запросить терминологический сервер вернуть информацию об определенной комбинации системы/кода
с помощью  <a href="codesystem-operations.html#lookup">операции поиска</a>. Сервер возвращает информацию как для отображения на экране, так и в целях обработки.
Клиент передает серверу следующую информацию:
<!-- A system can ask a terminology server to return a set of information about a particular system/code
combination using <a href="codesystem-operations.html#lookup">the lookup operation</a>. The server returns information for both display and processing
purposes. The client passes the server the following information: -->
</p>
<ul>
 <li>значение кода (либо код, либо тип данных Кодинг) <!-- the code value (either a code, or a Coding data type --></li>
 <li> (Optionally) the id or the url of the code system in which the code is being checked</li>
 <li>(Необязательно) дата, когда информация по этому коду должна быть возвращена (обычно это текущая дата/время, но есть обстоятельства, где это не подходит) <!-- (Optionally) a date at which the code information should be returned (usually, this is the current date/time, but there are circumstances where that is not appropriate) --></li>
 <li> (Optionally) a set of properties to return about the code</li>
</ul>
<p>
Сервер возращает некоторую из или всю следующую информацию:
<!-- The server returns some or all of the following information: -->
</p>
<ul>
 <li>Человекочитаемое описание системы<!-- a human description of the system --></li>
 <li>Рекомендуемое значение для отображения этого кода <!-- a recommended display for the code --> </li>
 <li> properties of the code</li>
 <li>Другие обозначения для этого кода (значение с необязательным указанием языка и/или применения) <!-- other designations for the code (a value, optionally with language and/or a use code) --></li>
 <li> relationships between this code and other codes</li>
</ul>
<p>
The recommended display for the code is a text representation of the code
that the terminology server recommends as the default choice to show 
to the user, though a  client may choose out of the other designations if it has reason to.
</p>
<p>
If the client does not ask for any particular properties to be returned, it is at the discretion
of the server to decide which properties to return.
</p>


<div class="example">
<p><b>Примеры</b></p>
<p>
Looking up a code in a code system:
</p>
<pre class="http">
GET [base]/CodeSystem/loinc/$lookup?code=1963-8
</pre>
<p>
Note that the logical id "loinc" is not a reliable identifer across systems; each server assigns
logical ids to code system resources however it sees fit. A more reliable query is this:
</p>
<pre class="http">
GET [base]/CodeSystem/$lookup?url=http://loinc.org&amp;code=1963-8&amp;properties=code,display,designations
</pre>
<p>
Поиск кодовой системы с помощью Кодинга (этот пример в XML):
<!-- Lookup the code system using a Coding (this example in XML): -->
</p>
<pre class="http">
POST [base]/CodeSystem/$lookup
[other headers]

&lt;Parameters xmlns=&quot;http://hl7.org/fhir&quot;&gt;
  &lt;parameter&gt;
    &lt;name value=&quot;coding&quot;/&gt;
  &lt;valueCoding&gt;
    &lt;system value=&quot;http://loinc.org&quot;/&gt;
    &lt;code value=&quot;1963-8&quot;/&gt;
  &lt;/valueCoding&gt;
  &lt;/parameter&gt;
&lt;/Parameters&gt;
</pre>
<p>
Сервер отвечает набором информации (на этот раз в JSON):
<!-- The server responds with a set of information (JSON this time): -->
</p>
<pre class="http">
HTTP/1.1 200 OK
[other headers]

{
  "resourceType" : "Parameters",
  "parameter" : [
    {
    "name" : "name",
    "valueString" : "LOINC"
  }, 
  {
    "name" : "version",
    "valueString" : "2.48"
  }, 
  {
    "name" : "display",
    "valueString" : "Bicarbonate [Moles/volume] in Serum"
  }, 
  {
    "name" : "abstract",
    "valueString" : "false"
  }
  ]
}
</pre>

<p>
Thie following properties are defined:
</p>
<table class="grid">
 <tr>
  <td><b>Name</b></td>
  <td><b>Usage</b></td>
 </tr>
 <tr>
  <td>system</td>
  <td>The name of the code ssystem</td>
 </tr>
 <tr>
  <td>version</td>
  <td>The version of the code system used for the look up operation</td>
 </tr>
 <tr>
  <td>display</td>
  <td>The recommended display for the code, if one is known</td>
 </tr>
 <tr>
  <td>definition</td>
  <td>The definition for the code</td>
 </tr>
 <tr>
  <td>designation</td>
  <td>Other designations for the code</td>
 </tr>
 <tr>
  <td>parent</td>
  <td>Parent codes for this code (for code systems with a defined heirarchy)</td>
 </tr>
 <tr>
  <td>child</td>
  <td>child codes of this code (for code systems with a defined heirarchy)</td>
 </tr>
</table>
<p>
In addition, any property codes defined by the code system (CodeSysem.property.code) can be used.
</p>

</div>

<h3>Валидация набора значений<!-- Value Set Validation --></h3>
<p>
Один способ определить, входит ли код в набор значений - это развёртывание этого набора значений 
(как описано выше) и затем просмотр возвращенных кодов, чтобы увидеть, есть ли среди них этот код.
Однако это не эффективный способ проверки, является ли код допустимым, и для некоторых наборов значений 
(например с бесконечным числом элементов) он может не работать. Вместо этого терминологический сервер FHIR 
предоставляет <a href="valueset-operations.html#validate-code">операцию "validate-code"</a>. Клиент передает серверу следующую информацию:
<!-- One way to determine whether a code is in a value set is to expand the value set
(as described above), and then look at the returned codes to see if the code is in the expansion. 
However this is not an efficient way to test whether a code is valid, and for some value sets 
(e.g. with infinite number of members), it cannot work. Instead, a FHIR terminology server 
provides <a href="valueset-operations.html#validate-code">a "validate-code" operation</a>. The client passes the server the following information: -->
</p>
<ul>
 <li>набор значений (либо по его URL в RESTful-интерфейсе, либо по его логическому идентификатору <a href="valueset-definitions.html#ValueSet.url">(ValueSet.url)</a>, либо непосредственно в виде параметра вызова) <!-- the value set (either by its URL on the RESTful interface, by its logical identifier <a href="valueset-definitions.html#ValueSet.url">(ValueSet.url)</a>, or directly as a parameter to the call) --></li>
 <li>значение кода (либо код+система, тип данных Кодинг, либо CodeableConcept) <!-- the code value (either a code + system, a Coding data type, or a CodeableConcept --></li>
 <li>(Необязательно) дата, когда развёртывание должно быть выполнено (обычно это текущая дата/время, но есть обстоятельства, где это не подходит)  <!-- (Optionally) a date at which the expansion should be evaluated (usually, this is the current date/time, but there are circumstances where that is not appropriate) --></li>
</ul>
<p>
Сервер возвращает значение true/false, указывающее, является ли код/концепт допустимым, и список 
ошибок и предупреждений, ассоциированных с этим. Сервер должен также вернуть соответствующее значение 
для отображения концепта для использования его в контексте интерфейса пользователя.
<!-- The server returns a true/false indicating whether the code/concept is valid, and a list
of errors and warnings associated with it. The server should also return an appropriate
display for the concept for use in a UI context. -->
</p>
<p>
Обратите внимание, что если серверу передают CodeableConcept, сервер может проверить 
валидны ли любые из кодов по отношению к набору значений, и также проверить, разрешены 
ли множественные кодинги и/или не противоречат ли предоставленные кодинги друг с другом.
<!-- Note that if the server is passed a CodeableConcept, the server is able to check
whether any of the codes are valid against the value set, and also check whether 
multiple codings are allowed and/or the codings provided are consistent with each other.  -->
</p>
<p>
Каждая кодовая система имеет имплицитный набор значений, который является "всеми концептами, определенными в этой кодовой системе" (CodeSystem.valueSet). Для некоторых кодовых систем URIs этих наборов значений определены заранее (например для <a href="loinc.html">LOINC</a> это <code>http://loinc.org/vs</code>). Однако для некоторых кодовых систем они не известны. Клиенты могут ссылаться на эти имплицитные наборы значений, передавая URI самой кодовой системы.
<!-- Every code system has an implicit value set that is "all the concepts defined
in the code system" (CodeSystem.valueSet). For some code systems, these value set URIs are defined 
in advance (e.g. for <a href="loinc.html">LOINC</a>, it is <code>http://loinc.org/vs</code>).
However for some code systems, they are not known. Clients can refer to these implicit 
value sets by providing the URI for the code system itself.  -->
</p>

<div class="example">
<p><b>Примеры</b></p>
<p>
Простая валидация кода/системы по отношению к известному набору значений:
<!-- Simple validation of a code/system against a known value set: -->
</p>
<pre class="http">
GET [base]/ValueSet/23/$validate-code?system=http://loinc.org&amp;code=1963-8&amp;display=test
</pre>
<p>
Валидирует CodeableConcept на соответствие набору значений, указанному клиентом (пример в JSON):
<!-- Validate a CodeableConcept against a client specified value set (this example in JSON): -->
</p>
<pre class="http">
POST [base]/ValueSet/$validate-code
[other headers]

{
  "ResourceType" : "Parameters",
  "parameter" : [
    {
    "name" : "coding",
    "valueCodeableConcept" : {
      "coding" : {
        "system" : "http://loinc.org",
          "code" : "1963-8",
      "display" : "test"
      }
    }  
  },
  {
    "name" : "valueSet",
    "resource": {
      "resourceType" : "ValueSet",
    [etc]
    }
  }
  ]
}
</pre>
<p>
Сервер отвечает информацией о валидации (пример в JSON):
<!-- The server responds with validation information (JSON this time): -->
</p>
<pre class="http">
HTTP/1.1 200 OK
[other headers]

{
  "resourceType" : "Parameters",
  "parameter" : [
    {
    "name" : "result",
    "valueBoolean" : "false"
  }, 
  {
    "name" : "message",
    "valueString" : "The display \"test\" is incorrect"
  }, 
  {
    "name" : "display",
    "valueString" : "Bicarbonate [Moles/volume] in Serum"
  }
  ]
}
</pre>
</div>

<h3>Проверка на вхождение<!-- Subsumption testing --></h3>
<p>
Операции Expand и Validate можно использовать для совершения проверки на вхождение. Чтобы проверить, 
входит ли <i>код Б</i> в <i>код A</i>, выполните операцию validate, указав набор значений, построенный из всех 
кодов, входящих в <i>код A</i>, и проверьте, входит ли туда <i>код Б</i>.
Обратите внимание, что серверу разрешается (и СЛЕДУЕТ, но не требуется) принимать во внимание таблицы соответствия 
концептов при выполнении проверки на вхождение. Например если А - это LOINC-код, и у него есть точное отображение на 
SNOMED CT-код, который включает Б, с соответствующей областью действия, тогда сервер может вернуть истину для 
утверждения, что LOINC-код А включает SNOMED CT-код Б.
<!-- The Expand and Validate operations can be used to perform subsumption testing. To test whether 
<i>code A</i> subsumes <i>code B</i>, perform a validate specifying a value set built of all the 
codes that are subsumed by <i>code A</i>, and test whether <i>code B</i> is subsumed by it. 
Note that a server is allowed to (and SHOULD, but is not required to) consider concept maps when 
doing subsumption testing. For example if A is a LOINC code, and it has a precise mapping to a
SNOMED CT code that subsumes B, with an appropriate scope, then the server can indicate 
that this it is true that LOINC code A subsumes SNOMED CT code B. -->
</p>
<p>
Чтобы сделать выполнение такой проверки на включение более удобной, кодовые системы, 
которые определяют иерархию категоризации, должны определять простые URL-адреса для выражения 
набора значений, который включает все эти коды, включенные в этот код.
<!-- In order to make it convenient to perform this subsumption testing, code systems that define
subsumption hierarchies should define simple URLs to express a value set that includes all the 
codes subsumed by a code.  --> 
</p>

<div class="example">
<p><b>Примеры</b></p>
<p>
Проверка того, что SNOMED CT-концепт 399211009 (History of myocardial infarction) включен в 22298006 (Myocardial infarction):
<!-- Test whether a SNOMED CT Concept 399211009 (History of myocardial infarction) is subsumed by 22298006 (Myocardial infarction): -->
</p>
<pre class="http">
GET [base]/ValueSet/$validate-code?system=http://snomed.info/sct&amp;code=399211009&amp;identifier=http://snomed.info/sct?fhir_vs%3Disa/22298006
</pre>
<p>
Ответ сервера:
<!-- Server response: -->
</p>
<pre class="http">
HTTP/1.1 200 OK
[other headers]

{
  "resourceType" : "Parameters",
  "parameter" : [
    {
    "name" : "result",
    "valueBoolean" : "false"
  }, 
  ]
}
</pre>
</div>

<h3>Пакетная валидация<!-- Batch Validation --></h3>

<p>
Также есть возможность валидировать несколько концептов по отношению к их 
соответствующим наборам значений с помощью операции <code>$validate-code</code> взаимодействия <a href="http.html#batch">Batch</a>.
<!-- It is also possible to validate a set of concepts against their relevant value
sets by using the <code>$validate-code</code> operation in a <a href="http.html#batch">Batch</a> 
interaction. -->
</p>

<div class="example">
<p><b>Примеры</b></p>
<p>
Запрос на валидацию 2 концептов из CDA-документа, с OID в качестве идентификаторов набора значений:
<!-- A request to validate 2 concepts from a <a href="http://www.hl7.org/implement/standards/product_brief.cfm?product_id=7">CDA</a> document, with OIDs for value set identifiers: -->
</p>
<pre class="http">
POST [base]
[other headers]

{
  "ResourceType": "Bundle",
  "type": "batch",
  "entry": [{
    "request": {
      "method": "Get",
      "url": "ValueSet?system=http://loinc.org&amp;code=2324-4&amp;uri=urn:oid:1.2.3.4.6"
    }
  }, 
  {
    "request": {
      "method": "GET",
      "url": "ValueSet?system=http://snomed.info/sct&amp;codes=22298006&amp;uri=urn:oid:1.2.3.4.7"
    }
  }]
}
</pre>

<p>
Сервер отвечает набором результатов валидации (пример в JSON):
<!-- The server responds with a series of validation outcomes (JSON this time): -->
</p>
<pre class="http">
HTTP/1.1 200 OK
[other headers]

{
  "ResourceType": "Bundle",
  "type": "batch-response",
  "entry": [{
    "resource": {
      "resourceType": "Parameters",
      "parameter": [{
        "name": "result",
        "valueBoolean": "false"
      }, 
      {
        "name": "message",
        "valueString": "'2324-4' is not a valid LOINC code"
      }]
      }
  },
  {  
    "resource": {
      "resourceType": "Parameters",
      "parameter": [{
        "name": "result",
        "valueBoolean": "false"
      }, 
      {
        "name": "message",
        "valueString": "The concept is not in the specified value set (\"Organisms\")"
      }, 
      {
        "name": "display",
        "valueString": "Myocardial infarction"
      }]
    }]
      }
</pre>

</div>


<h3>Переводы<!-- Translations --></h3>
<p>
A client can ask a server to translate a concept from one value set to another. Typically, this
is used to translate between code systems (e.g. from LOINC to SNOMED CT, or from a <a href="https://www.hl7.org/implement/standards/product_brief.cfm?product_id=186">HL7 V3</a> code to
a <a href="http://www.hl7.org/implement/standards/product_brief.cfm?product_id=185">HL7 V2</a> code). The client calls <a href="conceptmap-operations.html#translate">the translate operation</a> and passes the following parameters:
</p>
<ul>
  <li>код + система, Кодинг, или CodeableConcept<!-- A code + system, Coding, or CodeableConcept --></li>
  <li>a Concept Map to use for the translation</li>
  <li>набор значений-источник <!-- the value set for the context of the source --> </li>
  <li>набора значений-назначение  <!-- the value set for the destination --></li>
</ul>
<p>
Клиент передает либо карту соответствия концептов, либо наборы значений в контексте источника и назначения. Если карты соответствия концептов нет, сервер может определить подходящую для использования карту из контекста приведенных наборов значений. 
Если нет особого контекста, подходящими наборами значений будут наборы значений 
для всей кодовой системы, к которой идет обращение (например из  http://snomed.info/sct в http://loinc.org/vs). 
Сервер выполняет перевод как может, на основе карт соответствия концептов, которые ему известны.
Если единый мэппинг не может быть определен, тогда сервер возвращает ошибку. Некоторые серверы могут требовать использования карты соответствия концептов для выполнения перевода.
<!-- The client passes either a concept map, or the value sets for the source and destination context.
If there is no concept map, then the server may determine the appropriate map to use from 
context provided in the value sets.
If there is no particular context, the appropriate value sets would be the value sets for the 
entire coding system at question (e.g. from http://snomed.info/sct to http://loinc.org/vs).
The server performs the translation as it is able based on the concept maps that it knows about.
If no single mapping can be determined then the 
server returns an error. Some servers may require a concept map to use for the translation. -->
</p>

<div class="example">
<p><b>Пример</b></p>
<p>
Перевод из FHIR Composition status в V3 Act Status (на основе 
<a href="composition-status-map-v3.html">этой определенной карты соответствия концептов</a>):
<!-- Translate from FHIR Composition status to <a href="https://www.hl7.org/implement/standards/product_brief.cfm?product_id=186">HL7 v3</a> Act Status (based on
<a href="composition-status-map-v3.html">this defined concept map</a>: -->
</p>
<pre class="http">
GET [base]/ConceptMap/$translate?system=http://hl7.org/fhir/composition-status
  &amp;code=preliminary&amp;valueSet= http://hl7.org/fhir/ValueSet/composition-status
  &amp;target=http://hl7.org/fhir/ValueSet/v3-ActStatus
</pre>
<p>
Сервер отвечает информацией о валидации:
<!-- The server responds with validation information:-->
</p>
<pre class="http">
HTTP/1.1 200 OK
[other headers]

{
  "resourceType" : "Parameters",
  "parameter" : [
    {
    "name" : "result",
    "valueBoolean" : "true"
    }, 
    {
      "name" : "outcome",
      "valueCoding" : {
        "system" : "http://hl7.org/fhir/v3/ActStatus",
        "code" : "active",
      }
    }
  ]
}
</pre>
</div>


<h3>Пакетное выполнение переводов<!-- Batch Translation --></h3>

<p>
Также имеется возможность перевести сразу несколько концептов с помощью операции <code>$translate</code> взаимодействия <a href="http.html#batch">Batch</a>.
<!-- It is also possible to validate a set of concepts against their relevant value
sets by using the <code>$translate</code> operation in a <a href="http.html#batch">Batch</a> 
interaction. -->
</p>

<div class="example">
<p><b>Примеры<!-- Examples --></b></p>
<p>
Запрос на перевод 2 концептов из CDA-документа, с указанием OIDs в качестве идентификаторов наборов значений:
<!-- A request to translate 2 concepts from a <a href="http://www.hl7.org/implement/standards/product_brief.cfm?product_id=7">CDA</a> document, with OIDs for value set identifiers: -->
</p>
<pre class="http">
POST [base]
[other headers]

{
  "ResourceType": "Bundle",
  "type": "batch",
  "entry": [{
    "resource": {
      "ResourceType": "Parameters",
      "parameter": [{
        "name": "concept",
        "valueCodeableConcept": {
          "system": "http://loinc.org",
          "code": "2324-4"
        }
      },
    {
        "name": "target",
        "valueUri": "urn:oid:1.2.3.4.6"
      }]
      },
    "request": {
      "method": "POST",
      "url": "ConceptMap/$translate"
    }
  },
  {
    "resource": {
      "ResourceType": "Parameters",
      "parameter": [{
        "name": "concept",
        "valueCodeableConcept": {
          "system": "http://snomed.info/sct",
          "code": "22298006"
        }
      },
      {
        "name": "target",
        "valueUri": "urn:oid:1.2.3.4.7"
      }]
      },
    {
      "request": {
        "method": "POST",
        "url": "ConceptMap/$translate"
    }
    }]
  }
</pre>
<p>
Сервер отвечает серией результатов перевода:
<!-- The server responds with a series of translation outcomes: -->
</p>
<pre class="http">
HTTP/1.1 200 OK
[other headers]

{
  "ResourceType": "Bundle",
  "type": "batch-response",
  "entry": [{
    "resource": {
      "resourceType": "Parameters",
      "parameter": [{
        "name": "result",
        "valueBoolean": "false"
      },
      {
        "name": "message",
        "valueString": "'2324-4' is not a valid LOINC code"
      }]
      }
  },
  {
    "resource": {
      "resourceType": "Parameters",
      "parameter": [{
        "name": "result",
        "valueBoolean": "false"
      },
      {
        "name": "outcome",
        "valueCodeableConcept": {
          "coding": {
            "system": "http://example.com/codesystems/example",
            "code": "xxxx"
          }
        }
      }]
      }
  }]
}
</pre>

</div>

<a name="closure"> </a>
<h3>Поддержка таблицы замыканий<!-- Maintaining a Closure Table --></h3>

<p>
Эти 4 операции - Expand, Lookup, Validate и Translate - подходят для большинства эксплуатационных требований, 
связанных с использованием справочников. Однако есть один сложный, но важный сценарий использования, 
для которого они не предназначены - это логика интеграции на терминологической основе при поиске в приложениях.
<!-- The 4 operations Expand, Lookup, Validate, and Translate account for most operational requirements
associated with terminology use. However there is one difficult but important use case that 
they do not address, which is integrating terminologically based logic into application searches. -->
</p>
<p>
Типичный пример этого - пользователь, который хочет найти любые данные наблюдений для 
пациентов мужского пола в возрасте за 50, которые посещали конкретную клинику в конкретный 
2-недельный период, с диагнозом подагра, и у кого был повышенный уровень креатинина в сыворотке крови.
<!-- A typical example of this is a user that wants to find any observations for male patients over
the age of 50 who attended a particular clinic within a particular 2 week period, with a 
diagnosis of gout, and who had an elevated serum creatinine.  -->
</p>
<p>
В этом случае оба "diagnosis of gout" и "serum creatinine" задействуют запросы к наборам значений и/или 
проверки на включения (например SNOMED CT и LOINC соответственно). Этот поиск должен выполняться некоторым 
механизмом логической обработки, который знает, как найти эти данные в данном хранилище. 
Обычно это некоторый вид SQL-запроса, хотя есть и множество других технологий на выбор. 
Каким бы образом это ни делалось, основная трудность такой операции заключается в интеграции терминологических 
знаний с выполнением поиска, которое также охватывает и другие взаимосвязи, выраженные в критериях поиска.
<!-- In this case, both "diagnosis of gout" and "serum creatinine" involve value set and/or subsumption queries
(e.g. against SNOMED CT and LOINC respectively). This search has to be executed by some 
logical processing engine that knows how to find this data in a given persistence store. 
Often, this is some kind of SQL query, though many other technological choices are available. 
However this is done, the challenge with an operation like this is to integrate the 
terminological knowledge into a search execution that also covers other relationships expressed in the search criteria.  -->
</p>
<p>
Одним из подходов к этой проблеме будет использование операции развёртывания, описанной выше, таким образом, чтобы 
система, выполняющая поиск, могла производить развёртывания и затем искать по ним. Тут имеется пара проблем: 
<!-- One approach to this problem would be to using the expand operation above, so that the system executing
the search could generate expansions, and then search for these expansions. This has a couple of problems: -->
</p>
<ul>
  <li>список включенных кодов может быть очень длинным, и операция описка будет, соответственно, неэффективной 
  <!-- the list of subsumed codes could be very long, and the search operation becomes correspondingly inefficient --></li>
  <li>развёртывание включений может оказаться не законченным, следовательно, операция поиска не сможет быть корректной
  <!--  the expansion of the subsumption might not be closed, and so the search operation cannot be correct --> </li>
</ul>
<p>
An alternative approach is to generate a subsumption <a href="http://karwin.blogspot.com.au/2010/03/rendering-trees-with-closure-tables.html">closure table</a>,
which lists all the possible relationships, and allows for rapid execution of these kind of queries. However this has other problems:
</p>
<ul>
  <li>таблица классификации может быть очень большой (&gt;500000 записей для SNOMED CT), даже если из неё используется очень мало кодов
  <!--  the subsumption table can be very large (&gt;500000 records for SNOMED CT), even though very few of the codes are used --></li>
  <li>таблицы классификации, как правило, строятся заранее и не имеют дело с новыми кодами, тогда как они часто встречаются
  <!-- subsumption tables are generally built up front, and do not deal with new codes as they are encountered very well --></li>
  <li>они все еще не предлагают решение для незамкнутых развёртываний <!-- they still do not offer a solution for non-closed expansions --></li>
</ul>
<p>
Это основная причина, почему большинство систем не поддерживают посткоординацию или другие формы 
кодированных выражений.
<!-- This is the main reason why most systems do not support post-coordination or other forms
of coded expressions.  -->
</p>
<p>
В FHIR эта проблема решается созданием таблицы замыкания на лету, как только встречаются новые коды. 
Этот метод оставляет терминологический сервер FHIR ответственным за терминологические выводы, 
и клиента ответственным за поддержку таблиц замыканий. Для клиента нет разницы, посткоординирован ли концепт 
или нет. Вот описание работы этого процесса:
<!-- In FHIR, this problem is solved by building a closure table on the fly as new codes are seen.
This technique leaves the FHIR terminology server responsible for the terminological reasoning, 
and the client responsible for the closure table maintenance. To the client, it doesn't matter 
whether the concept is post-coordinated or not. Here's a description of how the process works: -->
</p>
<ol>
 <li>Клиент задает имя, ассоциированное с конкретным контекстом, в котором он хочет поддерживать таблицу замыкания классификации.
 <!-- the client defines a name associated with a particular context in which it wishes to maintain a subsumption based closure table. --></li>
 <li>Клиент регистрирует это имя в терминологическом сервере FHIR с помощью операции $closure (описанной ниже), с только одним параметром - именем контекста
 <!-- the client registers this name with the FHIR Terminology server using the $closure operation (described below), with only one parameter, the name of the context --></li>
 <li>каждый раз, когда клиентская система встречает новый Кодинг, не введенный в таблицу замыканий, она вызывает операцию $closure с именем контекста, и значение Кодинга, которое она встретила
 <!-- any time the client system encounters a new Coding that is not entered in the closure table, it calls the $closure operation with the context name, and the Coding value it has encountered --></li>
 <li>сервер возвращает ресурс ConceptMap с перечнем новых записей (code&nbsp;: system -&gt; code&nbsp;: system), которые клиенту следует добавить в свою таблицу замыканий 
 <!-- the server returns a ConceptMap resource with a list of new entries (code&nbsp;: system -&gt; code&nbsp;: system) that the client should add to its closure table --> 
   <ul>
    <li>сервер может указать, что записи следует удалить из этой таблицы, передав (code&nbsp;: system -&gt; code&nbsp;: system) с эквивалентом "unmatched" (хотя это не известно, зачем это может потребоваться)
	<!-- the server can indicate that entries should be removed from the table by providing a (code&nbsp;: system -&gt; code&nbsp;: system) with equivalence "unmatched" (though it's not known why that would be needed) --></li>
   </ul>
 </li>
 <li>Клиент добавляет эти записи в свою таблицу замыканий <!-- the client makes these entries into its closure table --> </li>
 <li>для облегчения процесса инициализации клиент может вызывать операцию $closure с несколькими значениями Кодингов<!-- to facilitate the initialization process, a client can call $closure with multiple Coding values --></li>
</ol>
<p>Операция <a href="conceptmap-operations.html#closure">$closure</a> принимает 2 параметра:
<!-- The <a href="conceptmap-operations.html#closure">$closure operation</a> takes 2 parameters: -->
</p>
<ul>
 <li>название контекста таблицы замыканий <!-- closure table context name --></li>
 <li>концепты для ввода в эту таблицу (0 или больше - 0 кодингов - это запрос на (ре-)инициализацию таблицы) <!-- concepts to enter into the table (0 or more - 0 codings is a request to (re-)initialise the table) --></li>
</ul>
<p>
Операция возвращает карту соответствия концептов, в которой есть список мэппингов, которые представляют новые записи для внесения в таблицу замыканий.
<!-- The operation returns a concept map which has a list of mappings that represent new entries to make in the closure table.  -->
</p>
<p>
Таблицу замыканий можно повторно синхронизировать, передав дополнительный параметр "version", который 
представляет собой значение, взятое из версии в одном из промежуточных ответов. Это запрос на воспроизведение 
всех изменений мэппингов с момента отправки этого ответа.
<!-- The closure table can be resynchronized by passing an additional "version" parameter, which is a value taken from the 
version in one of the delta responses. This is a request to replay all the mapping changes since that delta was sent. -->
</p>

<div class="example">
<p><b>Пример</b></p>
<p>
Клиент видит новый SNOMED CT-концепт "22298006" в элементе данных, который он отслеживает как "patient-problems":
<!-- The client sees a new SNOMED CT concept "22298006" in a data element it is tracking as "patient-problems": -->
</p>
<pre class="http">
POST [base]/$closure

{
  "resourceType" : "Parameters",
  "parameter" : [
    {
      "name" : "name",
      "valueString" : "patient-problems"
    }, 
    {
      "name" : "concept",
      "valueCoding" : {
        "system" : "http://snomed.info/sct",
        "code" : "22298006",
      }
    }
  ]
}

</pre>

<p>
Сервер отвечает набором новых записей для добавления к карте концептов. 
Он предоставляет важный элемент метаданных - версию, которую клиент 
может использовать для повторной синхронизации таблицы замыканий:
<!-- The server responds with a set of new entries to add to the concept map.
It provides one important piece of metadata - the version, which the client
can use to resynchronize the closure table: -->
</p>
<pre class="http">
HTTP/1.1 200 OK
[other headers]

{
  "resourceType": "ConceptMap",
  "identifier": "49088976-d54d-4d19-b868-3d4c18cebabb",
  "version": "8",
  "status": "active",
  "experimental": true,
  "date": "2012-06-13",
  "element": [
    {
      "codeSystem": "http://snomed.info/sct",
      "code": "22298006",
      "map": [
        {
          "codeSystem": "http://snomed.info/sct",
          "code": "128599005",
          "equivalence": "wider"
        }
      ]
    },
  ]
}
</pre>
</div>

<p>
Примечания:
</p>
<ul>
 <li>В этом простом примере добавление одного нового SNOMED CT-концепта создало одно существующее отношении категоризации. В общем случае клинического использования будет ожидаться более одного отношения
 <!-- In this simple example, the addition of a single new SNOMED CT concept created one existing subsumption relationship. In general clinical use, more than one relationship would be expected --></li>
 <li>В целях таблицы замыканий отношения считаются двунаправленными; например если А включает Б, тогда Б входит в А
 <!-- For the purposes of the closure table, the relationships are considered to be bi-directional; e.g. if A subsumes B, then B is subsumed by A --></li>
 <li>Заодно с вводимыми кодами, которые непосредственно используются, клиент также вводит в таблицу замыканий и термины для поиска
 <!-- As well as entering codes that are actually used, the client also enters search terms into the closure table --></li>
 <li>Комбинация системы и кода - это ключ к таблице замыканий; если сервер встречает два различных кода, имеющих одинаковое значение (например синтансический вариант), 
 он должен создать отношение равенства "equals" между ними
 <!-- The combination of the system and code is the key to the closure table; if the server encounters two different codes that have the same meaning (e.g. syntactical variation), it should create an "equals" relationship between them --></li>
</ul>

<p>
Клиент использует результат операции замыкания для поддержки таблицы замыканий. Если упрощенно, то это может выглядеть так:
<!-- The client uses the result of the closure operation to maintain a closure table. Simplistically, 
it might look like this: -->
</p>
<table class="grid">
 <tr>
    <td><b>Область действия</b></td>
   <td><b>Источник</b></td>
   <td><b>Цель</b></td>
   <td><b></b></td>
<!--    <td><b>Scope</b></td>
   <td><b>Source</b></td>
   <td><b>Target</b></td>
   <td><b></b></td> -->
 </tr>
 <tr>
   <td>patient-problems</td>
   <td>http://snomed.info/sct|22298006</td>
   <td>http://snomed.info/sct|128599005</td>
 </tr>
 <tr>
   <td>patient-problems</td>
   <td>http://snomed.info/sct|24595009</td>
   <td>http://snomed.info/sct|90560007</td>
 </tr>
 <tr>
   <td>obs-code</td>
   <td>http://loinc.org|14682-9</td>
   <td>http://loinc.org|LP41281-4</td>
 </tr>
</table>

<p>
Клиент может затем применять таблицу описанным способом, используя ее в рамках общих условий поиска. Используя пример выше: 
"Найти все данные наблюдений для пациентов мужского пола в возрасте старше 50 лет, которые обслуживались в конкретной клинике в конкретный двухнедельный период, с диагнозом подагра, и у которых повышенный уровень креатинина в сыворотке крови". Этот запрос можно составить, к примеру, с помощью SQL следующим образом:
<!-- The client can then use a table like this as part of its general search conditions. Using the example from above:
"Find any observations for male patients over the age of 50 who attended a particular clinic within a particular 
2 week period, with a diagnosis of gout, and who had an elevated serum creatinine." This query could be done, for 
instance, with an SQL query like this: -->
</p>
<pre>
 Select * from Observations, Patients, Encounters, Conditions, Observations as Obs2 where
   Observations.patient = Patients.Key and Patients.Age > 50 and 
   Observations.encounter = Encounters.Key and Encounter.clinic = [key] 
	   and encounter.date >= [date] and encounter.date &lt;= [date] and
	 Conditions.patient = Patients.Key and Conditions.code 
	   in (<span style="color: DarkGreen">select Source From ClosureTable 
		   where Scope = "patient-problems" and Target = "http://snomed.info/sct|90560007"</span>) and
	 Obs2.patient = Patients.Key and Obs2.value > 0.19 and Obs2.code 
	   in (<span style="color: DarkGreen">select Source From ClosureTable 
		   where Scope = "obs-code" and Target = "http://loinc.org|LP41281-4"</span>)
</pre>
<p>
Обратите внимание, что в реальных клинических системах таблицы намного более структурированы, чем предполагает этот простой пример, и, соответственно, запрос будет более сложным. Таблица замыканий будет, как правило, нормализоваться - этот пример сохранен простым для демонстрации общей идеи.
<!-- Note that in real clinical systems, tables are usually far more structured than this 
example implies, and the query is correspondingly more complex. The closure table
would usually be normalised - this example is kept simple to demonstrate the concept.  -->
</p>



<h3>Функциональные операции <!-- Functional Operations --> </h3>

<p>
Для поддержки терминологических операций в FHIR минимальный набор терминологических операций будет необходим. Эти операции - это подмножество доступных операций терминологического сервиса, определенных в спецификации [http://www.omg.org/spec/CTS2/1.0/ Common Terminology Services - Release 2 (CTS2)] и может быть классифицировано как:
<!-- In order to support terminology operations in FHIR a minimal set of terminology operations would be necessary.  These operations are a sub set of the available terminology service operations defined in the [http://www.omg.org/spec/CTS2/1.0/ Common Terminology Services - Release 2 (CTS2) specification] and can be categorized as: -->
</p>
<ul>
 <li>Административные операции <!-- Administrative Operations --></li>
 <li>Операции поиска/запросов <!-- Search/Query Operations --></li>
 <li>Операции авторизации/поддержки<!--  Authoring/Maintenance Operations --></li>
</ul>
<p>
Функциональные операции в этих трех категориях поддерживают доступ и управление такими терминологическими объектами, как Code Systems, Concepts, Value Sets и Concept Mappings. 
Далее приводятся функциональные операции, необходимые для поддержки терминологического сервиса FHIR.
<!-- Functional operations within these categories support the access and management of terminology objects such as Code Systems, Concepts, Value Sets and Concept Mappings. The functional operations necessary to support a FHIR terminology service are outlined here.   -->
</p>

<h4>Административные операции <!-- Administrative Operations --> </h4>
<ul>
 <li>Иметь возможность загрузить стандартную или локальную кодовую систему <!-- be able to load a standard or local code system --></li>
</ul>

<h4>Операции поиска/запросов <!-- Search/Query Operations --> </h4>

<p>Концепты <!-- Concepts --> </p>
<ul>
 <li>Извлечь описание концепта (отображаемое имя, классификаторы, ассоциации и т. д.) для данного кода/кодовой системы <!-- retrieve the concept details (display name, qualifiers, associations, etc.) for a given code/code system --></li>
 <li>Вернуть возможные совпадения концепта на основе критериев поиска <!-- return possible concept matches  based on search criteria --> </li>
 <li>Проверить, допустим ли код в данной кодовой системе (содержимом) <!-- validate whether a code is valid within a given code system (content) --></li>
 <li>Извлечь перечень кодов (например для использования в пользовательском интерфейсе) <!-- retrieve a list of codes (for example, to populate a user interface) --></li>
 <li>Вернуть потомков данного концепта <!-- return the decedents of a given concept --></li>
</ul>

<p>Кодовая система<!--  Code System --> </p>
<ul>
 <li>Извлечь метаданные кодовой системы <!-- retrieve the metadata for a code system --></li>
</ul>

<p>Набор значений <!-- Value Set --> </p>
<ul>
 <li>Извлечь метаданные набора значений <!-- retrieve the metadata for a value set --></li>
 <li>Вернуть набор значений в соответствии с критериями поиска <!-- return a value set based on search criteria --></li>
 <li>Установить, допустим ли код в наборе значений <!-- determine if a code is valid in a value set --></li>
 <li>Произвести развёртывание набора значений из определения набора значений. <!-- generate the Value set Expansion from the Value Set Definition. --></li>
</ul>

<p>Мэппинг <!-- Mapping --> </p>
<ul>
 <li>Извлечь метаданные набора карт <!-- retrieve the metadata for map set --></li>
 <li>Извлечь перевод (мэппинг) концепта(-ов) из данной кодовой системы-источника в целевой концепт(-ы) из целевой кодовой системы <!-- retrieve a translation (mapping) of concept(s) from a given source code system to target concept(s) from a target code system --></li>
</ul>

<h4>Операции авторизации/поддержки <!-- Authoring/Maintenance Operations --> </h4>
<p>Концепты<!-- Concepts --></p>
<ul>
 <li>Поддерживать таблицу замыканий <!-- maintain a closure table --></li>
</ul>

<p>Набор значений <!-- Value Set --> </p>
<ul>
 <li>Создать/редактировать набор значений <!-- create/editing a value set --></li>
</ul>

<p>Мэппинг <!-- Mapping --> </p>
<ul>
 <li>Перевести (отобразить) из исходной кодовой системы в целевую кодовую систему <!-- translate (map) from a source code system to a target code system --></li>
</ul>


</div>

[%file newfooter%]
    
    
</body>
</html>