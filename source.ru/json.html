<!DOCTYPE HTML>


      
[%settitle Формат JSON%]
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
[%file newheader%]
</head>
<body>
[%file newnavbar%]

<div class="col-9">

<%fmtheader json%>

<a name="json"> </a>
<h2>JSON-представление ресурсов</h2>
<p>
JSON-представление для ресурса описывается с помощью следующего формата:
<!-- The JSON representation for a resource is described using this format:  -->
</p>
<p>
<i>todo - develop this</i>
</p>
<p>
В отсутствие отдельного описания JSON-представление описывается относительно XML-представления:
<!-- In the current absence of a specific json description, the JSON representation is described relative to the XML representation: -->
</p>
<ul>
 <li>Имена членов JSON-объекта соответствуют именам элементов и атрибутов в XML, включая элементы, которые могут повторяться. Имена свойств чувствительны к регистру</li>
 <li>Как и в XML, JSON объекты и массивы не бывают пустыми, а свойства  are never empty, and properties никогда не содержат пустые значения (за исключением особого случая, описанного ниже). Следует опустить свойство, если оно пустое</li>
 <li>В JSON символы табуляции не являются частью содержимого ресурса. Приложения могут сохранять символы табуляции во время обработки ресурсов, но не обязаны это делать. Обратите внимание, что от символов табуляции могут зависеть электронные цифровые подписи</li>
</ul>

<p>Также имеются и различия:</p>
<ul>
 <li>В JSON-представлении нет пространств имен</li>
 <li>Тип ресурса представляется в JSON по-другому - instead of being the name of the base object (there is none in JSON), it is carried as the property "resourceType"</li>
 <li>Порядок следования свойств объекта в JSON-представлении не имеет значения, хотя внутри массива порядок должен поддерживаться</li>
 <li>JSON не имеет различия в обозначении атрибута и элемента, поэтому атрибуты (id, value) обрабатываются иначе</li>
 <li>JSON имеет систему обозначений для массивов, использующихся для представления повторяющихся элементов. Обратите внимание, что массивы используются, когда элемент может повторяться, даже если он не повторяется в данном случае</li>
 <li>XHTML-элемент &lt;div&gt; в типе данных <a href="narrative.html">Narrative</a> представлен как отдельная экранированная строка XHTML. Это делается для того, чтобы избежать проблем в JSON со смешанным содержимым и проч. XHTML ДОЛЖЕН по-прежнему соответствовать правилам, описанным для <a href="narrative.html">Narrative</a></li>
 <li>В JSON нет собственной поддержки синтаксиса комментариев. По конвенции содержимое. которое было бы комментариями в XML-представлении обозначается в свойстве с именем "fhir_comments", представляющем собой строковый массив, который может появиться в любом JSON-объекте. Это больше всего используется в экземплярах примеров, например в данной спецификации, но обычно не используется в работающих системах (и работающие системы могут отклонять ресурсы с комментариями)
 <!-- There is no inherent support in JSON for a comment syntax. As a convention, content that would be comments in an XML representation is represented in a property with the name "fhir_comments", which is an array of strings, which can appear on any JSON object. 
  This is heavily used in example instances, e.g. in this specification, but not usually used in production systems (and production systems may choose to reject resources with comments in them) --></li>
</ul>

<p>
Формат JSON для ресурсов приближен к стандартному XML-формату, что делает взаимное преобразование легкодоступным, поэтому XPath-запросы легко мапятся на запросы JSON-структур.
<!-- The JSON format for the resources follows the standard XML format closely to make interconversion 
easy, and so that XPath queries can easily be mapped to query the JSON structures. --> Однако различия – особенно с повторяющимся элементом, которого невозможно избежать – означают, что универсальные преобразователи XML --&gt; JSON не в состоянии выполнить эту операцию корректно. Эти <a href="downloads.html#refimpl">справочные платформы</a> 
предлагают функциональность по преобразованию XML &lt;--&gt; JSON, которая учитывает эти специфичные для FHIR технические детали.
</p>

<p>
Формальный mime-тип для этого формата - application/json+fhir.
</p>

<h3>JSON-представление для повторяющихся элементов</h3>

<p>
Элемент с максимальным кардинальным числом >1 (например x..* в определениях) может встречаться больше одного раза в экземпляре. В XML это делается простым повторением XML-элемента множество раз. В JSON это делается с помощью типа array. Обратите внимание, что:
</p>
<ul>
 <li>Имя массива указывается в единственном числе – так же как и XML-элемента.</li>
 <li>Элемент, который может повторяться, представляется в виде массива даже в том случае, если он не повторяется, чтобы процесс синтаксического разбора ресурса во всех случаях оставался одинаковым.</li>
 </ul>
<pre class="xml">
 &lt;<b>coding</b>&gt;
   &lt;<b>system</b> value="http://snomed.info/sct"/&gt;
   &lt;<b>code</b> value="104934005"/&gt;
 &lt;/<b>coding</b>/&gt;
 &lt;<b>coding</b>&gt;
   &lt;<b>system</b> value="http://loinc.org"/&gt;
   &lt;<b>code</b> value="2947-0"/&gt;
 &lt;/<b>coding</b>/&gt;
</pre>
<p>представляется в JSON как:</p>
<pre class="json">
 "coding": [
   {
     "system" : "http://snomed.info/sct",
     "code" : "104934005"
   },
   {
     "system" : "http://loinc.org",
     "code" : "2947-0"
   }
 ]
</pre>

<h3>JSON-представление примитивных элементов</h3>
<p>
FHIR-элементы с примитивными значениями представляются в двух частях:
</p>
<ul>
 <li>JSON-свойство с именем элемента, которое имеет JSON-тип числовой (number), логический (boolean) или строковый (string)</li>
 <li>JSON-свойство со знаком "_", добавленным в начало имени элемента, который, если присутствует, содержит id этого значения и/или расширения (и комментарии, если имеются)</li>
</ul>
<p>
FHIR-типы <a href="datatypes.html#integer">integer</a> и <a href="datatypes.html#decimal">decimal</a> представляются JSON-типом number, FHIR-тип <a href="datatypes.html#boolean">boolean</a>
 – как JSON boolean, а все остальные типы представляются как JSON-тип string, имеющий то же содержимое, что указано для соответствующего типа данных. Символы табуляции всегда являются значимыми (т. е. пробелы в начале и в конце для нестроковых типов не допускаются).</p>
<pre class="xml">
 &lt;<b>code</b> value="abc"/&gt; &lt;!-- code --&gt;
 &lt;<b>date</b> value="1972-11-30"/&gt; &lt;!-- dateTime --&gt;
 &lt;<b>deceased</b> value="false" /&gt; &lt;!-- boolean --&gt;
 &lt;<b>count</b> value="23" /&gt;  &lt;!-- integer --&gt;
</pre>
<p>в JSON представляется так:</p>
<pre class="json">
 "code" : "abc",
 "date" : "1972-11-30",
 "deceased" : false,
 "count" : 23
</pre>
<blockquote>
<p>При использовании JavaScript JSON.parse() реализации, имейте в виду, что JavaScript изначально поддерживает только один числовой тип данных, которым является число с плавающей точкой (floating point number). Это может привести к потере точности для чисел FHIR. Вы можете использовать пользовательскую программу синтаксического разбора (parser) и библиотеку больших чисел (например <a href="https://github.com/jtobey/javascript-bignum">https://github.com/jtobey/javascript-bignum</a>), если в этом имеется необходимость.</p>
</blockquote>
<p>
Если значение имеет атрибут id или расширения, то оно представляется следующим образом:
</p>
<pre class="xml">
 &lt;<b>dob</b> id="314159" value="1970-03-30" &gt;
   &lt;extension url="http://example.org/fhir/StructureDefinition/text"&gt;
     &lt;valueString value="Easter 1970"/&gt;     
   &lt;/extension&gt;
 &lt;/<b>dob</b>&gt;
</pre>
<p>в JSON представляется так:</p>
<pre class="json">
 "dob": "1972-11-30",
 "_dob": { 
   "id": "314159", 
   "extension" : [ {
      "url" : "http://example.org/fhir/StructureDefinition/text",
      "valueString" : "Easter 1970"
   }]
 }
</pre>
<p>Примечание: Если примитив имеет атрибут id или расширение, но не имеет value, то указывается только свойство со знаком "_".</p>
<p>
В случае, когда примитивный элемент может повторяться, это представляется двумя массивами. Для заполнения обоих массивов используется JSON-значение null,  чтобы привести в соответствие идентификатор и/или расширение с его значением в первом массиве, как продемонстрировано в этом примере:
</p>
<pre class="xml">
 &lt;<b>code</b> value="au"/&gt;
 &lt;<b>code</b> value="nz"&gt;
   &lt;extension url="http://hl7.org/fhir/StructureDefinition/display"&gt;
     &lt;valueString value="New Zealand a.k.a Kiwiland"/&gt;     
   &lt;/extension&gt;
 &lt;/<b>code</b>&gt;
</pre>
<p>в JSON представляется так:</p>
<pre class="json">
 "code": [ "au", "nz" ],
 "_code": [ 
   null, 
   { 
     "extension" : [ {
        "url" : "http://hl7.org/fhir/StructureDefinition/display",
      "valueString" : "New Zealand a.k.a Kiwiland"
     }]
   }
  ]
 }
</pre>
<p>Примечание: когда у одного из повторяющихся элементов нет значения (value), в первом массиве для него указывается значение null. Когда у элемента есть значение, но нет расширения/идентификатора, во втором массиве на месте этого элемента будет стоять null.</p>
<blockquote>
<p>
<b>Примечание разработчика</b>: Представление примитивных типов данных было разбито на две части с целью упрощения представления простых примитивных значений без идентификатора или расширений. Это действительно привело к издержкам, сделав представление атрибута id и расширений более неуклюжим, однако они оба редко используются с примитивными типами данных.
</p>
</blockquote>

<h3>JSON-представление элементов и сложных типов данных</h3>

<p>
Элементы и сложные <a href="datatypes.html">типы данных</a> (типы, содержащие именованные элементы других типов) представляются с помощью JSON-объекта, содержащего соответствующий элемент для каждого элемента в типе данных. Композиции могут иметь атрибуты id, которые преобразовываются в значения JSON-элементов объекта таким же способом, как описано для примитивов. Например:</p>
 <pre class="xml">
&lt;person&gt;
  &lt;text&gt;
    &lt;status value="generated" /&gt;
    &lt;div xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;p&gt;...&lt;/p&gt;&lt;/div&gt;
  &lt;/text&gt;
  &lt;name&gt;
    &lt;use value="official" /&gt;  
    &lt;given value="Karen" /&gt;
    &lt;family id="a2" value="Van" /&gt;
  &lt;/name&gt;
&lt;/person&gt;
</pre>
<p>в JSON представляется так:</p>
<pre class="json">
{
  "person" : {
    "name" : [{
      "use" : "official" ,
      "given" : [ "Karen" ],
      "family" : [ "Van" ]
      "_family" : [ {"id" : "a2"} ]
     }],
    "text" : {
      "status" : "generated" ,
      "div" : "&lt;div xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;p&gt;...&lt;/p&gt;&lt;/div&gt;"
    }
}
</pre>
<p>На что здесь необходимо обратить внимание:</p>
<ul>
<li>И given, и family являются повторяющимися XML-элементами, поэтому они сериализуются в Array вне зависимости от того, повторяются они в данном случае или нет.</li>
<li>В части family элемента 'name' атрибут 'id' представлен в _family способом, описанным выше.</li>
<li>XHTML-содержимое элемента 'div', который есть в Narrative-элементе 'text', представлено в виде экранированной строки в JSON-свойстве value. Корневым элементом в XHTML должен быть &lt;div&gt; в пространстве имен XHTML.</li>
</ul>

<h3>JSON-представление ресурсов</h3>
<p>
Ресурс – это JSON-объект со свойством "resourceType", который сообщает программе-анализатору, какой это тип ресурса:
</p>
<pre class="json">
{
  "resourceType" : "Patient",
  "text" : {
    "status" : "generated" ,
    "div" : "&lt;div xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;p&gt;...&lt;/p&gt;&lt;/div&gt;"
  }
  etc...
}
</pre>
<p>
Обратите внимание, что синтаксические анализаторы не могут полагаться на то, что свойство resourceType будет идти первым.
</p>
<blockquote>
<p>
<b>Примечание разработчика</b>: Это является проблемой для некоторых сериализаторов вида JSON -&gt; Object , которые предполагают, что свойство resourceType действительно идет первым, включая <a href="http://james.newtonking.com/json">Json.NET</a>. 
Однако некоторые JSON-генераторы не дают авторским приложениям управлять порядком значений свойств, поэтому эти реализации не могут взаимодействовать с реализациями, которые делают предположения о порядке. Учитывая, что JSON заявляет, что значения свойств являются неупорядоченной таблицей пар name/value, данная спецификация не может требовать, чтобы свойства шли в каком-то определенном порядке, хотя реализаторы могут зафиксировать порядок свойств, если у них есть такая возможность (и ссылочные платформы, предоставленные в этой спецификации, делают это).
</p>
</blockquote>

<p>
Для помощи в тестировании JSON-анализаторов приводится <a href="json-edge-cases.json">файл с примером</a>, демонстрирующим многие крайние случаи.
</p>

<a name="sig"> </a>
<h4>Цифровые подписи</h4>
<p>
<i>todo</i>
</p>

</div>

[%file newfooter%]
</body>
</html>