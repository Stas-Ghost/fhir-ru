<!DOCTYPE HTML>


      
[%settitle Формат JSON%]
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
[%file newheader%]
</head>
<body>
[%file newnavbar%]

<div class="col-12">

<%fmtheader json%>

<a name="json"> </a>
<h2>JSON-представление ресурсов</h2>
<table class="cols"><tr><td id="wg"><a _target="blank" href="[%wg its%]">[%wgt its%]</a> Work Group</td><td id="fmm"><a href="resource.html#maturity">Maturity Level</a>: 3</td><td id="ballot"><a href="help.html#status">Ballot Status</a>: <a href="history.html#pubs">DSTU 2</a></td></tr></table>
<p>
JSON-представление для ресурса описывается с помощью следующего формата:
<!-- The JSON representation for a resource is described using this format:  -->
</p>

<pre class="spec">{
  "resourceType" : "<a title="Base definition for all elements in a resource." class="dict" href="element-definitions.html#Element"><b>Element</b></a>",
  // from <a href="json.html">Source</a>: <a href="json.html">element #1</a>
  "<a title="long description" class="dict" href="json.html">property1</a>" : "&lt;<span style="color: darkgreen"><a href="datatypes.html">[primitive]</a></span>&gt;", <span style="color: Gray">//</span> <span style="color: navy; opacity: 0.8">short description</span>
  "<a title="long description" class="dict" href="json.html">property2</a>" : { <span style="color: darkgreen"><a href="datatypes.html">[Data Type]</a></span> }, <span style="color: Gray">//</span> <span style="color: navy; opacity: 0.8">short description</span>
  "<a title="long description" class="dict" href="json.html">property3</a>" : { <span style="color: Gray">//</span> <span style="color: navy; opacity: 0.8">Short Description</span>
    "<a title="long description" class="dict" href="json.html">propertyA</a>" : { <span style="color: darkgreen"><a href="datatypes.html#CodeableConcept">CodeableConcept</a></span> }, <span style="color: Gray">//</span> <span style="color: navy; opacity: 0.8"><a style="color: navy; opacity: 0.8" href="json.html">Short Description</a> (<a style="color: navy; opacity: 0.8" href="terminologies.html#example">Example</a>)</span>
  },
  "<a title="long description" class="dict" href="json.html">property4</a>" : [{ <span style="color: Gray">//</span> <span style="color: navy; opacity: 0.8">Short Description</span>
    "<a title="long description" class="dict" href="json.html">propertyB</a>" : { <span style="color: darkgreen"><a href="references.html#Reference">Reference</a>(<a href="resourcelist.html">ResourceType</a>)</span> } <span style="color: Gray">//</span> <span title="This element is required" style="color: brown"><b>R!</b></span>  <span style="color: navy; opacity: 0.8">Short Description</span>
  }]
}
</pre>
<p>
Используя этот формат:
<!-- Using this format: -->
</p>
<ul>
 <li>Для создания валидного JSON-экземпляра ресурса, замените содержимое значений свойств желаемым контентом, как описано в правилах типов и описании значений, которые можно найти в значении свойства каждого элемента</li>
 <li>В данном примере:
   <ol>
     <li><code>property1</code> имеет примитивный тип данных; значение свойства будет таким же, как описанное для указанного типа</li>
     <li><code>property2</code> имеет сложный тип данных; значением свойства будет объект с содержимым, соответствующим описанию к указанному типу</li>
     <li><code>property3</code> - это объектное свойство, которое содержит дополнительные свойства (например propertyA; допустимые свойства перечислены (и также включают расширения при необходимости)</li>
     <li><code>property4</code> - это массив, который содержит элементы, которые, в свою очередь, являются объектами. Эти элементы могут быть любого из типов, перечисленных в пунктах 1-3</li>
     <li><code>propertyA</code> имеет привязку к набору значений - слова "Краткое описание" являются ссылкой на соответствующий набор значений. Также указывается сила привязки</li>
     <li><code>propertyB</code> - это ссылка на конкретный тип ресурса</li>
   </ol>
 </li>
 <li>Названия свойств чувствительны к регистру (хотя дубликаты, различающиеся только регистром, не используются)</li>
 <li>Свойства можно указывать в любом порядке</li>
 <li>XHTML указывается в виде экранированной строки</li>
 <li>Объекты не могут быть пустыми. Если элемент присутствует в ресурсе, он ДОЛЖЕН иметь свойства, определенные для его типа, либо 1 или несколько <a href="extensibility.html">расширений</a></li>
 <li>Значения строковых свойств не могут быть пустыми. Либо свойство отсутствует, либо присутствует и содержит как минимум 1 символ</li>
 <li>Символ <span style="color: brown"><b>R!</b></span> означает, что элемент является обязательным - он должен присутствовать (либо в массиве должен быть как минимум один элемент)</li>
 <li>В данном формате <code>//</code> используется для комментариев, но это нельзя использовать в JSON-экземплярах</li>
 <li>Символьная кодировка всегда UTF-8</li>
 <li>MIME-тип для этого формата - <code>application/json+fhir</code>.</li>
<!--  <li>To build a valid JSON instance of a resource, replace the contents of the property values with valid content 
   as described by the type rules and content description found in the property value for each element</li>
 <li>In this example:
   <ol>
     <li><code>property1</code> has a primitive data type; the value of the property will be as described for the stated type</li>
     <li><code>property2</code> has a complex data type; the value of the property is an object that has the content as described for the stated type</li>
     <li><code>property3</code> is an object property that contains additional properties (e.g. propertyA; the allowable properties are listed (but also include extensions as appropriate)</li>
     <li><code>property4</code> is an array property that contains items which are objects themselves. The items may have any of the types already encountered in points 1-3</li>
     <li><code>propertyA</code> has a binding to a value set - the Short description is a link to the value set. In addition, the binding strength is shown </li>
     <li><code>propertyB</code> is a reference to a particular kind of resource </li>
   </ol>
 </li>
 <li>Property names are case-sensitive (though duplicates that differ only in case are never defined)</li>
 <li>Properties can appear in any order</li>
 <li>XHTML is represented as an escaped string</li>
 <li>Objects are never empty. If an element is present in the resource, it SHALL have properties as defined for its type, or 1 or more <a href="extensibility.html">extensions</a></li>
 <li>String property values can never be empty. Either the property is absent, or it is present with at least one character of content</li>
 <li>The <span style="color: brown"><b>R!</b></span> denotes that an element is mandatory - it must be present (or in an array, at least one item must be present)</li>
 <li>In this format, <code>//</code> is used for comments but these can't be in the JSON instances</li>
 <li>The character encoding is always UTF-8</li>
 <li>The MIME-type for this format is <code>application/json+fhir</code>.</li> -->
</ul>

<p>
Given the way <a href="extensibility.html">extensions</a> work, applications reading
JSON resources will never enocunter unknown properties. However once an application
starts trading with other appplications that conform to later versions of this specification,
unknown properties may be encountered. Applications MAY choose to ignore unknown properties
in order to foster forwards compatibility in this regard, but may also choose not to.
Applications declare their behavior with regard to unknown elements using
<a href="conformance-definitions.html#Conformance.acceptUnknown">Conformance.acceptUnknown</a>.
</p>

<a name="xml"> </a>

<h3>Сравнение с XML<!-- Comparison with XML --></h3>
<p>
JSON-формат подобен XML-формату:
<!-- The JSON format is similar to the XML format: -->
</p>
<ul>
 <li>Имена членов JSON-объекта соответствуют именам элементов и атрибутов в XML, включая элементы, которые могут повторяться. Имена свойств чувствительны к регистру</li>
 <li>Как и в XML, JSON объекты и массивы не бывают пустыми, а свойства  are never empty, and properties никогда не содержат пустые значения (за исключением особого случая, описанного ниже). Следует опустить свойство, если оно пустое</li>
 <li>В JSON символы табуляции не являются частью содержимого ресурса. Приложения могут сохранять символы табуляции во время обработки ресурсов, но не обязаны это делать. Обратите внимание, что от символов табуляции могут зависеть электронные цифровые подписи</li>
</ul>

<p>There are differences to XML:</p>
<ul>
 <li>В JSON-представлении нет пространств имен</li>
 <li>Тип ресурса представляется в JSON по-другому - не как имя базового объекта (котрого в JSON нет), а как свойство <code>resourceType</code></li>
 <li>Порядок следования свойств объекта в JSON-представлении не имеет значения, хотя внутри массива порядок должен поддерживаться</li>
 <li>JSON не имеет различия в обозначении атрибута и элемента, поэтому атрибуты (e.g. <code>id</code>, <code>value</code>) обрабатываются иначе (см. ниже)</li>
 <li>В JSON есть обозначение массива, используемое для представления повторяющихся элементов. Обратите внимание, что массивы используются, когда элемент может повторяться, даже если он не повторяется в конкретном случае</li>
 <li>XHTML-элемент <code>&lt;div&gt;</code> в типе данных <a href="narrative.html">Narrative</a> представлен как отдельная экранированная строка XHTML. Это делается для того, чтобы избежать проблем в JSON со смешанным содержимым и проч. XHTML ДОЛЖЕН по-прежнему соответствовать правилам, описанным для <a href="narrative.html">Narrative</a></li>
 <li>В JSON нет собственной поддержки синтаксиса комментариев. По конвенции содержимое. которое было бы комментариями в XML-представлении обозначается в свойстве с именем "fhir_comments", представляющем собой строковый массив, который может появиться в любом JSON-объекте. Это больше всего используется в экземплярах примеров, например в данной спецификации, но обычно не используется в работающих системах (и работающие системы могут отклонять ресурсы с комментариями)
 <!-- There is no inherent support in JSON for a comment syntax. As a convention, content that would be comments in an XML representation is represented in a property with the name <code>fhir_comments</code>, which is an array of strings, which can appear on any JSON object.
  This is heavily used in example instances, e.g. in this specification, but not usually used in production systems (and production systems may choose to reject resources with comments in them) --></li>
</ul>

<p>
Формат JSON для ресурсов приближен к стандартному XML-формату, что делает взаимное преобразование легкодоступным, поэтому XPath-запросы легко мапятся на запросы JSON-структур.
<!-- The JSON format for the resources follows the standard XML format closely to make interconversion 
easy, and so that XPath queries can easily be mapped to query the JSON structures. --> Однако различия – особенно с повторяющимся элементом, которого невозможно избежать – означают, что универсальные преобразователи XML --&gt; JSON не в состоянии выполнить эту операцию корректно. Эти <a href="downloads.html#refimpl">справочные платформы</a> 
предлагают функциональность по преобразованию XML &lt;--&gt; JSON, которая учитывает эти специфичные для FHIR технические детали.
</p>


<a name="repeat"> </a>
<h3>JSON-представление для повторяющихся элементов</h3>

<p>
Элемент с максимальным кардинальным числом >1 (например <code>x..*</code> в определениях) может встречаться больше одного раза в экземпляре. В XML это делается простым повторением XML-элемента множество раз. В JSON это делается с помощью типа array. Обратите внимание, что:
</p>
<ul>
 <li>Имя массива указывается в единственном числе – так же как и XML-элемента.</li>
 <li>Элемент, который может повторяться, представляется в виде массива даже в том случае, если он не повторяется, чтобы процесс синтаксического разбора ресурса во всех случаях оставался одинаковым.</li>
 </ul>
<pre class="xml">
 &lt;<b>coding</b>&gt;
   &lt;<b>system</b> value="http://snomed.info/sct"/&gt;
   &lt;<b>code</b> value="104934005"/&gt;
 &lt;/<b>coding</b>/&gt;
 &lt;<b>coding</b>&gt;
   &lt;<b>system</b> value="http://loinc.org"/&gt;
   &lt;<b>code</b> value="2947-0"/&gt;
 &lt;/<b>coding</b>/&gt;
</pre>
<p>представляется в JSON как:</p>
<pre class="json">
 "coding": [
   {
     "system" : "http://snomed.info/sct",
     "code" : "104934005"
   },
   {
     "system" : "http://loinc.org",
     "code" : "2947-0"
   }
 ]
</pre>

<a name="primitive"> </a>
<h3>JSON-представление примитивных элементов</h3>
<p>
FHIR-элементы с примитивными типами данных представляются в двух частях:
</p>
<ul>
 <li>JSON-свойство с именем элемента, которое имеет JSON-тип числовой (number), логический (boolean) или строковый (string)</li>
 <li>JSON-свойство со знаком <code>_</code>, добавленным в начало имени элемента, который, если присутствует, содержит id этого значения и/или расширения (и комментарии, если имеются)</li>
</ul>
<p>
FHIR-типы <a href="datatypes.html#integer">integer</a> и <a href="datatypes.html#decimal">decimal</a> представляются JSON-типом number, FHIR-тип <a href="datatypes.html#boolean">boolean</a>
 – как JSON boolean, а все остальные типы представляются как JSON-тип string, имеющий то же содержимое, что указано для соответствующего типа данных. Символы табуляции всегда являются значимыми (т. е. пробелы в начале и в конце для нестроковых типов не допускаются).</p>
<pre class="xml">
 &lt;<b>code</b> value="abc"/&gt; &lt;!-- code --&gt;
 &lt;<b>date</b> value="1972-11-30"/&gt; &lt;!-- dateTime --&gt;
 &lt;<b>deceased</b> value="false" /&gt; &lt;!-- boolean --&gt;
 &lt;<b>count</b> value="23" /&gt;  &lt;!-- integer --&gt;
</pre>
<p>в JSON представляется так:</p>
<pre class="json">
 "code" : "abc",
 "date" : "1972-11-30",
 "deceased" : false,
 "count" : 23
</pre>
<a name="decimal"> </a>
<div class="warning">
<blockquote>
<p>При использовании JavaScript JSON.parse() реализации обратите внимание, что JavaScript изначально поддерживает только один числовой тип данных, которым является число с плавающей точкой (floating point number). Это может привести к потере точности для чисел FHIR. В частности, нули после точки будут потеряны, например 2.00 превратится в 2.
FHIR-тип данных decimal определен таким образом, чтобы точность, включая нули на кнце, сохранялась в целях представления, поскольку это часто является критичным требованием для корректного представления клинических измерений. Реализациям следует рассмотреть использование кастомного парсерав и библиотеки больших чисел (например <a href="https://github.com/jtobey/javascript-bignum">https://github.com/jtobey/javascript-bignum</a>) для удовлетворения этих требований.</p>
</blockquote>
</div>
<a name="null"> </a>
<p>
Если значение имеет атрибут id или расширения, то оно представляется следующим образом:
</p>
<pre class="xml">
 &lt;<b>birthDate</b> id="314159" value="1970-03-30" &gt;
   &lt;extension url="http://example.org/fhir/StructureDefinition/text"&gt;
     &lt;valueString value="Easter 1970"/&gt;     
   &lt;/extension&gt;
 &lt;/<b>birthDate</b>&gt;
</pre>
<p>в JSON представляется так:</p>
<pre class="json">
 "birthDate": "1970-03-30",
 "_birthDate": { 
   "id": "314159", 
   "extension" : [ {
      "url" : "http://example.org/fhir/StructureDefinition/text",
      "valueString" : "Easter 1970"
   }]
 }
</pre>
<p>Примечание: Если примитив имеет атрибут id или расширение, но не имеет value, то указывается только свойство со знаком <code>_</code>.</p>
<p>
В случае, когда примитивный элемент может повторяться, это представляется двумя массивами. Для заполнения обоих массивов используется JSON-значение null,  чтобы привести в соответствие идентификатор и/или расширение с его значением в первом массиве, как продемонстрировано в этом примере:
</p>
<pre class="xml">
 &lt;<b>code</b> value="au"/&gt;
 &lt;<b>code</b> value="nz"&gt;
   &lt;extension url="http://hl7.org/fhir/StructureDefinition/display"&gt;
     &lt;valueString value="New Zealand a.k.a Kiwiland"/&gt;     
   &lt;/extension&gt;
 &lt;/<b>code</b>&gt;
</pre>
<p>в JSON представляется так:</p>
<pre class="json">
 "code": [ "au", "nz" ],
 "_code": [ 
   null, 
   { 
     "extension" : [ {
        "url" : "http://hl7.org/fhir/StructureDefinition/display",
      "valueString" : "New Zealand a.k.a Kiwiland"
     }]
   }
  ]
</pre>
<p>Примечание: когда у одного из повторяющихся элементов нет значения (value), в первом массиве для него указывается значение null. Когда у элемента есть значение, но нет расширения/идентификатора, во втором массиве на месте этого элемента будет стоять null.</p>
<blockquote>
<p>
<b>Примечание разработчика</b>: Представление примитивных типов данных было разбито на две части с целью упрощения представления простых примитивных значений без идентификатора или расширений. Это действительно привело к издержкам, сделав представление атрибута id и расширений более неуклюжим, однако они оба редко используются с примитивными типами данных.
</p>
</blockquote>

<a name="complex"> </a>

<h3>JSON-представление элементов и сложных типов данных</h3>

<p>
Элементы и сложные <a href="datatypes.html">типы данных</a> (типы, содержащие именованные элементы других типов) представляются с помощью JSON-объекта, содержащего соответствующий элемент для каждого элемента в типе данных. Композиции могут иметь атрибуты id, которые преобразовываются в значения JSON-элементов объекта таким же способом, как описано для примитивов. Например:</p>
 <pre class="xml">
&lt;person&gt;
  &lt;text&gt;
    &lt;status value="generated" /&gt;
    &lt;div xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;p&gt;...&lt;/p&gt;&lt;/div&gt;
  &lt;/text&gt;
  &lt;name&gt;
    &lt;use value="official" /&gt;  
    &lt;given value="Karen" /&gt;
    &lt;family id="a2" value="Van" /&gt;
  &lt;/name&gt;
&lt;/person&gt;
</pre>
<p>в JSON представляется так:</p>
<pre class="json">
{
  "person" : {
    "name" : [{
      "use" : "official" ,
      "given" : [ "Karen" ],
      "family" : [ "Van" ]
      "_family" : [ {"id" : "a2"} ]
     }],
    "text" : {
      "status" : "generated" ,
      "div" : "&lt;div xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;p&gt;...&lt;/p&gt;&lt;/div&gt;"
    }
}
</pre>
<p>На что здесь необходимо обратить внимание:</p>
<ul>
<li>И given, и family являются повторяющимися XML-элементами, поэтому они сериализуются в Array вне зависимости от того, повторяются они в данном случае или нет.</li>
<li>В части family элемента <code>name</code> атрибут <code>id</code> представлен в <code>_family</code> способом, описанным выше.</li>
<li>XHTML-содержимое элемента <code>div</code>, который есть в Narrative-элементе <code>text</code>, представлено в виде экранированной строки в JSON-свойстве value. Корневым элементом в XHTML должен быть &lt;div&gt; в пространстве имен XHTML.</li>
</ul>

<a name="resources"> </a>

<h3>JSON-представление ресурсов</h3>
<p>
Ресурс – это JSON-объект со свойством <code>resourceType</code>, который сообщает программе-анализатору, какой это тип ресурса:
</p>
<pre class="json">
{
  "resourceType" : "Patient",
  "text" : {
    "status" : "generated" ,
    "div" : "&lt;div xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;p&gt;...&lt;/p&gt;&lt;/div&gt;"
  }
  etc...
}
</pre>
<p>
Обратите внимание, что синтаксические анализаторы не могут полагаться на то, что свойство resourceType будет идти первым.
</p>
<blockquote>
<p>
<b>Примечание разработчика</b>: Это является проблемой для некоторых сериализаторов вида JSON -&gt; Object , которые предполагают, что свойство resourceType действительно идет первым, включая <a href="http://james.newtonking.com/json">Json.NET</a>. 
Однако некоторые JSON-генераторы не дают авторским приложениям управлять порядком значений свойств, поэтому эти реализации не могут взаимодействовать с реализациями, которые делают предположения о порядке. Учитывая, что JSON заявляет, что значения свойств являются неупорядоченной таблицей пар name/value, данная спецификация не может требовать, чтобы свойства шли в каком-то определенном порядке, хотя реализаторы могут зафиксировать порядок свойств, если у них есть такая возможность (и ссылочные платформы, предоставленные в этой спецификации, делают это).
</p>
</blockquote>

<p>
Для помощи в тестировании JSON-анализаторов приводится <a href="json-edge-cases.json">файл с примером</a>, демонстрирующим многие крайние случаи.
</p>

<a name="sig"> </a>
<a name="canonical"> </a>

<h3>Canonical JSON</h3>
<p>
Resources and/or Bundles may be digitally signed (see <a href="bundle.html">Bundle</a> and <a href="provenance.html">Provenance</a>).
</p>
<p>
This specification defines the following method for canonicalizing FHIR resources, when represented as
JSON:
</p>
<ul>
 <li>No whitespace other than single spaces in property values and in the xhtml in the <a href="narrative.html">Narrative</a></li>
 <li>Order properties alphabetically</li>
 <li>Omit all properties that have a default value, if a default value is defined</li>
 <li>Omit all comments (<code>fhir_comments</code> property as defined above)</li>
</ul>
<p>
This canonicalization method is identified by the URL <code>http://hl7.org/fhir/canonicalization/json</code>. The
following additional canonicalization URLS are also defined:
</p>
<table class="grid">
 <tr>
  <td>http://hl7.org/fhir/canonicalization/json#data</td>
  <td>The narrative (<code>Resource.text</code>) is omitted prior to signing (note the deletion is at <code>Resource.text</code>, not <code>Resource.text.div</code>)</td>
 </tr>
 <tr>
  <td>http://hl7.org/fhir/canonicalization/json#static</td>
  <td>In addition to narrative (Resource.text), the <code>Resource.meta</code> element is removed. This makes the signature robust as the content is moved from server to server, or workflow and access tags are added or removed</td>
 </tr>
 <tr>
  <td>http://hl7.org/fhir/canonicalization/json#narrative</td>
  <td>The method only covers the <code>Resource.id</code> and Narrative is retained</td>
 </tr>
</table>
<p>
These canonicalization methods allow system the flexiibility to sign the various portions of
the resource that matter for the workflow the signature serves.
</p>

<p>
Note: One consequence of signing the document is that URLs, identifiers and internal references are frozen and
cannot be changed. This might be a desired feature, but it may also cripple interoperability between closed
ecosystems where <a href="managing.html">re-identification</a> frequently occurs. For this reason, it is
recommended that systems consider carefully the impact of any signature processes. The impact of signatures
on <a href="documents.html">Document bundles</a> and their related processes is the most well understood
use of digital signatures.
</p>

</div>

[%file newfooter%]
</body>
</html>
