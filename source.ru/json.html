<!DOCTYPE HTML>


      
[%settitle Формат JSON%]
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
[%file newheader%]
</head>
<body>
[%file newnavbar%]

<div class="col-9">

<%fmtheader json%>

<a name="json"> </a>
<h2>JSON-представление ресурсов</h2>
<p>
JSON-представление для ресурса описывается с помощью следующего формата:
<!-- The JSON representation for a resource is described using this format:  -->
</p>

<pre class="spec">{
  "resourceType" : "<a title="Base definition for all elements in a resource." class="dict" href="element-definitions.html#Element"><b>Element</b></a>",
  // from <a href="json.html">Source</a>: <a href="json.html">elemnt #1</a>
  "<a title="long description" class="dict" href="json.html">property1</a>" : "&lt;<span style="color: darkgreen"><a href="datatypes.html">[primitive]</a></span>&gt;", <span style="color: Gray">//</span> <span style="color: navy; opacity: 0.8">short description</span>
  "<a title="long description" class="dict" href="json.html">property2</a>" : { <span style="color: darkgreen"><a href="datatypes.html">[Data Type]</a></span> }, <span style="color: Gray">//</span> <span style="color: navy; opacity: 0.8">short description</span>
  "<a title="long description" class="dict" href="json.html">property3</a>" : { <span style="color: Gray">//</span> <span style="color: navy; opacity: 0.8">Short Description</span>
    "<a title="long description" class="dict" href="json.html">propertyA</a>" : { <span style="color: darkgreen"><a href="datatypes.html#CodeableConcept">CodeableConcept</a></span> }, <span style="color: Gray">//</span> <span style="color: navy; opacity: 0.8"><a style="color: navy; opacity: 0.8" href="json.html">Short Description</a> (<a style="color: navy; opacity: 0.8" href="terminologies.html#example">Example</a>)</span>
  },
  "<a title="long description" class="dict" href="json.html">property4</a>" : [{ <span style="color: Gray">//</span> <span style="color: navy; opacity: 0.8">Short Description</span>
    "<a title="long description" class="dict" href="json.html">propertyB</a>" : { <span style="color: darkgreen"><a href="references.html#Reference">Reference</a>(<a href="resourcelist.html">ResourceType</a>)</span> } <span style="color: Gray">//</span> <span title="This element is required" style="color: brown"><b>R!</b></span>  <span style="color: navy; opacity: 0.8">Short Description</span>
  }]
}
</pre>
<p>
Using this format:
</p>
<ul>
 <li>To build a valid JSON instance of a resource, replace the contents of the property values with valid content 
   as described by the type rules and content description found in the property value for each element</li>
 <li>In this example:
   <ol>
     <li><code>property1</code> has a primitive data type; the value of the property will be as described for the stated type</li>
     <li><code>property2</code> has a complex data type; the value of the property is an object that has the content as described for the stated type</li>
     <li><code>property3</code> is an object property that contains additional properties (e.g. propertyA; the allowable properties are listed (but also include extensions as appropriate)</li>
     <li><code>property4</code> is an array property that contains items which are objects themselves. The items may have any of the types already encountered in points 1-3</li>
     <li><code>propertyA</code> has a binding to a value set - the Short description is a link to the value set. In addition, the binding strength is shown </li>
     <li><code>propertyB</code> is a reference to a particular kind of resource </li>
   </ol>
 </li>
 <li>Property names are case-sensitive (though duplicates that differ only in case are never defined)</li>
 <li>Properties can appear in any order</li>
 <li>XHTML is represented as an escaped string</li>
 <li>Objects are never empty. If an element is present in the resource, it SHALL have properties as defined for its type, or 1 or more <a href="extensibility.html">extensions</a></li>
 <li>String property values can never be empty. Either the property is absent, or it is present with at least one character of content</li>
 <li>The <span style="color: brown"><b>R!</b></span> denotes that an element is mandatory - it must be present (or in an array, at least one item must be present)</li>
 <li>In this format, // is used for comments but these can't be in the JSON instances</li>
 <li>The character encoding is always UTF-8</li>
 <li>The MIME-type for this format is application/json+fhir.</li>
</ul>

<h3>Comparison with XML</h3>
<p>
The JSON format is similar to the XML format:
</p>
<ul>
 <li>Имена членов JSON-объекта соответствуют именам элементов и атрибутов в XML, включая элементы, которые могут повторяться. Имена свойств чувствительны к регистру</li>
 <li>Как и в XML, JSON объекты и массивы не бывают пустыми, а свойства  are never empty, and properties никогда не содержат пустые значения (за исключением особого случая, описанного ниже). Следует опустить свойство, если оно пустое</li>
 <li>В JSON символы табуляции не являются частью содержимого ресурса. Приложения могут сохранять символы табуляции во время обработки ресурсов, но не обязаны это делать. Обратите внимание, что от символов табуляции могут зависеть электронные цифровые подписи</li>
</ul>

<p>There are differences to XML:</p>
<ul>
 <li>В JSON-представлении нет пространств имен</li>
 <li>Тип ресурса представляется в JSON по-другому - instead of being the name of the base object (there is none in JSON), it is carried as the property "resourceType"</li>
 <li>Порядок следования свойств объекта в JSON-представлении не имеет значения, хотя внутри массива порядок должен поддерживаться</li>
 <li>JSON не имеет различия в обозначении атрибута и элемента, поэтому атрибуты (id, value) обрабатываются иначе (см. ниже)</li>
 <li>В JSON есть обозначение массива, используемое для представления повторяющихся элементов. Обратите внимание, что массивы используются, когда элемент может повторяться, даже если он не повторяется в конкретном случае</li>
 <li>XHTML-элемент &lt;div&gt; в типе данных <a href="narrative.html">Narrative</a> представлен как отдельная экранированная строка XHTML. Это делается для того, чтобы избежать проблем в JSON со смешанным содержимым и проч. XHTML ДОЛЖЕН по-прежнему соответствовать правилам, описанным для <a href="narrative.html">Narrative</a></li>
 <li>В JSON нет собственной поддержки синтаксиса комментариев. По конвенции содержимое. которое было бы комментариями в XML-представлении обозначается в свойстве с именем "fhir_comments", представляющем собой строковый массив, который может появиться в любом JSON-объекте. Это больше всего используется в экземплярах примеров, например в данной спецификации, но обычно не используется в работающих системах (и работающие системы могут отклонять ресурсы с комментариями)
 <!-- There is no inherent support in JSON for a comment syntax. As a convention, content that would be comments in an XML representation is represented in a property with the name "fhir_comments", which is an array of strings, which can appear on any JSON object. 
  This is heavily used in example instances, e.g. in this specification, but not usually used in production systems (and production systems may choose to reject resources with comments in them) --></li>
</ul>

<p>
Формат JSON для ресурсов приближен к стандартному XML-формату, что делает взаимное преобразование легкодоступным, поэтому XPath-запросы легко мапятся на запросы JSON-структур.
<!-- The JSON format for the resources follows the standard XML format closely to make interconversion 
easy, and so that XPath queries can easily be mapped to query the JSON structures. --> Однако различия – особенно с повторяющимся элементом, которого невозможно избежать – означают, что универсальные преобразователи XML --&gt; JSON не в состоянии выполнить эту операцию корректно. Эти <a href="downloads.html#refimpl">справочные платформы</a> 
предлагают функциональность по преобразованию XML &lt;--&gt; JSON, которая учитывает эти специфичные для FHIR технические детали.
</p>


<h3>JSON-представление для повторяющихся элементов</h3>

<p>
Элемент с максимальным кардинальным числом >1 (например x..* в определениях) может встречаться больше одного раза в экземпляре. В XML это делается простым повторением XML-элемента множество раз. В JSON это делается с помощью типа array. Обратите внимание, что:
</p>
<ul>
 <li>Имя массива указывается в единственном числе – так же как и XML-элемента.</li>
 <li>Элемент, который может повторяться, представляется в виде массива даже в том случае, если он не повторяется, чтобы процесс синтаксического разбора ресурса во всех случаях оставался одинаковым.</li>
 </ul>
<pre class="xml">
 &lt;<b>coding</b>&gt;
   &lt;<b>system</b> value="http://snomed.info/sct"/&gt;
   &lt;<b>code</b> value="104934005"/&gt;
 &lt;/<b>coding</b>/&gt;
 &lt;<b>coding</b>&gt;
   &lt;<b>system</b> value="http://loinc.org"/&gt;
   &lt;<b>code</b> value="2947-0"/&gt;
 &lt;/<b>coding</b>/&gt;
</pre>
<p>представляется в JSON как:</p>
<pre class="json">
 "coding": [
   {
     "system" : "http://snomed.info/sct",
     "code" : "104934005"
   },
   {
     "system" : "http://loinc.org",
     "code" : "2947-0"
   }
 ]
</pre>

<h3>JSON-представление примитивных элементов</h3>
<p>
FHIR-элементы с примитивными значениями представляются в двух частях:
</p>
<ul>
 <li>JSON-свойство с именем элемента, которое имеет JSON-тип числовой (number), логический (boolean) или строковый (string)</li>
 <li>JSON-свойство со знаком "_", добавленным в начало имени элемента, который, если присутствует, содержит id этого значения и/или расширения (и комментарии, если имеются)</li>
</ul>
<p>
FHIR-типы <a href="datatypes.html#integer">integer</a> и <a href="datatypes.html#decimal">decimal</a> представляются JSON-типом number, FHIR-тип <a href="datatypes.html#boolean">boolean</a>
 – как JSON boolean, а все остальные типы представляются как JSON-тип string, имеющий то же содержимое, что указано для соответствующего типа данных. Символы табуляции всегда являются значимыми (т. е. пробелы в начале и в конце для нестроковых типов не допускаются).</p>
<pre class="xml">
 &lt;<b>code</b> value="abc"/&gt; &lt;!-- code --&gt;
 &lt;<b>date</b> value="1972-11-30"/&gt; &lt;!-- dateTime --&gt;
 &lt;<b>deceased</b> value="false" /&gt; &lt;!-- boolean --&gt;
 &lt;<b>count</b> value="23" /&gt;  &lt;!-- integer --&gt;
</pre>
<p>в JSON представляется так:</p>
<pre class="json">
 "code" : "abc",
 "date" : "1972-11-30",
 "deceased" : false,
 "count" : 23
</pre>
<blockquote>
<p>При использовании JavaScript JSON.parse() реализации, имейте в виду, что JavaScript изначально поддерживает только один числовой тип данных, которым является число с плавающей точкой (floating point number). Это может привести к потере точности для чисел FHIR. Вы можете использовать пользовательскую программу синтаксического разбора (parser) и библиотеку больших чисел (например <a href="https://github.com/jtobey/javascript-bignum">https://github.com/jtobey/javascript-bignum</a>), если в этом имеется необходимость.</p>
</blockquote>
<p>
Если значение имеет атрибут id или расширения, то оно представляется следующим образом:
</p>
<pre class="xml">
 &lt;<b>birthDate</b> id="314159" value="1970-03-30" &gt;
   &lt;extension url="http://example.org/fhir/StructureDefinition/text"&gt;
     &lt;valueString value="Easter 1970"/&gt;     
   &lt;/extension&gt;
 &lt;/<b>dob</b>&gt;
</pre>
<p>в JSON представляется так:</p>
<pre class="json">
 "birthDate": "1972-11-30",
 "_birthDate": { 
   "id": "314159", 
   "extension" : [ {
      "url" : "http://example.org/fhir/StructureDefinition/text",
      "valueString" : "Easter 1970"
   }]
 }
</pre>
<p>Примечание: Если примитив имеет атрибут id или расширение, но не имеет value, то указывается только свойство со знаком "_".</p>
<p>
В случае, когда примитивный элемент может повторяться, это представляется двумя массивами. Для заполнения обоих массивов используется JSON-значение null,  чтобы привести в соответствие идентификатор и/или расширение с его значением в первом массиве, как продемонстрировано в этом примере:
</p>
<pre class="xml">
 &lt;<b>code</b> value="au"/&gt;
 &lt;<b>code</b> value="nz"&gt;
   &lt;extension url="http://hl7.org/fhir/StructureDefinition/display"&gt;
     &lt;valueString value="New Zealand a.k.a Kiwiland"/&gt;     
   &lt;/extension&gt;
 &lt;/<b>code</b>&gt;
</pre>
<p>в JSON представляется так:</p>
<pre class="json">
 "code": [ "au", "nz" ],
 "_code": [ 
   null, 
   { 
     "extension" : [ {
        "url" : "http://hl7.org/fhir/StructureDefinition/display",
      "valueString" : "New Zealand a.k.a Kiwiland"
     }]
   }
  ]
 }
</pre>
<p>Примечание: когда у одного из повторяющихся элементов нет значения (value), в первом массиве для него указывается значение null. Когда у элемента есть значение, но нет расширения/идентификатора, во втором массиве на месте этого элемента будет стоять null.</p>
<blockquote>
<p>
<b>Примечание разработчика</b>: Представление примитивных типов данных было разбито на две части с целью упрощения представления простых примитивных значений без идентификатора или расширений. Это действительно привело к издержкам, сделав представление атрибута id и расширений более неуклюжим, однако они оба редко используются с примитивными типами данных.
</p>
</blockquote>

<h3>JSON-представление элементов и сложных типов данных</h3>

<p>
Элементы и сложные <a href="datatypes.html">типы данных</a> (типы, содержащие именованные элементы других типов) представляются с помощью JSON-объекта, содержащего соответствующий элемент для каждого элемента в типе данных. Композиции могут иметь атрибуты id, которые преобразовываются в значения JSON-элементов объекта таким же способом, как описано для примитивов. Например:</p>
 <pre class="xml">
&lt;person&gt;
  &lt;text&gt;
    &lt;status value="generated" /&gt;
    &lt;div xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;p&gt;...&lt;/p&gt;&lt;/div&gt;
  &lt;/text&gt;
  &lt;name&gt;
    &lt;use value="official" /&gt;  
    &lt;given value="Karen" /&gt;
    &lt;family id="a2" value="Van" /&gt;
  &lt;/name&gt;
&lt;/person&gt;
</pre>
<p>в JSON представляется так:</p>
<pre class="json">
{
  "person" : {
    "name" : [{
      "use" : "official" ,
      "given" : [ "Karen" ],
      "family" : [ "Van" ]
      "_family" : [ {"id" : "a2"} ]
     }],
    "text" : {
      "status" : "generated" ,
      "div" : "&lt;div xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;p&gt;...&lt;/p&gt;&lt;/div&gt;"
    }
}
</pre>
<p>На что здесь необходимо обратить внимание:</p>
<ul>
<li>И given, и family являются повторяющимися XML-элементами, поэтому они сериализуются в Array вне зависимости от того, повторяются они в данном случае или нет.</li>
<li>В части family элемента 'name' атрибут 'id' представлен в _family способом, описанным выше.</li>
<li>XHTML-содержимое элемента 'div', который есть в Narrative-элементе 'text', представлено в виде экранированной строки в JSON-свойстве value. Корневым элементом в XHTML должен быть &lt;div&gt; в пространстве имен XHTML.</li>
</ul>

<h3>JSON-представление ресурсов</h3>
<p>
Ресурс – это JSON-объект со свойством "resourceType", который сообщает программе-анализатору, какой это тип ресурса:
</p>
<pre class="json">
{
  "resourceType" : "Patient",
  "text" : {
    "status" : "generated" ,
    "div" : "&lt;div xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;p&gt;...&lt;/p&gt;&lt;/div&gt;"
  }
  etc...
}
</pre>
<p>
Обратите внимание, что синтаксические анализаторы не могут полагаться на то, что свойство resourceType будет идти первым.
</p>
<blockquote>
<p>
<b>Примечание разработчика</b>: Это является проблемой для некоторых сериализаторов вида JSON -&gt; Object , которые предполагают, что свойство resourceType действительно идет первым, включая <a href="http://james.newtonking.com/json">Json.NET</a>. 
Однако некоторые JSON-генераторы не дают авторским приложениям управлять порядком значений свойств, поэтому эти реализации не могут взаимодействовать с реализациями, которые делают предположения о порядке. Учитывая, что JSON заявляет, что значения свойств являются неупорядоченной таблицей пар name/value, данная спецификация не может требовать, чтобы свойства шли в каком-то определенном порядке, хотя реализаторы могут зафиксировать порядок свойств, если у них есть такая возможность (и ссылочные платформы, предоставленные в этой спецификации, делают это).
</p>
</blockquote>

<p>
Для помощи в тестировании JSON-анализаторов приводится <a href="json-edge-cases.json">файл с примером</a>, демонстрирующим многие крайние случаи.
</p>

<a name="sig"> </a>
<h4>Цифровые подписи</h4>
<p>
<i>todo</i>
</p>

</div>

[%file newfooter%]
</body>
</html>