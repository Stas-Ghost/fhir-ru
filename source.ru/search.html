<!DOCTYPE HTML>


[%settitle Search (RESTful API) %]
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
[%file newheader%]
</head>
<body>
[%file newnavbar%]

<div class="col-9">

<a name="base"> </a>
<h2>Поиск</h2>

<p>
Один из основополагающих аспектов в работе FHIR - это механизм поиска набора ресурсов. Операции поиска ищут в существующем наборе ресурсов в соответствии с критериями поиска, переданными в качестве параметров механизму поиска. На этой странице задокументирована система поиска FHIR от простых примеров до самых сложных случаев. Реализациям требуется внедрить только ту степень сложности, которая им необходима.
</p>

<h3>Сводная таблица</h3>

<table class="grid">
<tr><td><b>Типы параметров поиска</b></td><td><b>Параметры для всех ресурсов</b></td><td><b>Параметры результатов поиска</b></td></tr>
<tr>
<td>
<%codetoc SearchParamType%>
</td>
<td>
<a href="#id">_id</a><br/>
<a href="#language">_language</a><br/>
<a href="#lastUpdated">_lastUpdated</a><br/>
<a href="#profile">_profile</a><br/>
<a href="#security">_security</a><br/>
<a href="#tag">_tag</a><br/>
<a href="#text">_text</a><br/>
<a href="#filter">_filter</a><br/>
</td>
<td>
<a href="#sort">_sort</a><br/>
<a href="#count">_count</a><br/>
<a href="#include">_include</a><br/>
<a href="#revinclude">_revinclude</a><br/>
<a href="#summary">_summary</a><br/>
<a href="#contained">_contained</a><br/>
<a href="#containedType">_containedType</a><br/>
</td>
</tr>
</table>

<h3>Введение</h3>
<p>
В простейшем случае поиск выполняется операцией GET в RESTful-системе:
</p>
<pre>
 GET [base]/[resourcetype]?name=value&amp;...
</pre>
<p> 
Для такого RESTful-поиска (см. <a href="http.html#search">определение в RESTful API</a>) параметры представляют собой последовательность пар вида имя=[значение] (name=[value]), кодированных в URL [процентная кодировка] или в формате application/x-www-form-urlencoded для [запроса] POST. Сервер возвращает результаты в HTTP-ответе в виде <a href="bundle.html">bundle</a>, который включает в себя ресурсы, являющиеся результатами этого поиска. Сервер также может включить в набор результатов дополнительные ресурсы, например <a href="operationoutcome.html">OperationOutcome</a>. Клиентам следует игнорировать ресурсы, не соответствующие ожидаемому типу. Код HTTP-статуса 403 означает отказ сервера выполнять поиск, тогда как некоторые другие коды вида 4xx или 5xx сигнализируют о том, что произошла какая-то ошибка. 
</p>
<p>
<a href="http.html#search">Операции поиска</a> исполняются в одном из трех заданных контекстов, определяющих, в каком наборе ресурсов будет осуществляться поиск:
</p>
<ul>
 <li>Определенный тип ресурса: GET [base]/[ResourceType]?parameter(s)</li>
 <li>Определенный <a href="extras.html#compartments">модуль</a>, возможно с указанием типа ресурса в этом модуле: GET [[base]/patient/[id]/[ResourceType]?parameter(s)</li>
 <li>Все ресурсы: GET [base]/_search?parameter(s) (только параметры, общие для всех типов)</li>
</ul>
<p>
Операции поиска также могут инициироваться другими, более сложными и гибкими методами, описанными ниже, которые модифицируют и способ запуска поиска, и возвращаемые результаты. 
</p>
<a name="standard"> </a>
<h3>Стандартные параметры</h3>

<a name="all"> </a>
<h4>Параметры для всех ресурсов</h4>
<p>
Эти параметры <a href="resource.html#search">описаны здесь</a> и применяются ко всем ресурсам: [%allparams%]. Кроме того, параметры поиска  <a href="#text">_text</a> и <a href="#filter">_filter</a>, (задокументированы ниже) также применяются ко всем ресурсом (как и параметры результатов поиска). 
</p>
<a name="id"> </a>
<p>
Параметр поиска _id относится к логическому id ресурса и может быть использован, когда в качестве контекста поиска указан тип ресурса:
</p>
<pre>
 GET [base]/Patient?_id=23
</pre>
<p>
В этом примере поиска ищется ресурс patient с указанным id (может быть только один ресурс с таким id). С функциональной точки зрения это эквивалентно <a href="http.html#read">простой операции чтения</a>:
</p>
<pre>
 GET [base]/Patient/23
</pre>
<p>
за исключением того, что он возвращает комплект с требуемым ресурсом, а не сам ресурс. Могут быть добавлены дополнительные параметры, которые  предоставят дополнительную функциональность к этой базовой, эквивалентной чтению.
</p>
<a name="language"> </a>
<p>
Параметр поиска _language относится к основному языку ресурса:
</p>
<pre>
 GET [base]/Composition?_language=fr
</pre>
<p>
В этом примере поиска ищутся все ресурсы Composition с обозначенным языком French.
Обратите внимание, что это заявленный язык ресурса, а не фактический язык его содержимого.
</p>
<a name="lastUpdated"> </a>
<p>
Параметр поиска _lastUpdated может использоваться для выбора ресурсов по дате их последнего изменения:
</p>
<pre>
 GET [base]/Observation?_lastUpdated=>2010-10-01
</pre>
<p>
В этом примере поиска ищутся все Observations, измененные после 1-Окт 2010. При использовании этого параметра поиска приложениям следует принимать во внимание подходы к синхронизации (<a href="http.html#history">RESTful история</a>
или <a href="subscription.html">ресурс Subscription</a>.
</p>
<a name="tag"> </a>
<a name="tags"> </a>
<a name="profile"> </a>

<p>
Параметры поиска _tag, _profile и _security ищут по соответствующим элементам в <a href="resource.html#meta">элементе meta</a>.
Например
</p>
<pre>
 GET [base]/Condition?_tag=http://acme.org/codes|needs-review
</pre>
<p>
ищет все ресурсы Condition с тегом:
</p>
<pre class="json">
{
  "system" : "http://acme.org/codes", 
  "code" : "needs-review"
}
</pre>
<p>
Таким же образом:
</p>
<pre>
 GET [base]/DiagnosticReport?_profile=http://hl7.org/fhir/StructureDefinition/lipid
 GET [base]/DiagnosticReport?_profile=Profile/lipid
</pre>
<p>
ограничивает поиск только ресурсами DiagnosticReport с тегом, что они согласуются с определенным профилем. Вторая ссылка относительная и ссылается на локальный профиль на том же сервере.
</p>
<p>
Параметры _tag, _profile и _security имеют тип токен (см. <a href="#token">ниже</a>).
</p>


<h4>Указание параметров для каждого ресурса</h4>
<p>
Кроме параметра _id, который применяется ко всем ресурсам, каждый тип FHIR-ресурса определяет свой собственный набор параметров поиска по именам, типам и значениям. Эти параметры поиска можно найти на той же самой странице, где и определения ресурса, также они опубликованы как часть стандартного заявления о соответствии (<a href="conformance-base.xml.html">XML</a> и <a href="conformance-base.json.html">JSON</a>).
</p>
<p>
Обычно, заданные параметры поиска соответствуют одному элементу в ресурсе, однако это не является обязательным, и некоторые параметры поиска относятся к одному типу элемента в нескольких местах или относятся к их значениям.
</p>
<p>
Некоторые из параметров поиска, заданные ресурсами, ассоциируются с более чем одним путем в ресурсе. Это означает, что этот параметр поиска соответствует, если любой из путей содержит совпадающее содержимое, и который из путей соответствует, ресурс целиком возвращается в результатах поиска. Клиент может потребоваться проверить ресурс, чтобы определить, который из путей содержит совпадение.
</p>
<p>
Серверам не обязательно реализовывать ни один из этих параметров поиска (за исключением параметра _id, описанного выше), и они могут определять свои собственные дополнительные параметры, если хотят. 
</p>

<a name="ptypes" />
<h4>Типы параметров поиска</h4>
<p>Каждый параметр поиска указывается с типом, которые определяет способ поведения параметра поиска. Далее следуют определения типов параметров:
</p>
<%linkcodelist SearchParamType%>
<p>
Эти параметры поиска также могут иметь "модификаторы", добавленные к ним, которые управляют их поведением. Виды модификаторов, которые могут использоваться, зависят от типа параметра. 
</p>

<a name="modifiers" />
<h4>Модификаторы</h4>
<p>Параметры определены для каждого ресурса, и их имена могут дополнительно указывать модификатор в качестве суффикса, отделенного от имени параметра двоеточием. Модификаторами являются:</p>
<ul>
 <li>Для всех параметров (кроме комбинации): ":missing". Например gender:missing=true (or false). Поиск по "gender:missing=true" вернет все ресурсы, которые не имеют никакого значения параметра gender (что, как правило, приравнивается к отсутствию соответствующего элемента в ресурсе). Поиск по "gender:missing=false" вернет все ресурсы, имеющие значение параметра "gender".</li>
 <li>Для строки: ":exact" (совпадение должно быть точным, не частичным совпадением, чувствительным к регистру и диакритическим знакам), вместо поведения по умолчанию, когда допускается частичное совпадение. Решение о том, выполнять ли левый частичный поиск, остается на усмотрение сервера.</li>
 <li>Для лексемы (token): ":text" (совпадение совершает частичные поиски по части text в CodeableConcept или 
части display в Coding), вместо поиска по умолчанию, который использует коды. Other define modifiers are ":in", ":below", ":above", ":in" and ":not-in" which are described below</li>
 <li>Для ссылки: ":[type]", где [type] - это имя типа ресурса.</li>
 <li>Для uri: ":below", ":above" означают, что вместо точного совпадения либо search term left соответствует значению, либо наоборот</li>
</ul>

<a name="number" />
<h4>number</h4>
<p>
В значение параметра могут использоваться префиксы &gt;, &gt;=, &lt;= и &lt; в своем обычном значении (note that "=" must be <a href="http://en.wikipedia.org/wiki/Percent-encoding">URL-encoded</a> in the 
value in a URL). Примеры:
</p>
<table class="grid">
 <tr><td>[parameter]=100</td><td>Значения, равные 100 с точностью до 2 значимых знаков, таким образом диапазон [99.5 ... 100.5)</td></tr>
 <tr><td>[parameter]=100.00</td><td>Значения, равные 100 с точностью до 4 значимых знаков, таким образом диапазон [99.995 ... 100.005). Целые числа также равны 100.00, но не 100.01</td></tr>
 <tr><td>[parameter]=&lt;100</td><td>Значения, которые меньше 100</td></tr>
 <tr><td>[parameter]=&lt;=100</td><td>Значения, которые меньше или равны 100</td></tr>
 <tr><td>[parameter]=&gt;100</td><td>Значения, которые больше 100</td></tr>
 <tr><td>[parameter]=&gt;=100</td><td>Значения, которые больше или равны 100</td></tr>
 <tr><td>[parameter]=!=100</td><td>Values that are not equal to 100. Precision works as for equals (this operation is the logical converse of equals)</td></tr>
</table>
<p>
Для сравнений, включающих &lt; или &gt;, неточность не играет роли, и точность чисел полагается произвольно высокой. Следует отметить, что то, как эти параметры поиска работают здесь, отличается от того, являются ли два числа равными друг другу в математическом смысле.
</p>

<a name="date" />
<h4>date</h4>
<p>
Параметр даты ищет по дате/времени или периоду. Префиксы &gt;, &gt;=, &lt;= и &lt; могут использоваться со значением параметра в своем обычном значении. Однако, как это обычно для связанной с датой/временем функциональности, хотя эти понятия и относительно простые, имеется целый ряд тонкостей, связанных с обеспечением согласованного поведения.
</p>
<ul>
 <li>Формат параметра даты yyyy-mm-ddThh:nn:ss(TZ) (стандартный XML-формат). 
   <ul>
     <li>Технически это любой из типов данных <a href="datatypes.html#date">date</a>, <a href="datatypes.html#dateTime">dateTime</a> и <a href="datatypes.html#instant">instant</a> data types</li>
     <li>например любая степень точности может быть приведена, однако это ДОЛЖНО быть заполнено слева (например нельзя указать месяц без года), за исключением того, что минуты ДОЛЖНЫ присутствовать, если указан час, и вы ДОЛЖНЫ указать часовой пояс, если присутствует время</li>
     <li>Некоторые пользовательские агенты могут экранировать символы ":" в URL, и серверы ДОЛЖНЫ корректно обрабатывать это</li>
   </ul>
 </li>
 <li>[parameter]=[date] ищет ресурсы, где дата соответствует периоду, подразумеваемому данным значением в [date] . "[parameter]=&gt;[date]" [date]" ищет все ресурсы, где указанная дата больше [date]. "[parameter]=&lt;=[date]" =[date]" ищет все ресурсы, где указанная дата равна или меньше [date], и т. д. </li>
 <li>Элемент, к которому относится поиск, может иметь тип данных <a href="datatypes.html#date">date</a>, 
 <a href="datatypes.html#dateTime">dateTime</a>, <a href="datatypes.html#instant">instant</a>, 
 <a href="datatypes.html#Period">Period</a> или <a href="datatypes.html#Schedule">Schedule</a>. 
 Все эти типы, связанные со временем, в действительности задают интервал времени, как, собственно, и сам параметр поиска.
  <ul>
    <li>Для типов Period и Schedule тот факт, что они относятся к интервалу времени, является явным (однако верхняя или нижняя граница может не быть фактически указана в ресурсах)</li>
 	<li>Для типов date и dateTime (и параметра поиска) интервал не выражен явно. Например дата 2013-01-10 указывает на все время от 00:00 10-Jan 2013 до, непосредственно, 00:00 on 11-Jan 2013.</li>
    <li>instant (что то же самое, что и полностью указанная dateTime с миллисекундами) полагается фиксированной точкой во времени с интервалом меньшим, чем точность системы, т. е. интервалом с рабочей шириной 0.</li>
   </ul>
 </li>
 <li>Поиски по параметру даты всегда находят совпадения на основе поведения интервалов, как изложено ниже:
   <ul>
     <li>Для [parameter]=[date] требование состоит в том, что интервал поиска полностью содержит время цели, т. е.  [parameter]=2013-01-14 включает в себя 2013-01-14T00:00 (что очевидно) и также 2013-01-14T10:00, однако не 2013-01-15T00:00</li>
     <li>Для [parameter]=!=[date], требование состоит в том, что интервал поиска не содержит целевое время полностью, т. е. [parameter]=!=2013-01-14 включает в себя 2013-01-15T00:00, но не 2013-01-14T00:00 или 2013-01-14T10:00</li>


	 <li>Для "[parameter]=&lt;[date]" требование состоит в том, что интервал времени до [date] пересекается (т. е. накладывается) с интервалом времени в соответствующем элементе ресурса. Например время ресурса 2013-01-14 включается в набор значений, которые идут ранее 2013-01-14T10:00, потому что он включает часть 14-Jan 2013 до 10am</li>
	 <li>Для "[parameter]=&gt;[date]" требование состоит в том, что интервал времени после [date] пересекается (т. е. накладывается) с интервалом времени в соответствующем элементе ресурса. Например время ресурса 2013-01-14 включено в набор значений, которые идут после 2013-01-14T10:00, потому что он включает часть 14-Jan 2013 после 10am</li>
   </ul>
   Неявно, опущенная нижняя граница "меньше чем" любая фактическая дата. Опущенная верхняя граница "больше чем" любая фактическая дата. Например, период от 21-Jan 2013 и далее включен в совпадения для date=&gt;=2013-03-14, потому что он может включать время после 14-Mar 2013.
 </li>
 <li>Таким же образом, когда параметр даты указан не полностью, совпадения с ним основываются на свойстве интервалов, где:
	<ul>
		<li>Даты, где указан только год, эквивалентны интервалу, который начинается в первое мгновение 1го января до последнего мгновения 31го декабря, например 2000 эквивалентно интервалу [2000-01-01T00:00, 2000-12-31T23:59]</li>
		<li>Даты, где указан год и месяц, эквивалентны интервалу, который начинается в первое мгновение первого дня месяца и заканчивается в последнее мгновение последнего дня месяца, например 2000-04 эквивалентно интервалу [2000-04-01T00:00, 2000-04-30T23:59]</li>
	</ul>
 </li>
 <li>Где это возможно, система должна корректировать часовые пояса при совершении запросов. Даты не имеют часовых поясов, и часовые пояса не должны учитываться. Там, где и параметр поиска, и дата время элемента ресурса не имеют часового пояса, им следует присваивать локальный часовой пояс сервера.
 </li>
 <li>
   Обратите внимание, что для типа данных Schedule указанные подробности расписания игнорируются и только внешние лимиты имеют значение. К примеру расписание, которое определяет каждый второй день между 31-Jan 2013 и 24-Mar 2013, включает в себя 1-Feb 2013, хотя это будет и нечетный день, который не соответствует расписанию. Это делается для того, чтобы сохранить загрузку обрабатывающего запросы сервера разумной.
 </li>
</ul>
<p>
В качестве примера следующий поиск ищет все процедуры в модуле patient, которые произошли за двухлетний период:
</p>
<pre>
 GET [base]/Patient/23/Procedure?date=&gt;2010-01-01&amp;date=&lt;2011-12-31
</pre>


<a name="string" />
<h4>string</h4>
<p>
Строковый параметр относится к простому строковому поиску в последовательностях символов. Совпадения являются нечувствительными к регистру и диакритическим знакам. По умолчанию совпадение существует, если часть значения параметра содержит указанную строку. Решение о том, выполнять ли левый частичный поиск, остается на усмотрение сервера. Модификатор :exact можно использовать для указания, что совпадение должно быть точным (целая строка, включая регистр и диакритические знаки). Например:
</p>
<pre>
 GET [base]/Patient?name=eve
 GET [base]/Patient?name:exact=Eve
</pre>
<p>
 Первое - это запрос на поиск всех пациентов с "eve" в любой части имени. Результат будет включать в себя пациентов с именами "Eve", "Severine" и пр. Второй поиск вернет только пациентов с именем "Eve".
</p>
<p>
 Дополнительный модификатор :text можно использовать для указания поиска с продвинутым управлением текста  (см. <a href="#text">ниже</a>), однако такую возможность предлагает небольшое количество серверов.
</p>
<p>
Решение о том, делать ли предварительную обработку имен, адресов и контактной информации для удаления символов-разделителей до нахождения соответствия, чтобы гарантировать непротиворечивое поведение, остается на усмотрение сервера. Например сервер мог бы удалить все пробелы и символы "-" из телефонных номеров. Что лучше всего подходит, варьируется в зависимости от культуры и контекста.
</p>


<a name="uri" />
<h4>uri</h4>
<p>
Параметр URI относится к элементу, который является URI (<a href="https://tools.ietf.org/html/rfc3986">RFC 3986</a>). Совпадения являются точными (например чувствительность к регистру, диакритическим знакам, экранированию), и весь URI целиком должен совпадать. Могут быть использованы модификаторы :above или :below для указания левостороннего совпадения. Например:
<!-- The uri parameter refers to an element which is URI (<a href="https://tools.ietf.org/html/rfc3986">RFC 3986</a>).
Matches are precise (e.g. case, accent, and escape) sensitive, and the entire URI must match. 
The modifier :above or :below can be used to indicate
that the match is based on left. For example: -->
</p>
<pre>
 GET [base]/ValueSet?url=http://acme.org/fhir/ValueSet/123
 GET [base]/ValueSet?url:below=http://acme.org/fhir/
</pre>
<p>
Первый запрос для поиска любого набора значений с точным URL "http://acme.org/fhir/ValueSet/123". 
Второй поиск вернет любые наборы значений, у которых URL начинается с "http://acme.org/fhir/".
Обратное утверждение - поиск любого набора значений, кроме данного конкретного URL - может быть полезным для поиска name systems, но это, как правило, менее полезно, чем поиск с параметром :below.
<!-- The first is a request to find any value set with the exact url "http://acme.org/fhir/ValueSet/123". 
The second search will return any value sets that have a URL that starts with "http://acme.org/fhir/".
The converse - the search for any value set above a given specific URL - may be useful for searching
name systems, but it is generally less useful than the :below search.  -->
</p>

<a name="token" />
<h4>token</h4>
<p>
Тип токен - это параметр, который ищет по значению кода или идентификатора, где это значение может иметь URI, который ограничивает свое значение (типы <a href="datatypes.html#Coding">Coding</a>, 
<a href="datatypes.html#CodeableConcept">CodeableConcept</a> и <a href="datatypes.html#Identifier">Identifier</a>, а также <a href="datatypes.html#code">code</a>, где URI не выражен явно, или для boolean).
</p>
<p>
Если у параметра нет модификатора, поиск осуществляется по URI/value из Кодинга или Идентификатора. Синтаксис для этого значения один из следующих:
</p>
<ul>
 <li><b>[parameter]=[code]</b>: значение [code] совпадает с Coding.code или Identifier.value не зависимо от значения свойства "system"</li>
 <li><b>[parameter]=[system]|[code]</b>: значение [code] совпадает с Coding.code или Identifier.value, а значение [system] совпадает со значением свойства "system" в Identifier или Coding</li>
 <li><b>[parameter]=|[code]</b>: значение [code] совпадает с Coding.code или Identifier.value, а Coding/Identifier не содержит свойства "system" </li>
</ul>
<p>
Обратите внимание, что URI пространства имен и код необходимо <a href="#escaping">экранировать</a>. Совпадения должны быть буквальными (т.е. не должны основываться на отнесении к какой-либо категории или других характеристиках кодовых систем), но не должны зависеть от регистра.
</p>
<p><b>Модификаторы:</b></p>
<table class="lines">
 <tr> <td><b>Модификатор</b></td> <td><b>Использование</b></td> </tr>
 <tr> <td>:text</td> <td>этот параметр поиска обрабатывается как строка поиска по тексту, ассоциированному с кодом/значением - либо <i>CodeableConcept.text</i>, <i>Coding.display</i>, либо <i>Identifier.type.text</i></td> </tr>
 <tr> <td>:not</td> <td>изменяет на противоположное совпадение по коду, описанное в параграфе выше</td> </tr>
 <tr> <td>:above</td> <td>параметром поиска является концепт с формой [system]|[code], и он проверяет, включает ли кодинг в ресурсе указанный в поиске код (например поисковый концепт имеет связь "is-a" с кодингом в ресурсе, и сюда входит сам кодинг)</td> </tr>
 <tr> <td>:below</td> <td>параметром поиска является концепт с формой [system]|[code], и он проверяет, относится ли кодинг в ресурсе к указанному в поиске коду (например кодинг в ресурсе имеет связь "is-a" с поисковым концептом, и сюда входит сам кодинг)</td> </tr>
 <tr> <td>:in</td> <td>параметром поиска является URI (относительный или абсолютный), который идентифицирует набор значений, и поисковый параметр проверяет, входит ли кодинг в указанный  <a href="valueset.html">набор значений</a>. Ссылка может быть буквальной (адрес, где нахоидтся этот набор значений) или логической (ссылка на ValueSet.identifier)</td> </tr>
 <tr> <td>:not-in</td> <td>параметром поиска является URI (относительный или абсолютный), который идентифицирует набор значений, и поисковый параметр проверяет, что кодинг не входит в указанный набор значений</td> </tr>
</table>
<p>
Большинство серверов будут обрабатывать только уже известные/зарегистрированные/поддерживаемые внутри наборы значений, но могут принимать любые валидные ссылки на наборы значений.
Серверы могут учитывать таблицы соответствий концептов при проверке связей категоризации (отнесения объекта к определённой категории).
</p>

<p>
Вот несколько примеров поиска:
</p>
<table>
 <tr><td width="50%"><b>Поисковый запрос</b></td><td><b>Описание</b></td></tr>
 <tr><td><pre> GET [base]/Patient?identifier=http://acme.org/patient|2345</pre></td><td>Ищет всех пациентов с идентификатором с ключом = "2345" в системе "http://acme.org/patient"</td></tr>
 <tr><td><pre> GET [base]/Patient?gender=male</pre></td><td>Ищет всех пациентов с полем gender, имеющим код "male", вне зависимости от системы. Заметим, что это, как правило, не очень полезно - системы обычно определяют символы, где перекрытия являются случайными и не информативными</td></tr>
 <tr><td><pre> GET [base]/Patient?gender=http://hl7.org/fhir/v2/0001|M</pre></td><td>Ищет всех пациентов с полем gender, которое закодированым значением "M" из таблицы HL7 Administrative Gender</td></tr>
 <tr><td><pre> GET [base]/Patient?gender:text=male</pre></td><td>Ищет всех пациентов с полем gender, содержащим текст "male", ассоциированный с ним (примечание: результат будет включать и значение "female")</td></tr>
 <tr><td><pre> GET [base]/Patient?active=true</pre></td><td>Search for any patients that are active</td></tr>
</table>

<p>
Note about the use of token search parameters for boolean fields: the boolean values 'true' and 'false' are also represented
as formal codes in the <a href="special-values.html">Special Values</a> code system, which is useful when boolean values 
need to be represented in a <a href="datatypes.html#coding">Coding</a> data type. The namespace for these codes is 
http://hl7.org/fhir/special-values, though there is usually no reason to use this, as a simple true or false is sufficient.
</p>

<a name="quantity" />
<h4>quantity</h4>
<p>
Параметр величины ищет по типу данных <a href="datatypes.html#Quantity">Quantity</a>. Синтаксис для значения соответствует следующей форме:
</p>
<ul>
 <li><b>[parameter]=[comparator][number]|[system]|[code]</b> соответствует количеству с заданными единицами измерения</li>
</ul>
<p>
Компаратор является необязательным; если не указан, по умолчанию компаратором является "=". Специальное значение "~" может использоваться как символ приближения. Примеры поисков:
</p>

<table>
 <tr><td width="50%"><b>Поисковый запрос</b></td><td><b>Описание</b></td></tr>
 <tr><td><pre> GET [base]/Observation?value=5.4|http://unitsofmeasure.org|mg</pre></td><td>Находит все результаты обследований со значением 5.4 mg, где mg понимается как UCUM-единица измерения (система/код)</td></tr>
 <tr><td><pre> GET [base]/Observation?value=5.4||mg</pre></td><td>Находит все результаты обследований со значением 5.4 mg, где единицей измерений - либо код, либо официально утверждённая человеческая единица измерения - является "mg"</td></tr>
 <tr><td><pre> GET [base]/Observation?value=&lt;5.4|http://unitsofmeasure.org|mg</pre></td><td>Находит все результаты обследований, в которых значение меньше, чем 5.4 mg, где mg понимается как UCUM-единица измерения</td></tr>
 <tr><td><pre> GET [base]/Observation?value=~5.4|http://unitsofmeasure.org|mg</pre></td><td>Находит все результаты обследований со значением около 5.4 mg, где mg понимается как UCUM-единица измерения. Рекомендованное значение приближения 10% от установленного значения, однако системы могут выбирать другие значения, где это необходимо</td></tr>
</table>

<p>
Поисковый процессор может решить выполнить поиск, основанный на <a href="datatypes.html#quantity">канонических единицах измерений</a> (например любое значение, которое может быть преобразовано в значение в миллиграммах, для случая выше)
</p>


<a name="chaining" />
<a name="reference" />
<h4>reference</h4>
<p>
Ссылочный параметр относится к <a href="references.html">ссылкам между ресурсами</a>, например найти все Conditions, где объектом ссылки является определенный пациент, где пациент выбирается по имени или идентификатору. Интерпретация параметра <i>ссылка</i> одна из двух: 
</p>
<ul>
 <li><b>[parameter]=[id]</b> логический [id] ресурса, имеющего локальную ссылку (т. е. относительную ссылку) </li>
 <li><b>[parameter]=[url]</b> где [url] - это абсолютный URL-адрес  - ссылка на ресурс по его абсолютному местоположению</li>
</ul>
<p>
Обратите внимание, что если относительная ссылка разрешается тем же значением, что и указанный абсолютный URL-адрес, либо наоборот, это также считается совпадением.
</p>
<p>
У некоторых ссылок есть возможность указывать на более чем один тип ресурса, например объект : Reference(Patient|Group|Device|..). В таких случаях несколько различных ресурсов могут иметь один и тот же логический идентификатор. В этом случае клиент может указать модификатор типа после имени параметра, чтобы явно задать желаемый тип:
</p>
<pre>
 GET [base]/Condition?subject:Patient=23
</pre>
<p>
Этот запрос ищет все условия (conditions), в которых объект ссылается на ресурс patient с логическим идентификатором "23". Сервер ДОЛЖЕН отклонить поиск, в котором логический идентификатор ссылается на более чем один совпадающий ресурс среди нескольких типов. Следует отметить, что модификатор :[type]  не может быть использован со ссылкой на ресурс, находящийся на другом сервере, т. к. сервер не будет знать, какой тип имеет этот ресурс (но т. к. это абсолютные ссылки, то двусмысленность относительно типа отсутствует).
</p>

<h4>Цепочечные параметры (Chained parameters)</h4>
<p>
Чтобы избавить клиента от необходимости выполнять серию операций поиска, ссылочные параметры могут быть "сцеплены" (объединены в последовательность) добавлением к ним точки (.), за которой следует имя параметра поиска, указанного для целевого ресурса. Это может быть сделано рекурсивно, следуя логическому пути через граф связанных ресурсов, разделенных точкой ".". К примеру дано, что ресурс <a href="diagnosticreport.html">DiagnosticReport</a> 
имеет параметр поиска с именем <i>subject</i>, который обычно является ссылкой на ресурс <a href="patient.html">Patient</a>, и этот ресурс Patient содержит параметр <i>name</i>, который ищет по имени пациента, тогда поиск вида
</p>
<pre>
 GET [base]/DiagnosticReport?subject.name=peter
</pre>
<p>
- это запрос на возвращение всех лабораторных отчетов, в которых имеется объект, чье имя содержит "peter". Так как  объект Diagnostic Report может быть одним из набора различных ресурсов, имеется возможность ограничить поиск определенным типом:
</p>
<pre>
 GET [base]/DiagnosticReport?subject:Patient.name=peter
</pre>
<p>
Это запрос на возвращение всех лабораторных отчетов, имеющих в качестве объекта пациента, чье имя содержит "peter".
</p>

<p>
Примечание к продвинутому поиску: Там, где цепочечный параметр ищет ссылку на ресурс, который может иметь более одного ресурса различного типа в качестве цели, цепочка параметров может заканчиваться ссылкой на параметры поиска с тем же именем на более чем один вид ресурса одновременно. Имена параметров, установленные в FHIR, имеют непротиворечивые типы, где бы они не использовались. Разработчикам, вводящим свои собственные названия, необходимо удостовериться, что они не создают комбинации, которые будет невозможно обработать. Серверам СЛЕДУЕТ отклонять цепочечные запросы, которые ведут к нарушению структуры типов наряду с путем (например клиент должен явно указать тип с помощью синтаксиса во втором примере выше). 
</p>

<a name="composite" />
<a name="combining" />
<h3>Комбинированные параметры поиска</h3>
<p>
Результатом операции поиска является пересечение ресурсов, которые соответствуют критериям, указанным в каждом отдельном параметре поиска. Если параметр повторяется, например /patient?language=FR&amp;language=NL, тогда это соответствует пациенту, который говорит на обоих языках. Это называется параметром поиска И (AND), так как от сервера ожидается ответ с результатами, которые соответствуют обоим значениям.
</p>
<p>
Если, наоборот, поиск ищет пациентов, которые говорят на одном из этих языков, тогда это будет один параметр с несколькими значениями, разделенными запятой ','. 
Например: "/patient?language=FR,NL". Это называется параметром поиска ИЛИ (OR), так как от сервера ожидается ответ с результатами, которые соответствуют одному из значений.
</p>
<p>
AND-параметры и OR-параметры можно комбинировать, например: 
"/patient?language=FR,NL&amp;language=EN" будет относиться к любому пациенту, который говорит на 
английском, а также французском или голландском языках.
</p>
<p>
Это позволяет использовать простые комбинации and/or значений, однако не позволяет поиски, основанные на паре значений, такие как все обследования со значением натрия >150 mmol/L  (в особенности как конечный критерий цепочечного поиска), или поиск по Group.characteristic: вам необходимо найти комбинацию ключ/значение, а не пересечение отдельных совпадений по ключу и значению. Другой пример - это пространственные координаты в географических поисках.
</p>
<p>
Для осуществления этих поисков ресурс может также указать <i>комбинированные</i> параметры, которые принимают последовательность отдельных значений, которые соответствуют другим определенным параметрам в качестве аргумента. Совпадающий параметр каждого компонента в такой последовательности задокументирован в определении этого параметра. Эти последовательности формируются присоединением отдельных значений через символ "$". Обратите внимание, что эта последовательность является отдельным значением и сама может входить в состав набора значений для того чтобы, например, несколько совпадающих параметров state-on-date могли быть указаны наподобие state-on-date=new$2013-05-04,active$2013-05-05.
</p>
<p>
В комбинированных параметрах модификаторы не используются.
<!--
Future note: use \p and \m in search values? if we add a double = to parameter value for text, that would get rid 
of :exact. 
Won't try to get rid of type modifier - that's the real use for modifiers because it has to be in a chaining line. 
Other modifier is :text on token - use "~"? or ""?
-->
</p>

<a name="escaping" />
<h4>Экранирование параметров поиска</h4>
<p>
В правилах выше особые правила определены для символов "$", ",", и "|". Как следствие, если эти символы встречаются в самом значении параметра, они должны отличаться от их использования в качестве разделительных символов. Когда любой из этих символов входит непосредственно в значение параметра, перед ним необходимо добавлять символ "\" (который также должен быть использован для экранирования самого себя). Таким образом 
"param=xxx$xxx" означает комбинированный параметр, в то время как "param=xx\$xx" означает, что этот параметр имеет буквальное значение 'xx$xx'. Значение параметра "xx\xx" является недопустимым, а значение параметра "param=xx\\xx" означает буквальное значение 'xx\xx'.
</p>


<a name="text"> </a>
<h4>Текстовые параметры поиска</h4>
<p>
Имеется два особых параметра текстового поиска, _text and _content, которые ищут по описательной части ресурса и по всему содержимому ресурса соответственно. Эти параметры ДОЛЖНЫ поддерживать тип функциональности продвинутого поиска, предлагаемый типовыми службами индексирования текста, ??? уместно (подходяще). Значением параметра является текстовый поиск, который может включать поиск нескольких слов  по словарю и соображениям близости, и такие логические операции, как AND, OR и т. п. Например:
</p>
<pre>
 GET [base]/Condition?_text=(bone OR liver) and metastases
</pre>
<p>
 Запрос ищет все ресурсы Condition со словами "metastases" и либо "bone", либо "liver" в описательной части. Сервер МОЖЕТ также выбрать поиск по связанным словам.
</p>
<a name="dstu"> </a>
<blockquote>
<p><b>Примечание DSTU</b>: Не все вопросы стандартизации текстового поиска решены. Во время пробного периода использования данной спецификации мы рекомендуем системам использовать правила, описанные в <a href="http://docs.oasis-open.org/odata/odata/v4.0/cs01/part1-protocol/odata-v4.0-cs01-part1-protocol.html#_The_$search_System">
a forth coming release of the OData specification for the $search parameter</a>.
Типовые разработки будут использовать Lucene - полнотекстовый поиск на основе sql-запросов, либо некоторую службу индексирования. Обратную связь о непротиворечивости реализации в этой области можно только приветствовать.
</p>
</blockquote>

<a name="filter"> </a>
<a name="_filter"> </a>
<h4>Расширенные возможности фильтрации</h4>

<p>
Поисковый механизм, описанный выше, гибкий и легко осуществимый для простых случаев, однако он ограничен в своей способности выражать комбинированные запросы. В дополнение к этому механизму может быть использован особый параметр поискового выражения "_filter".
</p>
<p>
Например такой умеренно простой поиск: найти все результаты обследований пациента с именем, содержащим "peter", которые имеют LOINC-код 1234-5:
</p>
<pre>
GET [base]/Observation?name=http://loinc.org|1234-5&amp;subject.name=peter
</pre>
<p>
С использованием параметра _filter поиск будет выражаться следующим образом:
</p>
<pre>
GET [base]/Observation?_filter=name eq http://loinc.org|1234-5 and subject.name co "peter"
</pre>
<p>
Параметр _filter подробно описан на странице <a href="search_filter.html">"Параметр _Filter"</a>.
</p>

<a name="return"> </a>
<h3>Управление возвращаемыми ресурсами</h3>

<a name="sort" />
<h4>Сортировка</h4>
<p>
Клиент может указать порядок возвращения результатов с помощью параметра "_sort", который может иметь значением одного из параметров поиска. Параметр _sort может повторяться для указания порядка сортировки с повторением, указывающим более низкий приоритет сортировки последовательно. 
</p>
<p>
Параметр _sort принимает один из двух спецификаторов, ":asc" and ":desc", который указывает возрастающий или убывающий порядок сортировки, соответственно. Значением по умолчанию является ":asc".
</p>
<p>
Примечания:
</p>
<ul>
 <li>При сортировке фактическое значение, используемое для сортировки, не выводится явно сервером для каждого ресурса, только содержимое ресурса</li>
 <li>Для сортировки по релевантности используйте "_sort:asc=_score"</li>
 <li>Сервер возвращает сортировку, которую он совершает как часть возвращаемых параметров поиска (см. <a href="#conformance">ниже</a>)</li>
 <li>Параметр поиска может относиться к элементу, который повторяется, и следовательно могут быть несколько значения для данного параметра поиска для одного ресурса. В таком случае сортировка основывается на элементе в наборе нескольких параметров, которые идут раньше всех в указанном порядке сортировки во время упорядочения возвращаемых ресурсов.</li> 
</ul>

<a name="count"> </a>
<h4>Количество страниц</h4>

<p>
С целью поддержания загрузки на клиентах, серверах и сети минимизированной, сервер может решить возвращать результаты в виде серии страниц. Набор результатов поиска содержит URL-адреса, которые клиент использует для запроса дополнительных страниц из поискового набора. Для простого RESTful-поиска ссылки на страницы 
<a href="http.html#paging">содержатся в возвращаемом комплекте в виде ссылок</a>.
</p>
<p>
Обычно сервер предоставляет свои собственные параметры в ссылках, которые он использует для управления состоянием поиска во время получения страниц. Эти параметры нет необходимости понимать или обрабатывать клиентом.
</p>

<p>
Параметр _count определяется как подсказка серверу в отношении как много ресурсов следует возвращать на одной странице. Серверам НЕ СЛЕДУЕТ возвращать больше ресурсов, чем запрошено (даже если они не поддерживаю пагинацию), однако разрешается возвращать меньше, чем запросил клиент. Сервер должен повторять исходный параметр _count в возвращаемых ссылках на страницы, чтобы последующие запросы на пагинацию учитывали этот исходный _count. Обратите внимание, что решение о том, каким образом обрабатывать происходящие в настоящее время обновление ресурсов во время действия поиска, остается на усмотрение поискового механизма.
</p>
<p>
Note that the combination of _sort and _count can be used to return
just the latest resource that meets a particular criteria - set the
critera, and then sort by date in descending order, with _count=1.
This way, the last matching resource will be returned.
</p>
<a name="include"> </a>
<a name="revinclude"> </a>
<h4>Включение других ресурсов в результат _include и _revinclude)</h4>
<p>
Клиенты могут запросить, чтобы система вернула дополнительные ресурсы, относящиеся к результатам поиска, с целью уменьшения общей сетевей задержки при повторных извлечениях связанных ресурсов. Типичный случай, когда это полезно, это когда клиент ищет некоторый тип клинического ресурса, однако для каждого возвращения такого ресурса клиенту также нужен ресурс-объект (пациент), к которому относится клинический ресурс. Клиент запрашивает включение зависимых ресурсов в набор результатов указанием одного или нескольких параметров _include. An alternative scenario is where the client 
wishes to fetch a particular resource, and any resources that refer
to it. For example, the client may wish to fetch a MedicationPrescription,
and any provenance resources that refer to the prescription. This is known
as a reverse include, and specified by providing a _revinclude parameter.
</p>
<p>  
Both _include and _revinclude are based on search parameters, rather 
than paths in the resource, since joins (e.g. <a href="#chaining">chaining</a>
are already done by search parameter.
</p> 
<p>
Each _include parameter specifies a search parameter to join on:
Каждый параметр _include содержит поисковый параметр для присоединения по:
</p>
<pre>
 GET [base]/MedicationPrescription?_include=MedicationPrescription:patient&amp;criteria...
 GET [base]/MedicationPrescription?_revinclude=Provenance:target&amp;criteria...
</pre>
<p>
The first search means, for any matching MedicationPrescription, include 
any patient that the medication prescriptions in the result set refer to. 
The second search means, for any matching prescriptions, return all 
the provenance resources that refer to them. 
</p>
<p>
Parameter values for both _include and _revinclude have 3 parts, separated by a ":" separator:
</p>
<ol>
 <li>The name of the source resource from which the join comes</li>
 <li>The name of the search parameter which must be of type <i>reference</i></li>
 <li>(Optional) A specific of type of target resource (for when the search parameter refers to multiple possible target types)</li>
</ol>
<p>
_include and _reverseInclude parameters do not include multiple values. Instead, the 
parameters are repeated for each different include criteria.
</p>
<p>
For each returned resource, the server identifies the resources that meet
the criteria expressed in the join, and adds to the results,
with the <a href="bundle-definitions.html#Bundle.entry.status">entry.status</a>
set to "include" (in some searches, it is not obvious which resources are 
matches, and which are includes). 
</p>
<p>
The inclusion process can be recursive. For example, this example search 
returns all the <a href="medicationprescription.html">Medication
Prescription</a> resources and their <a href="practitioner.html">prescribing Practitioner</a> Resources
for the matching <a href="medicationdispense.html">Medication Dispense</a> resources:
</p>
<pre>
GET [base]/MedicationDispense?_include=MedicationDispense.authorizingPrescription
    &amp;_include=MedicationPrescription.prescriber&amp;criteria...
</pre>
<p>
Both _include and _reverseInclude and use the wild card "*" for the search parameter
name, indicating by this that any search parameter of type=reference be included, though 
though both clients and servers need to take care not to request or return too many resources
when doing this. Most notably, re-applying inclusion paths over newly included resources
might lead to cycles or the retrieval of the full patient's file: resources are
organized into an interlinked network and broad _include paths may eventually traverse all
possible paths on the server. For servers, these recursive and wildcard _includes are
demanding and may slow the search response time significantly. 
</p>
<p>
It is at the server's discretion how deep to recursively evaluate the _includes. Servers are expected to
limit the number of iterations done and are not obliged to honor requests to include
additional resources in the search results.
</p>
<p>
When the search results are paged, each page of search results should include 
the matching includes for the resources in each page, so that each page stands
alone as a coherent package.
</p>


<a name="contained"> </a>
<a name="containedType"> </a>


<h4>Contained Resources</h4>

<p>
By default, search results only include resources that are not contained in other resources. 
A chained condition will be evaluated inside contained resources. To illustrate this, consider
a MedicationPrescription resource that has a contained Medication resource specifying 
a custom formulation that has ingredient that has a value Substance/x23. In this case, a search:
</p>
<pre>
GET MedicationPrescription?medication.ingredient=Substance/x23
</pre>
<p>
will include the MedicationPrescription resource in the results. However this search:
</p>
<pre>
GET Medication?ingredient=Substance/x23
</pre>
<p>
will not include the contained Medication resource in the results, since either the 
wrong type of resource would be returned, or the contained resource would be returned
without it's container resource, which provides context to the contained resource.
</p>
<p>
Clients are able to modify this behavior using the _contained parameter, which
can have one of the following values:
</p>
<ul>
 <li>false (default): Do not return contained resources</li>
 <li>true: return only contained resources</li>
 <li>both: return both contained and non-contained (normal) resources</li>
</ul>
<p>
When contained resources are being returned, the server 
should return either the container resource, or the contained resource alone. The 
client can specify which by using the _containedType parameter, which can have one of the 
following values:
</p>
<ul>
 <li>container (default): Return the container resources</li>
 <li>contained: return only the contained resource</li>
</ul>
<p>
When returning a container resource, the server simply puts this in the 
search results:
</p>
<pre>
&lt;Bundle&gt;
  ...
  &lt;base value=&quot;http://example.com/fhir&quot;/&gt;
  &lt;entry&gt;
    &lt;resource&gt;
      &lt;MedicationPrescription&gt;
        &lt;id value=&quot;23&quot;&gt;
        ....
        &lt;contained&gt;
          &lt;Medication&gt;
            &lt;id value=&quot;m1&quot;&gt;
            ...
          &lt;/Medication&gt;
        &lt;contained&gt;

      &lt;/MedicationPrescription&gt;
    &lt;/resource&gt;
    &lt;search&gt;
      &lt;mode value=&quot;match&quot;/&gt;
    &lt;/search&gt;
  &lt;/entry&gt;
&lt;/Bundle&gt;
</pre>
<p>
In the case of returning container resources, the server SHALL populate the entry.search.mode
element so that the client can pick matches and includes apart (the usual approach of doing it
by type may not work). If the return type is the contained resource, this must be done slightly 
differently:
</p>
<pre>
&lt;Bundle&gt;
  ...
  &lt;base value=&quot;http://example.com/fhir&quot;/&gt;
  &lt;entry&gt;
    &lt;base value=&quot;http://example.com/fhir/MedicationPrescription/23#&quot;/&gt;
    &lt;resource&gt;
      &lt;Medication&gt;
        &lt;id value=&quot;m1&quot;&gt;
        ...
      &lt;/Medication&gt;
    &lt;/resource&gt;
    &lt;search&gt;
      &lt;mode value=&quot;match&quot;/&gt;
    &lt;/search&gt;
  &lt;/entry&gt;
&lt;/Bundle&gt;
</pre>
<p>
In this case, the alternative base informs the client that this is a contained resource,
and the identity of the containing resource.
</p>
<p>
<i>todo: this is yet another stitching rule for Bundle.entry.base</i>.
</p>

<a name="external"> </a>
<h4>Внешние ссылки</h4>
<p>
Если путь _include выбирает ссылку, которая относится к ресурсу на другом сервере, сервер может предпочесть включить этот ресурс в результаты поиска для удобства клиента.
</p>
<p>
Если путь _include выбирает ссылку, которая относится к сущности, не являющейся Ресурсом (например вложенное изображение), сервер может также решить включить это в возвращаемые результаты в виде <a href="extras.html#binary">Binary</a> ресурса. Например, путь включения может указывать на вложение с помощью ссылки, как здесь:
</p>
<pre>
 &lt;content&gt;
   &lt;contentType&gt;image/jpeg&lt;/contentType&gt;
   &lt;url&gt;http://example.org/images/2343434/234234.jpg&lt;/url&gt;
 &lt;/content&gt;
</pre>
<p>
Сервер может запросить цель этой ссылки и добавить её к результатам для удобства клиента.
</p>

<a name="dstu-2"> </a>
<blockquote>
<p><b>Примечание DSTU</b>: HL7 ожидает фидбеков от разработчиков о том, следует ли ввести дополнительные правила работы _include, основанных на опыте внедрения.
</p>
</blockquote>


<h4>Пагинация (разбиение на страницы)</h4>
<p>
При возвращении разбитых на страницы результатов поиска с ресурсами _include, все _include-ресурсы, относящиеся к первичным ресурсам, возвращаемым на странице, ДОЛЖНЫ также быть возвращены в рамках этой же страницы, даже если некоторые их этих экземпляров ресурсов уже были ранее показаны на предыдущих страницах. Это позволит и отправителю, и получателю избежать кеширования результатов на других страницах.
</p>

<a name="summary"> </a>
<h4>Ресурсы с кратким содержанием (Summary)</h4>
<p>
Клиент может запросить сервер вернуть только суммарные ресурсы с помощью параметра "_summary":
</p>
<pre>
   GET [base]/ValueSet?_summary=true
</pre>
<p>
Параметр <i>_summary</i> требует от сервера вернуть только те элементы, которые помечены как "summary" в своем определении. Это используется для уменьшения общей загрузки на сервер, на клиента и на ресурсы между ними, например на сеть. Наиболее применимо к ресурсам, которые могут быть большими, особенно те, что включают изображения или элементы, повторяющиеся много раз.
</p>
<p>
Серверы не обязаны возвращать только суммарные ресурсы, а суммарность не определена для ресурсов, где нет необходимости в резюмировании. Имеется только одна краткая форма, определенная для каждого ресурса, чтобы позволить серверам хранить резюмированную форму заранее.
</p>
<a name="score"> </a>
<h4>Relevance</h4>
<p>
Where a search specifies a non-deterministic sort, the search algorithm
may generate some kind of ranking score to indicate which resources meet
the specified criteria better than others. The server can return this
score in <a href="bundle-definitions.html#Bundle.entry.score">entry.score</a>:
</p>
<pre class="xml">
  &lt;entry&gt;
    &lt;score value=&quot;.45&quot;/&gt;
    &lt;Patient&gt;
      ... patient data ...
    &lt;/Patient&gt;
  &lt;/entry&gt;
</pre>
<p>
The score is a decimal number with a value between (and including) 0 and 1, where 1 is best match, and 0 is least match.
</p>

<a name="conformance" />
<h3>Заключение о соответствии сервера (Server Conformance)</h3>
<p>
Чтобы позволить клиенту быть уверенным о том, что параметры поиска были использованы сервером в качестве критериев, серверу СЛЕДУЕТ возвращать параметра, которые были фактически использованы при обработке поиска. Приложениям, обрабатывающим результаты поиска, следует проверять эти возвращаемые значения при необходимости. Например, если сервер не поддерживает некоторые фильтры, указанные в поиске, клиент мог бы вручную применить эти фильтры к полученному набору результатов, показать предупреждающее сообщение пользователю или совершить какое-то другое действие.
</p>
<p>
В случае RESTful-поиска эти параметра закодированы в ссылку с типом отношения self в bundle, который будет возвращен:
</p>
<pre class="xml">
  &lt;link&gt;
    &lt;relation value="self"/&gt; 
    &lt;url value="http://example.org/Patient?name=peter"/&gt;
  &lt;/link&gt;
</pre>
<p>
В остальном серверы имеют значительную свободу действий в отношении поддерживаемого поиска:
</p>
<ul>
 <li>Серверы могут выбирать, какие параметры поддерживать (кроме _id выше)</li>
 <li>Серверы могут выбирать, когда и где применять формирование цепочки параметров, и когда и где они поддерживают параметр _include</li>
 <li>Серверы могут объявлять дополнительные параметры в профилях, на которые есть ссылки из их заявлений о соответствии. Серверам следует определять параметры поиска, начинающиеся с символа "-", чтобы гарантировать, что имена, они выбрали, не будут конфликтовать с параметрами, определенным в данной спецификации в будущем</li>
 <li>От серверов не требуется навязывать чувствительность к регистру именам параметров, хотя имена являются чувствительными к регистру (и URL-адреса в основном являются регистрозависимыми)</li>
 <li>Серверы могут выбирать, сколько результатов возвращать, хотя клиент может использовать _count как описано выше</li>
 <li> Серверы могут выбирать способ сортировки возвращаемых результатов, хотя они ДОЛЖНЫ принимать на обработку параметр _sort</li>
</ul>

<hr/>
<a name="advanced"> </a>
<h3>Продвинутый поиск</h3>
<p>
Система поиска, описанная выше - это пригодная основа для обеспечения простого поиска, основанного на индексированных критериях, однако необходима возможность более сложных запросов для обработки точных запросов, комбинированных  требований для поддержки принятия решений, и прямых запросов, имеющих человеческую интерпретацию.
</p>
<p>
Более продвинутые операции поиска определяются параметром _query:
</p>
<pre>
   GET [base]/Patient?_query=name&amp;parameters...
</pre>
<p>
 Параметр _query присваивает имя пользовательскому профилю поиска, который описывает определенную операцию поиска. Именованный запрос может определять дополнительные именованные параметры, которые используются с этим конкретным именованным запросом. Серверы могут определять свои собственные дополнительные именованные запросы для удовлетворения собственных нужд с помощью <a href="operationdefinition.html">OperationDefinition</a>.
</p>
<p>
 В наборе параметров поиска может быть всего один параметр _query. Серверы, обрабатывающие запросы поиска, ДОЛЖНЫ отказывать в обработке запроса поиска, если они не могут распознать значение параметра _query.
</p>

<h3>Выполнение поиска</h3>
<p>
В дополнение к стандартной операции <a href="http.html#search">поиска</a> в RESTful-интерфейсе (описанной выше), поиск может быть также выполнен с помощью фреймворка обмена сообщениями.
</p>
<p>
<i>TODO: describe how this is done</i>
</p>

<a name="currency"> </a>
<h3>Актуальность результатов поиска</h3>

<p>
 Актуальность результатов операции поиска гарантируется только на момент выполнения операции. После того, как операция выполнена, продолжающиеся в настоящее время действия, совершаемые над ресурсами, полученными с помощью выполнения поиска, будут делать результаты всё более и более неактуальными. Значимость этого зависит от типа поиска и вида использования результатов.
</p>
<p>
 В частности, это важно, когда сервер возвращает результаты в виде ряда страниц. Решение о том, каким образом обрабатывать происходящие в настоящее время обновления ресурсов во время действия поиска, остается на усмотрение поискового механизма.
</p>
<p>
Следует отметить, что выполнение операции поиска не меняет набор ресурсов на сервере, за исключением создания ресурсов <a href="auditevent.html">Audit Event</a>, которые выполняют аудит самого поиска.
</p>

</div>

[%file newfooter%]
</body>
</html>

