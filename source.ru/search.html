<!DOCTYPE HTML>

[%settitle Поиск (RESTful API) %]
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
[%file newheader%]
</head>
<body>
[%file newnavbar%]

<div class="col-12">

<a name="base"> </a>
<h2>Поиск</h2>
<table class="cols"><tr><td id="wg"><a _target="blank" href="[%wg fhir%]">[%wgt fhir%]</a> Рабочая группа</td><td id="fmm"><a href="versions.html#maturity">Уровень зрелости</a>: 5</td><td id="ballot"><a href="versions.html#levels">Статус голосования</a>: <a href="versions.html#std-process">Пробное использование</a></td></tr></table>

<p>
Поиск ресурсов является основополагающим в механике FHIR.
Операции поиска проходят по существующим ресурсам, отфильтровывая их в соответствии с параметрами, переданными операции поиска. Текст ниже описывает систему поиска в FHIR, начиная от простых случаев и заканчивая комплексными. Реализаторам потребуется реализовать только ту часть функциональности, которая им необходима для своих реализаций.
<!-- Searching for resources is fundamental to the mechanics of FHIR.
Search operations traverse through an existing set of resources filtering by 
parameters supplied to the search operation. The text below describes
the FHIR search framework, starting with simple cases moving to the more complex.
Implementers need only implement the amount of
complexity that they require for their implementations. -->
</p>

<h3>Сводная таблица</h3>

<table class="grid">
<tr><td><b>Типы параметров поиска</b></td><td><b>Параметры для всех ресурсов</b></td><td><b>Параметры результатов поиска</b></td></tr>
<!-- <tr><td><b>Search Parameter Types</b></td><td><b>Parameters for all resources</b></td><td><b>Search result parameters</b></td></tr> -->
<tr>
<td>
<%codetoc http://hl7.org/fhir/search-param-type%>
</td>
<td>
<a href="#id"><code>_id</code></a><br/>
<a href="#lastUpdated"><code>_lastUpdated</code></a><br/>
<a href="#tag"><code>_tag</code></a><br/>
<a href="#profile"><code>_profile</code></a><br/>
<a href="#security"><code>_security</code></a><br/>
<a href="#text"><code>_text</code></a><br/>
<a href="#content"><code>_content</code></a><br/>
<a href="#list"><code>_list</code></a><br/>
<a href="#has"><code>_has</code></a><br/>
<a href="#_type"><code>_type</code></a><br/>
<a href="#query"><code>_query</code></a><br/>
</td>
<td>
<a href="#sort"><code>_sort</code></a><br/>
<a href="#count"><code>_count</code></a><br/>
<a href="#include"><code>_include</code></a><br/>
<a href="#revinclude"><code>_revinclude</code></a><br/>
<a href="#summary"><code>_summary</code></a><br/>
<a href="#elements"><code>_elements</code></a><br/>
<a href="#contained"><code>_contained</code></a><br/>
<a href="#containedType"><code>_containedType</code></a><br/>
</td>
</tr>
</table>
<p>
Кроме этого, есть ещё один особый параметр <a href="#filter"><code>_filter</code></a> для альтернативного метода поиска.
<!-- In addition, there is a special search parameter called <a href="#filter"><code>_filter</code></a> that allows for an alternative method of searching. -->
</p>
<p>
Также есть отдельная страница, где перечислены <a href="searchparameter-registry.html">все поисковые параметры</a>.
<!-- Also, there is a single page that lists <a href="searchparameter-registry.html">all the search parameters</a>. -->
</p>

<h3>Введение</h3>
<p>
В простейшем случае поиск выполняется операцией <code>GET</code> в RESTful-системе:
<!-- In the simplest case, a search is executed by performing a <code>GET</code> operation
in the RESTful framework: -->
</p>
<pre>
 GET [base]/[type]?name=value&amp;...{&amp;_format=[mime-type]}}
</pre>
<p> 
Для такого RESTful-поиска (см. <a href="http.html#search">определение в RESTful API</a>) параметры представляют собой последовательность пар вида имя=[значение] (name=[value]), кодированных в URL [процентная кодировка] или в формате application/x-www-form-urlencoded для [запроса] POST:
<!-- For this RESTful search (see <a href="http.html#search">definition in RESTful API</a>), the parameters are a series
of name=[value] pairs encoded in the URL or as an
application/x-www-form-urlencoded submission for a POST: -->
</p>
<pre>
 POST  [base]/[type]/_search{?[parameters]{&amp;_format=[mime-type]}}
</pre>
<p> 
Сервер определяет, какие ресурсы из набора, который он обслуживает, соответствуют указанным критериям, и возвращает результаты в HTTP-ответе в виде <a href="bundle.html">bundle</a>, который включает в себя ресурсы, являющиеся результатами этого поиска. Отметьте, что параметр <code>_format</code> работает с поиском так же, как и с <a href="http.html#mime-type">другими операциями</a>.
<!-- The server determines which of the set of resources it serves meet
the specific criteria, and returns the results in the HTTP response 
as a <a href="bundle.html">bundle</a> which includes the resources 
that are the results of the search. Note that the <code>_format</code>
parameter works for search <a href="http.html#mime-type">like for other interactions</a>.  -->
</p>
<p>
<a href="http.html#search">Операции поиска</a> выполняются в одном из трех заданных контекстов, определяющих, в каком наборе ресурсов будет осуществляться поиск:
<!-- <a href="http.html#search">Search operations</a> are executed in one of three defined contexts that control which set of resources are being searched: -->
</p>
<ul>
 <li>Определенный тип ресурса: <code>GET [base]/[type]?parameter(s)</code></li>
 <li>Определенный <a href="compartmentdefinition.html">модуль</a>, возможно с указанием типа ресурса в этом модуле: <code>GET [base]/Patient/[id]/[type]?parameter(s)</code></li>
 <li>Все ресурсы: <code>GET [base]?parameter(s)</code> (только параметры, общие для всех типов)</li>
<!--  <li>A specified resource type: <code>GET [base]/[type]?parameter(s)</code></li>
 <li>A specified <a href="compartmentdefinition.html">compartment</a>, perhaps with a specified resource type in that compartment: <code>GET [base]/Patient/[id]/[type]?parameter(s)</code></li>
 <li>All resource types: <code>GET [base]?parameter(s)</code> (parameters common to all types only)</li> -->
</ul>
<p>
Операции поиска также могут быть реализованы в <a href="messaging.html#search">фреймворке обмена сообщениями</a>.
<!-- Search operations can also be implemented in <a href="messaging.html#search">the messaging framework</a>. -->
</p>
<p>
Сервер определяет, какие из его ресурсов соответствуют критериям, содержащимся в параметрах поиска, как описано ниже. Однако у сервера имеется привилегия возвращать дополнительные результаты поиска, если он считает их релевантными. Примечание: имеется особый случай поиска наиболее релевантного контекста, в котором поисковый набор является неопределимым - <a href="patient.html#mpi">Patient MPI Search</a>.
<!-- The server determines which of their resources meet the criteria 
contained in the search parameters as described below. However
the server has the prerogative to return additional search results 
if it believes them to be relevant. Note: There is a 
special search for the most relevant context in which the 
search set is indeterminate: <a href="patient.html#mpi">Patient MPI Search</a>. -->
</p>
<p>
Поиск с помощью <code>GET</code> может содержать регистрозависимую информацию в параметрах поиска. Поэтому рекомендуется использовать безопасную коммуникацию и контроль точек взаимодействия, см. <a href="security.html#http">Security Communications</a>.
<!-- Search using <code>GET</code> may include sensitive information in the search parameters.  Therefore 
secure communications and endpoint management are recommended, see <a href="security.html#http">Security Communications</a> -->
</p>
<p>
The response to any search operation is always a list of resources in a Bundle. 
An alternative approach is to <a href="graphql.html">use GraphQL</a>.
</p>

<a name="errors"> </a>
<h3>Обработка ошибок<!-- Handling Errors --></h3>
<p>
Если сервер не может выполнить поисковый запрос, он возвращает ошибку. 
HTTP-код состояния <code>403</code> говорит о том, что сервер отказался выполнять поиск, в то время как другие коды <code>4xx</code> и <code>5xx</code> означают, что произошла некоторая ошибка. Если поиск не выполнился, сервер ДОЛЖЕН вернуть <a href="operationoutcome.html">OperationOutcome</a> в указанием причины неудачи. Примечание: пустой результат поиска не считается неудачей.
<!-- If a server is unable to execute a search request, it may return an error. 
A HTTP status code of <code>403</code> signifies that the server refused to perform the search,
while other <code>4xx</code> and <code>5xx</code> codes signify that some sort of error has occurred. When
the search fails, a server SHOULD return an <a href="operationoutcome.html">OperationOutcome</a>
detailing the cause of the failure. Note: An empty search result is not a failure. -->
</p>
<p>
В некоторых случаях параметры могут вызвать ошибку. Например:
<!-- In some cases, parameters may cause an error. For instance: -->
</p>
<ul>
 <li>В параметре может быть указан несуществующий ресурс, например <code>GET [base]/Observation?subject=101</code>, где "101" не существует</li>
 <li>В параметре может быть указан неизвестный код, например<code>GET [base]/Observation?code=loinc|1234-1</code>, где LOINC-код "1234-1" не известен серверу</li>
 <li>В параметре может быть указано время вне допустимого диапазона, например <code>GET [base]/Condition?onset=le1995</code>, когда система имеет данные только начиная с 2001 года</li>
 <li>В параметре может быть использован запрещённый или недопустимый модификатор, например <code>GET [base]/Condition?onset:text=1995</code>, где этот модификатор не может быть обработан сервером</li>
 <li>Параметр даты/времени может иметь неправильный формат, например <code>GET [base]/Condition?onset=23%20May%202009</code></li>
 <li>Параметр может быть неизвестен или не поддерживаться (см. ниже)</li>
<!--  <li>A parameter may refer to a non-existent resource e.g. <code>GET [base]/Observation?subject=101</code>, where "101" does not exist</li>
 <li>A parameter may refer to an unknown code e.g. <code>GET [base]/Observation?code=loinc|1234-1</code>, where the LOINC code "1234-1" is not known to the server</li>
 <li>A parameter may refer to a time that is out of scope e.g. <code>GET [base]/Condition?onset=le1995</code>, where the system only has data going back to 2001</li>
 <li>A parameter may use an illegal or unacceptable modifier e.g. <code>GET [base]/Condition?onset:text=1995</code>, where the modifier cannot be processed by the server</li>
 <li>A data time parameter may have incorrect format e.g. <code>GET [base]/Condition?onset=23%20May%202009</code></li>
 <li>A parameter may be unknown or unsupported (see below)</li> -->

</ul>
<p>
Если содержимое параметра синтаксически неправильное, сервер ДОЛЖЕН вернуть ошибку. Однако если проблема в логическом условии (например указан неизвестный "subject" или "code"), сервер ДОЛЖЕН обработать поиск с указанным параметром - результатом будет пустой результат поиска, поскольку такой параметр не может быть выполнен.
<!-- Where the content of the parameter is syntactically incorrect, servers SHOULD return an error. 
However where the issue is a logical condition (e.g. unknown subject or code), the server 
SHOULD process the search, including processing the parameter - with the result of returning
an empty search set, since the parameter cannot be satisfied.  -->
</p>
<p>
В таких случаях процесс поиска МОЖЕТ включать <a href="operationoutcome.html">OperationOutcome</a> в поисковый набор, который содержит дополнительный подсказки и предупреждения относительно процесса поиска. В результаты поиска это входит в виде записи "entry" с <a href="bundle-definitions.html#Bundle.entry.search.mode">search mode</a> = <a href="valueset-search-entry-mode.html"><code>outcome</code></a>. Клиенты могут использовать эту информацию для улучшения последующих поисков.
<!-- In such cases, the search process MAY include an <a href="operationoutcome.html">OperationOutcome</a>
in the search set that contains additional hints and warnings about the search process.
This is included in the search results as an entry with <a href="bundle-definitions.html#Bundle.entry.search.mode">search mode</a> = <a href="valueset-search-entry-mode.html"><code>outcome</code></a>.
Clients can use this information to improve future searches. -->
</p>

<p><b>Неизвестные и неподдерживаемые параметры<!-- Unknown and unsupported parameters --></b></p>

<p>
Сервер может получить от клиента параметры, которые он не распознаёт или распознаёт, но не поддерживает (либо вообще, либо в конкретном случае). В общем случае сервер ДОЛЖЕН игнорировать неизвестные или неподдерживаемые параметры по следующим причинам:
<!-- Servers may receive parameters from the client that they do not recognise, or may 
receive parameters they recognise but do not support (either in general, or for
a specific search). In general, servers SHOULD ignore unknown or unsupported parameters
for the following reasons: -->
</p>
<ul>
 <li>Различные HTTP-стеки и прокси могут добавлять параметры, которые клиент не контролирует.<!-- Various HTTP stacks and proxies may add parameters that aren't under the control of the client --></li>
 <li>Клиент может определить, какие параметры сервер использовал, рассматривая "self"-ссылку в ответе сервера (см. <a href="#conformance">ниже</a>)<!-- The client can determine what parameters the server used by examing the self link in the return (see <a href="#conformance">below</a>) --></li>
</ul>
<p>
Клиенты могут указывать желаемое поведение сервера, используя заголовок "prefer".
<!-- Clients can specify how the server should behave, by using the prefer header -->
</p>
<ul>
 <li>Prefer: handling=strict: Клиент говорит серверу возвращать ошибку для всех неизвестных или неподдерживаемых параметров.<!-- Prefer: handling=strict: Client requests that the server return an error for any unknown or unsupported parameter --></li>
 <li>Prefer: handling=lenient: Клиент говорит серверу игнорировать все неизвестные или неподдерживаемые параметры.<!-- Prefer: handling=lenient: Client requests that the server ignore any unknown or unsupported parameter --></li>
</ul>
<p>
Сервер ДОЛЖЕН выполнять требование клиента, но не обязан это делать.
<!-- Servers SHOULD honor the client's request, but are not required to do so.  -->
</p>

<a name="standard"> </a>
<h3>Стандартные параметры<!-- Standard Parameters --></h3>

<a name="all"> </a>
<h4>Параметры для всех ресурсов<!-- Parameters for all resources --></h4>
<p>
Эти параметры <a href="resource.html#search">описаны здесь</a> и применяются ко всем ресурсам: [%allparams%]. Кроме того, параметры поиска  <a href="#text"><code>_text</code></a> и <a href="#filter"><code>_filter</code></a> (задокументированы ниже) также применяются ко всем ресурсом (как и параметры результатов поиска). 
<!-- The following parameters apply <a href="resource.html#search">to all resources</a>: [%allparams%]. In addition, the search 
parameter <a href="#text"><code>_text</code></a> and <a href="#filter"><code>_filter</code></a>, (documented below) also applies to all resources (as do the search result parameters).  -->
</p>
<a name="id"> </a>
<p>
Параметр поиска <code>_id</code> относится к логическому id ресурса и может быть использован, когда в качестве контекста поиска указан тип ресурса:
<!-- The search parameter <code>_id</code> refers to the logical id of the resource, and can be used when the search context specifies a resource type: -->
</p>
<pre>
 GET [base]/Patient?_id=23
</pre>
<p>
В этом примере поиска ищется ресурс patient с указанным id (может быть только один ресурс с таким id). С функциональной точки зрения это эквивалентно <a href="http.html#read">простой операции чтения</a>:
<!-- This search finds the patient resource with the given id (there can only be one
resource for a given id). Functionally, this is equivalent to a <a href="http.html#read">simple
read operation</a>: -->
</p>
<pre>
 GET [base]/Patient/23
</pre>
<p>
Однако поиск с параметром <code>_id</code> возвращает бандл с запрашиваемым ресурсом, а не просто сам этот ресурс. Могут быть добавлены дополнительные параметры, которые  предоставят дополнительную функциональность к этой базовой, эквивалентной чтению (например <a href="#include"><code>_include</code></a>). Отметьте, что хотя параметр _id и имеет тип "токен", у него нет системы, так как сервер должен искать по точному соответствию с ним.
<!-- However, the search with parameter <code>_id</code> returns a bundle with the requested resource, instead of just the
resource itself. Additional parameters can be added which may provide
additional functionality on top of this base read equivalence (e.g. <a href="#include"><code>_include</code></a>). Note that although the _id parameter has a type of token, because servers SHALL use exact match with it, there is 
no system for the _id parameter. -->

</p>
<a name="lastUpdated"> </a>
<p>
Параметр поиска <code>_lastUpdated</code> может использоваться для выбора ресурсов по дате их последнего изменения:
<!-- The search parameter <code>_lastUpdated</code> can be used to select resources based
on the last time they were changed: -->
</p>
<pre>
 GET [base]/Observation?_lastUpdated=gt2010-10-01
</pre>
<p>
В этом примере поиска ищутся все Observations, измененные после 1-Окт 2010. При использовании этого параметра поиска приложениям следует принимать во внимание подходы к синхронизации (<a href="http.html#history">RESTful история</a>
или ресурс <a href="subscription.html">Subscription</a>.
<!-- This search finds any observations changed since 1-Oct 2010. When
this search parameter is used, applications should consider
synchronization approaches (<a href="http.html#history">RESTful history</a>
or the <a href="subscription.html">Subscription resource</a>). -->
</p>
<a name="tag"> </a>
<a name="tags"> </a>
<a name="profile"> </a>
<a name="security"> </a>

<p>
Поисковые параметры <a href="resource.html#simple-tags">_tag</a>, <a href="resource.html#profile-tags">_profile</a> и <a href="resource.html#security-labels">_security</a> ищут совпадения по эквивалентным элементам в элементе <a href="resource.html#meta"><code>meta</code></a>.
К примеру,
<!-- The search parameters <a href="resource.html#simple-tags">_tag</a>, <a href="resource.html#profile-tags">_profile</a> and <a href="resource.html#security-labels">_security</a> parameters search
on the equivalent elements in the <a href="resource.html#meta"><code>meta</code> element</a>.
For example, -->
</p>
<pre>
 GET [base]/Condition?_tag=http://acme.org/codes|needs-review
</pre>
<p>
ищет все ресурсы Condition с тегом:
<!-- searches for all Condition resources with the tag: -->
</p>
<pre class="json">
{
  "system" : "http://acme.org/codes", 
  "code" : "needs-review"
}
</pre>
<p>
Таким же образом:
<!-- In the same manner: -->
</p>
<pre>
 GET [base]/DiagnosticReport?_profile=http://hl7.org/fhir/StructureDefinition/lipid
 GET [base]/DiagnosticReport?_profile=Profile/lipid
</pre>
<p>
ограничивает поиск только ресурсами DiagnosticReport с тегом, что согласуется с определенным профилем. Вторая ссылка относительная и ссылается на локальный профиль на том же сервере.
<!-- restricts the search to only DiagnosticReport resources that are tagged as conforming to a particular profile.
The second reference is relative, and refers a local profile on the same server. -->
</p>
<p>
Параметры <a href="resource.html#simple-tags">_tag</a>, <a href="resource.html#profile-tags">_profile</a> и <a href="resource.html#security-labels">_security</a> имеют тип "токен" (см. <a href="#token">ниже</a>).
<!-- <a href="resource.html#simple-tags">_tag</a>, <a href="resource.html#profile-tags">_profile</a> and <a href="resource.html#security-labels">_security</a> parameters are all token types (see <a href="#token">below</a>). -->
</p>


<h4>Указание параметров для каждого ресурса<!-- Parameters for each resource --></h4>
<p>
Кроме параметра <code>_id</code>, который применяется ко всем ресурсам, каждый тип FHIR-ресурса определяет свой собственный набор параметров поиска по именам, типам и значениям. Эти параметры поиска можно найти на той же самой странице, где и определения ресурса, также они опубликованы как часть стандартного заявления о возможностях - Capability statement (<a href="capabilitystatement-base.xml.html">XML</a> или <a href="capabilitystatement-base.json.html">JSON</a>).
<!-- In addition to the <code>_id</code> parameter which exists for all resources, each
FHIR resource type defines its own set of search parameters with
their names, types, and meanings. These search parameters are on the
same page as the resource definitions, and are also published as part
of the standard Capability statement (<a href="capabilitystatement-base.xml.html">XML</a> or <a href="capabilitystatement-base.json.html">JSON</a>). -->
</p>
<p>
Как правило, заданные параметры поиска соответствуют одному элементу в ресурсе, однако это не является обязательным, и некоторые параметры поиска относятся к одному типу элемента в нескольких местах или относятся к их значениям.
<!-- In general, the defined search parameters correspond to a
single element in the resource, but this is not required, and some
search parameters refer to the same type of element in multiple
places, or refer to derived values. -->
</p>
<p>
Некоторые параметры поиска, заданные ресурсами, ассоциируются с более чем одним путем в ресурсе. Это означает, что соответствие такому параметру поиска выполняется в случае, когда любой из путей содержит совпадающее содержимое. Если путь соответствует, ресурс целиком возвращается в результатах поиска. Клиенту может потребоваться проверить ресурс, чтобы определить, который из путей содержит совпадение.
<!-- Some search parameters defined by resources are associated
with more than one path in a resource. This means that the search
parameter matches if any of the paths contain matching content.  If a
path matches, the whole resource is returned in the
search results. The client may have to examine the resource to determine
which path contains the match. -->
</p>
<p>
Серверам не обязательно реализовывать ни один из этих параметров поиска (за исключением параметра <code>_id</code>, описанного выше), и они могут определять свои собственные параметры.
<!-- Servers are not required to implement any of the standard search parameters
(except for the <code>_id</code> parameter described above), and may define their own
 parameters. -->
</p>

<a name="ptypes"> </a>
<h4>Типы параметров поиска<!-- Search Parameter Types --></h4>
<p>
Каждый параметр поиска указывается с типом, который определяет способ поведения параметра поиска. Далее следуют определения типов параметров:
<!-- Each search parameter is defined by a type that specifies how the search parameter
behaves. These are the defined parameter types: -->
</p>
<%linkcodelist http://hl7.org/fhir/search-param-type%>
<p>
К этим параметрам поиска могут также добавляться "модификаторы", которые управляют их поведением. Виды модификаторов, которые могут использоваться, зависят от типа параметра, который требуется модифицировать.
<!-- The search parameters can also append "modifiers" that control
their behavior. The kinds of modifiers that available is dependent on the type
of parameter being modified. -->
</p>

<a name="modifiers" > </a>
<h4>Модификаторы<!-- Modifiers --></h4>
<p>
Параметры определены для каждого ресурса. К имени параметра может добавляться модификатор в виде суффикса. Такие модификаторы отделяются от имени параметра двоеточием. Модификаторами являются:
<!-- Parameters are defined per resource.  Parameter names may specify a modifier as a suffix.
The modifiers are separated from the parameter name by a colon. Modifiers are: --></p>
<ul>
 <li>Для всех параметров (кроме комбинации): <code>:missing</code>, например gender:missing=true (or false). Поиск по <code>gender:missing=true</code> вернет все ресурсы, которые не имеют никакого значения параметра gender (что, как правило, приравнивается к отсутствию соответствующего элемента в ресурсе). Поиск по <code>gender:missing=false</code> вернет все ресурсы, имеющие значение параметра <code>gender</code>.</li>
 <li>Для строки: <code>:exact</code> (совпадение должно быть точным, не частичным совпадением, чувствительным к регистру и диакритическим знакам), либо <code>:contains</code> (регистронезависимый и не чувствительный к диакритическим знакам, частичное совпадение в начале или в конце), вместо поведения по умолчанию (регистронезависимый и не чувствительный к диакритическим знакам, частичное совпадение в начале или в конце)</li>
 <li>Для лексемы (token): <code>:text</code> (совпадение совершает частичные поиски по части text в CodeableConcept или 
части display в Coding), вместо поиска по умолчанию, который использует коды. Другие модификаторы <code>:in</code>, <code>:below</code>, <code>:above</code> и <code>:not-in</code> описаны ниже.</li>
 <li>Для ссылки: <code>:[type]</code>, где [type] - это имя типа ресурса.</li>
 <li>Для uri: <code>:below</code>, <code>:above</code> означают, что вместо точного совпадения значению соответствует либо левосторонний поиск, либо наоборот.</li>
<!--  <li>For all parameters (except combination): <code>:missing</code>; e.g. gender:missing=true (or false).
  Searching for <code>gender:missing=true</code> will return all the resources that don't have a value for the gender parameter (which usually
  equates to not having the relevant element in the resource). Searching for <code>gender:missing=false</code>
  will return all the resources that have a value for the <code>gender</code> parameter. </li>
 <li>For string: <code>:exact</code> (the match needs to be exact, no partial matches, case sensitive and accent-sensitive), or <code>:contains</code> (case insensitive and accent-insensitive, partial match at start or end), instead of the default behavior (case insensitive and accent-insensitive, partial matches at the end of the string).</li>
 <li>For token: <code>:text</code> (the match does a partial searches on the text portion of a CodeableConcept or the display portion of a Coding), instead of the default search which uses codes. Other defined modifiers are <code>:in</code>, <code>:below</code>, <code>:above</code> and <code>:not-in</code> which are described below.</li>
 <li>For reference: <code>:[type]</code> where [type] is the name of a type of resource</li>
 <li>For uri: <code>:below</code>, <code>:above</code> indicate that instead of an exact match, either the search term left matches the value, or vice-versa.</li> -->
</ul>
<p>
Сервер ДОЛЖЕН отклонять любые запросы поиска, которые содержат суффиксы-модификаторы, которые сервер <b>не</b> поддерживает для данного параметра. К примеру, если сервер поддерживает параметр поиска <code>name</code>, но не его модификатор <code>:exact</code>, ему следует отклонять поиск с параметром <code>name:exact=Bill</code> и возвращать HTTP-ошибку <code>400</code> и <a href="operationoutcome.html">OperationOutcome</a> с <a href="operationoutcome-example-searchfail.html">чётким сообщением об ошибке</a>.
<!-- Server SHALL reject any search request that contains is suffixed by a modifier that the 
server does <b>not</b> support for that parameter. For example, if the server supports 
the <code>name</code> search param, but not the <code>:exact</code> modifier on the name, it should reject a 
search with the parameter <code>name:exact=Bill</code>, using an HTTP <code>400</code> error with
an <a href="operationoutcome.html">OperationOutcome</a> with a <a href="operationoutcome-example-searchfail.html">clear error message</a>. -->

</p>

<a name="prefix"> </a>
<h4>Префиксы<!-- Prefixes --></h4>
<p>
Для упорядоченных параметров типа <a href="#number">number</a>, <a href="#date">date</a>и <a href="#quantity">quantity</a>, префикс к значению параметра может быть использован для управления характером поиска совпадения. Чтобы избежать экранирования URL-строки и визуальной путаницы, используются следующие префиксы:
<!-- For the ordered parameter types of <a href="#number">number</a>, <a href="#date">date</a>, and <a href="#quantity">quantity</a>, 
a prefix to the parameter value may be used to control the nature of the matching. To avoid URL escaping and visual confusion,
the following prefixes are used: -->
</p>
<table class="grid">
 <tr>
	<td><code>eq</code></td>
	<td>значение параметра в ресурсе равно указанному значению</td>
	<td>диапазон значения поиска целиком содержит диапазон искомого значения</td>
 </tr>
 <tr>
	<td><code>ne</code></td>
	<td>значение этого параметра в ресурсе не равно указанному значению</td>
  <td>диапазон значения параметра поиска не полностью содержит диапазон искомого значения</td>
 </tr>
 <tr>
	<td><code>gt</code></td>
	<td>значение этого параметра в ресурсе больше, чем указанное значение</td>
  <td>диапазон выше значения поиска пересекается (т. е. частично совпадает) с диапазоном искомого значения</td>
 </tr>
 <tr>
	<td><code>lt</code></td>
	<td>значение этого параметра в ресурсе меньше, чем указанное значение</td>
  <td>диапазон ниже значения поиска пересекается (т. е. частично совпадает) с диапазоном искомого значения</td>
 </tr>
 <tr>
	<td><code>ge</code></td>
	<td>значение этого параметра в ресурсе больше или равно указанному значению</td>
  <td>диапазон выше значения поиска пересекается (т. е. перекрывает) диапазон искомого значения, либо диапазон значения поиска полностью содержит диапазон искомого значения</td>
 </tr>
 <tr>
	<td><code>le</code></td>
	<td>значение этого параметра в ресурсе меньше или равно указанному значению</td>
  <td>диапазон ниже значения поиска пересекается (т.е. перекрывает) диапазон искомого значения, либо диапазон значения поиска полностью содержит диапазон искомого значения</td>
 </tr>
 <tr>
	<td><code>sa</code></td>
	<td>значение этого параметра в ресурсе начинается после указанного значения<!-- the value for the parameter in the resource starts after the provided value --></td>
  <td>диапазон значения параметра не пересекается с диапазоном искомого значения, а диапазон выше поискового значения содержит диапазон искомого значения <!-- the range of the search value does not overlap with the range of the target value, and the range above the search value contains the range of the target value --></td>
 </tr>
 <tr>
	<td><code>eb</code></td>
	<td>значение параметра в ресурсе заканчивается до указанного значения<!-- the value for the parameter in the resource ends before the provided value --></td>
  <td>диапазон поискового значения не пересекается с диапазоном искомого значения, а диапазон ниже поискового значения содержит диапазон искомого значения<!-- the range of the search value does overlap not with the range of the target value, and the range below the search value contains the range of the target value --></td>
 </tr>
 <tr>
	<td><code>ap</code></td>
	<td>значение этого параметра в ресурсе приблизительно равно указанному<!-- the value for the parameter in the resource is approximately the same to the provided value. --><br/> 
	Отметьте, что рекомендуемое значение приближения - 10% от указанного (либо для даты это будет 10% промежуток между текущим и датой), однако системы могут использовать и другие значения на свой выбор
	<!-- Note that the recommended value for the approximation is 10% of the stated value (or for a date, 10% of the gap between now and the date), but systems may choose other values where appropriate --></td>
  <td>диапазон поискового значения пересекается с диапазоном искомого значения<!-- the range of the search value overlaps with the range of the target value --></td>
 </tr>
</table>
<p>
Если префикс не указан, то считается, что это <code>eq</code>. Обратите внимание, что способ работы параметров поиска отличается от способа работы операций над двумя числами в математическом смысле. <code>sa</code> (<code>starts-after</code>) и 
<code>eb</code> (<code>ends-before</code>) не используются для целых чисел.
<!-- If no prefix is present, the prefix <code>eq</code> is assumed. Note that the way search parameters operate 
is not the same as the way the operations on two numbers work in a mathematical sense. <code>sa</code> (<code>starts-after</code>) and 
<code>eb</code> (<code>ends-before</code>) are not used with integer values. -->
</p>
<p>
Для каждого префикса, приведённого выше, указаны две интерпретации - назначение префикса и интерпретация этого параметра при применении к диапазонам. Интерпретация диапазонов приведена для десятичных чисел и дат. 
<!-- For each prefix above, two interpretations are provided - the simple intent of the prefix and the 
interpretation of the parameter when applied to ranges. The range interpretation is provided
for decimals and dates.  Searches are always performed on values that are implicitly
or explicitly a range. For instance, the number 2.0 has an implicit range of 
1.95 to 2.05, and the date 2015-08-12 has an implicit range of the all the time during that day. 
If the target value is a <a href="datatypes.html#range">Range</a>, a <a href="datatypes.html#period">Period</a>, 
or a <a href="datatypes.html#timing">Timing</a>, then the target is explicitly a range. Three ranges 
are identified: -->
</p>
<table class="grid">
 <tr>
	<td>границы интервала</td>
	<td>Пределы, вытекающие из точности значения</td>
  <td>Число 2.0 имеет диапазон от 1.95 до 2.05<br/>
      Дата 2015-08-12 имеет диапазон от 00:00 до 00:00 исключительно</td>
 </tr>
 <tr>
	<td>интервал левее указанного значения</td>
	<td>До указанного числа</td>
  <td>Интервал левее 2.0 включает в себя любое значение, которое меньше или равно &lt;2.00000000000000000000<br/>
      Интервал левее 2015-08-12T05:23:45 включает в себя любое время до 2015-08-12T05:23:45.000000000000000</td>
 </tr>
 <tr>
	<td>диапазон правее указанного значения</td>
	<td>Указанное значение и выше</td>
  <td>Интервал правее 2.0 включает в себя любое значение, которое больше или равно &lt;2.00000000000000000000<br/>
      Интервал правее 2015-08-12T05:23:45 включает в себя любое время после 2015-08-12T05:23:45.000000000000000</td>
 </tr>
<!--  <tr>
	<td>range of the value</td>
	<td>The limits implied by the precision of the value</td>
  <td>The number 2.0 has a range of 1.95 to 2.05<br/>
      The date 2015-08-12 has a range from 00:00 to 00:00 exclusive</td>
 </tr>
 <tr>
	<td>range below the value</td>
	<td>Up to the specified value</td>
  <td>The range below 2.0 includes any value less or equal to &lt;2.00000000000000000000<br/>
      The range before 2015-08-12T05:23:45 includes any time up to 2015-08-12T05:23:45.000000000000000</td>
 </tr>
 <tr>
	<td>range above the value</td>
	<td>The specified value and up</td>
  <td>The range above 2.0 includes any value greater or equal to &lt;2.00000000000000000000<br/>
      The range after 2015-08-12T05:23:45 includes any time after 2015-08-12T05:23:45.000000000000000</td>
 </tr> -->
</table>
<p>
Обсуждение надлежащего использования этих интервалов будет продолжено ниже.
<!-- The proper use of these ranges is discussed further below.  -->
</p>

<a name="number"> </a>
<h4>number</h4>
<p>
Примеры поиска простых численных значений в ресурсе:
<!-- Sarching on a simple numerical value in a resource. Examples: -->
</p>
<table class="grid">
 <tr><td><code>[parameter]=100</code></td><td>Значения, равные 100 с точностью до 3 значимых знаков, таким образом это будет диапазон [99.5 ... 100.5)</td></tr>
 <tr><td><code>[parameter]=100.00</code></td><td>Значения, равные 100 с точностью до 5 значимых знаков, таким образом это будет диапазон [99.995 ... 100.005). Целые числа также равны 100.00, но не 100.01</td></tr>
 <tr><td><code>[parameter]=lt100</code></td><td>Значения меньше 100</td></tr>
 <tr><td><code>[parameter]=le100</code></td><td>Значения, которые меньше или равны 100</td></tr>
 <tr><td><code>[parameter]=gt100</code></td><td>Значения больше 100</td></tr>
 <tr><td><code>[parameter]=ge100</code></td><td>Значения, которые больше или равны 100</td></tr>
 <tr><td><code>[parameter]=ne100</code></td><td>Значения, которые не равны 100</td></tr>
<!--  <tr><td><code>[parameter]=100</code></td><td>Values that equal 100, to 3 significant figures precision, so range [99.5 ... 100.5)</td></tr>
 <tr><td><code>[parameter]=100.00</code></td><td>Values that equal 100, to 5 significant figures precision, so range [99.995 ... 100.005). Whole numbers also equal 100.00, but not 100.01</td></tr>
 <tr><td><code>[parameter]=lt100</code></td><td>Values that are less than 100</td></tr>
 <tr><td><code>[parameter]=le100</code></td><td>Values that are less or equal to 100</td></tr>
 <tr><td><code>[parameter]=gt100</code></td><td>Values that are greater than 100</td></tr>
 <tr><td><code>[parameter]=ge100</code></td><td>Values that are greater or equal to 100</td></tr>
 <tr><td><code>[parameter]=ne100</code></td><td>Values that are not equal to 100</td></tr> -->
</table>
<p>
Примечание: неточность не играет роли при вычислениях. Точность чисел полагается произвольно высокой. (То, как параметры поиска работают в ресурсах, отличается от того, являются ли два числа равными друг другу в математическом смысле).
<!-- Note: Uncertainty does not factor in evaluations.  The precision of the numbers is considered arbitrarily high. (The 
way search parameters operate in resources is not the same as whether two numbers are equal to each other in a mathematical sense). -->
</p>

<p>
Вот несколько примеров поиска:
<!-- Here are some example searches: -->
</p>
<table>
 <tr><td width="50%"><b>Поиск</b></td><td><b>Описание</b></td></tr>
 <tr><td><pre> GET [base]/Encounter?length=gt20</pre></td><td>Поиск всех визитов, длившихся более 20 дней</td></tr>
 <tr><td><pre> GET [base]/ImmunizationRecommendation?deo-number=2</pre></td><td>Поиск всех рекомендаций по иммунизации, рекомендующих вторую дозу</td></tr>
<!--  <tr><td width="50%"><b>Search</b></td><td><b>Description</b></td></tr>
 <tr><td><pre> GET [base]/Encounter?length=gt20</pre></td><td>Search for all the encounters longer than 20 days</td></tr>
 <tr><td><pre> GET [base]/ImmunizationRecommendation?deo-number=2</pre></td><td>Search for any immunization recommendation recommending a second dose</td></tr> -->
</table>


<a name="date"> </a>
<h4>date</h4>
<p>
Параметр даты ищет по дате/времени или периоду. Как это принято для функциональности, связанной с датой/временем, хотя эти понятия и являются относительно простыми, имеется целый ряд тонкостей, связанных с обеспечением их согласованного поведения.
<!-- A date parameter searches on a date/time or period. As is usual for date/time related functionality, while the
concepts are relatively straight-forward, there are a number of subtleties involved in ensuring consistent behavior. -->
</p>
<p>
Формат параметра даты следующий: <code>yyyy-mm-ddThh:mm:ss[Z|(+|-)hh:mm]</code> (стандартный XML-формат).
<!-- The date parameter format is <code>yyyy-mm-ddThh:mm:ss[Z|(+|-)hh:mm]</code> (the standard XML format). -->
</p>
<p>
Технически, им является любой из типов данных <a href="datatypes.html#date">date</a>, <a href="datatypes.html#dateTime">dateTime</a> 
и <a href="datatypes.html#instant">instant</a>; при этом может указываться любая степень точности даты, однако она ДОЛЖНА идти слева направо (т. е. нельзя указать месяц без года), за исключением того, что минуты ДОЛЖНЫ присутствовать, если указан час, и вы ДОЛЖНЫ указать часовой пояс, если присутствует время. Примечание: временнАя часть даты может состоять из часов и минут без секунд, в отличие от типа dateTime XML-схемы. Некоторые пользовательские агенты могут экранировать символы <code>:</code> в URL, и серверы ДОЛЖНЫ корректно обрабатывать это.
<!-- Technically, this is any of the <a href="datatypes.html#date">date</a>, <a href="datatypes.html#dateTime">dateTime</a>, 
and <a href="datatypes.html#instant">instant</a> data types; e.g. Any degree of precision can be provided, but it SHALL 
be populated from the left (e.g. can't specify a month without a year), except that the minutes SHALL be present if 
an hour is present, and you SHOULD provide a time zone if the time part is present. Note: Time can consist of hours and minutes with no seconds, unlike the XML Schema dateTime type. Some user agents may escape the <code>:</code> 
characters in the URL, and servers SHALL handle this correctly. -->
</p>
<p>
Параметры даты можно использовать со следующими типами данных:
<!-- Date parameters may be used with the following data types: -->
</p>
<table class="grid">
 <tr><td><a href="datatypes.html#date">date</a></td><td>В диапазон этого значения входит день, месяц или год, смотря что указано</td></tr>
 <tr><td><a href="datatypes.html#dateTime">dateTime</a></td><td>Это значение включает в себя диапазон в соответствии с указанным выше; например дата 2013-01-10 обозначает любое время от 00:00 10 января 2013 непосредственно до 00:00 11 января 2013</td></tr>
 <tr><td><a href="datatypes.html#instant">instant</a></td><td>Мгновением считается фиксированный момент времени с интервалом меньшим, чем точность системы, т. е. интервал с эффективной шириной 0</td></tr>
 <tr><td><a href="datatypes.html#Period">Period</a></td><td>Период, хотя верхняя или нижняя граница может быть в действительности не указана в ресурсах.</td></tr>
 <tr><td><a href="datatypes.html#Timing">Timing</a></td><td>указанные детали расписания игнорируются и имеют значение только внешние пределы. К примеру, расписание "каждый второй день между 31 января 2013 г. и 24 марта 2013 г." включает в себя 1 февраля 2013 г., даже при том, что это нечетный день, не соответствующий правилу расписания. Это сделано для уменьшения загрузки сервера.</td></tr>
<!--  <tr><td><a href="datatypes.html#date">date</a></td><td>The range of the value is the day, month, or year as specified</td></tr>
 <tr><td><a href="datatypes.html#dateTime">dateTime</a></td><td>The range of the value as defined above; e.g. For example, the 
   date 2013-01-10 specifies all the time from 00:00 on 10-Jan 2013 to immediately before 00:00 on 11-Jan 2013</td></tr>
 <tr><td><a href="datatypes.html#instant">instant</a></td><td>An instant is considered a fixed point in time with an interval smaller than the precision of the system, i.e. an interval with an effective width of 0</td></tr>
 <tr><td><a href="datatypes.html#Period">Period</a></td><td>Explicit, though the upper or lower bound may not actually be specified in resources.</td></tr>
 <tr><td><a href="datatypes.html#Timing">Timing</a></td><td>the specified scheduling details are ignored and only the outer limits matter. For instance, a schedule that specifies every second day between
   31-Jan 2013 and 24-Mar 2013 includes 1-Feb 2013, even though that is on an odd day that is not specified by the period. This is
   to keep the server load processing queries reasonable.</td></tr> -->
</table>
<p>
Неявно, опущенная нижняя граница "меньше", чем любая реальная дата. Опущенная верхняя граница "больше", чем любая реальная дата. 
Применение префиксов:
<!-- Implicitly, a missing lower boundary is "less than" any actual date.  A missing upper boundary is "greater than" any actual date.
The use of the prefixes: -->
</p>
<table class="grid">
 <tr>
   <td><code>[parameter]=eq2013-01-14</code></td>
   <td>
    <ul>
     <li style="list-style-image: url('assets/images/tick2.gif')">2013-01-14T00:00 подходит (очевидно)</li>
     <li style="list-style-image: url('assets/images/tick2.gif')">2013-01-14T10:00 подходит</li>
     <li style="list-style-image: url('assets/images/cross.png')">2013-01-15T00:00 не подходит, т.к. не входит в диапазон</li>
    </ul>
   </td>
 </tr>
 <tr>
   <td><code>[parameter]=ne2013-01-14</code></td>
   <td>
    <ul>
     <li style="list-style-image: url('assets/images/tick2.gif')">2013-01-15T00:00 подходит, т.к. не входит в диапазон</li>
     <li style="list-style-image: url('assets/images/cross.png')">2013-01-14T00:00 не подходит, т.к. входит в диапазон</li>
     <li style="list-style-image: url('assets/images/cross.png')">2013-01-14T10:00 не подходит, т.к. входит в диапазон</li>
    </ul>
   </td>
 </tr>
 <tr>
   <td><code>[parameter]=lt2013-01-14T10:00</code></td>
   <td>
    <ul>
     <li style="list-style-image: url('assets/images/tick2.gif')">2013-01-14 подходит, поскольку содержит часть 14 января 2013 до 10 утра</li>
    </ul>
   </td>
 </tr>
 <tr> 
   <td><code>[parameter]=gt2013-01-14T10:00</code></td>
   <td>
    <ul>
     <li style="list-style-image: url('assets/images/tick2.gif')">2013-01-14 подходит, поскольку содержит часть 14 января 2013 после 10 утра</li>
    </ul>
   </td>
 </tr>
 <tr>
   <td><code>[parameter]=ge2013-03-14</code></td>
   <td>
    <ul>
     <li style="list-style-image: url('assets/images/tick2.gif')">"с 21 января 2013 и далее" входит в указанный диапазон, поскольку он включает в себя любые даты позже 14 марта 2013</li>
    </ul>
   </td>
 </tr>
 <tr>
   <td><code>[parameter]=le2013-03-14</code></td>
   <td>
    <ul>
     <li style="list-style-image: url('assets/images/tick2.gif')">"с 21 января 2013 и далее" входит в указанный диапазон, поскольку  он включает в себя любые даты до 14 марта 2013</li>
    </ul>
   </td>
  </tr>
 <tr>
   <td><code>[parameter]=sa2013-03-14</code></td>
   <td>
    <ul>
     <li style="list-style-image: url('assets/images/tick2.gif')">"с 15 марта 2013 и далее" подходит, поскольку that period starts after 14 марта 2013</li>
     <li style="list-style-image: url('assets/images/cross.png')">"с 21 января 2013 и далее" не подходит, поскольку начинается до 14 марта 2013</li>
     <li style="list-style-image: url('assets/images/cross.png')">"до 21 января 2013 включительно" не подходит, поскольку начинается (и заканчивается) до 14 марта 2013</li>
    </ul>
   </td>
  </tr>
 <tr>
   <td><code>[parameter]=eb2013-03-14</code></td>
   <td>
    <ul>
     <li style="list-style-image: url('assets/images/cross.png')">"с 15 марта 2013 и позже" не подходит, т.к. начинается после 14 марта 2013</li>
     <li style="list-style-image: url('assets/images/cross.png')">"с 21 января 2013 и позже" не подходит, т.к. начинается до 14 марта 2013, однако заканчивается позже этой даты</li>
     <li style="list-style-image: url('assets/images/tick2.gif')">"до 21 января 2013 включительно" не подходит, т.к.заканчивается до 14 марта 2013</li>
    </ul>
   </td>
  </tr>
 <tr>
   <td><code>[parameter]=ap2013-03-14</code></td>
   <td>
    <ul>
     <li style="list-style-image: url('assets/images/cross.gif')">14 марта 2013 - подходит, т.к. это точное совпадение</li>
     <li style="list-style-image: url('assets/images/cross.png')">21 января 2013 - не подходит, т.к. не рядом с 14 марта 2013</li>
     <li style="list-style-image: url('assets/images/cross.png')">15 января 2015 - не подходит, т.к. не рядом с 14 марта 2013. Обратите внимание, что точное значение здесь находится на усмотрении системы.</li>
    </ul>
   </td>
  </tr>
</table>
<p>
Другие примечания:
<!-- Other notes: -->
</p>
<ul>
 <li>Когда параметр даты указан не полностью, совпадения с ним основываются на поведении интервалов, где:
 <!-- When the date parameter is not fully specified, matches against it are based on the behavior of intervals, where: -->
	<ul>
		<li>Даты, где указан только год, эквивалентны интервалу, который начинается в первое мгновение 1го января до последнего мгновения 31го декабря, например 2000 эквивалентно интервалу [2000-01-01T00:00, 2000-12-31T23:59]
    <!-- Dates with only the year specified are equivalent to an interval that starts at the first instant of January 1st to the last instant of December 31st, e.g. 2000 is equivalent to an interval of [2000-01-01T00:00, 2000-12-31T23:59]. --></li>
		<li>Даты, где указан год и месяц, эквивалентны интервалу, который начинается в первое мгновение первого дня месяца и заканчивается в последнее мгновение последнего дня этого месяца, например 2000-04 эквивалентно интервалу [2000-04-01T00:00, 2000-04-30T23:59].
    <!-- Dates with the year and month are equivalent to an interval that starts at the first instant of the first day of the month and ends on the last instant of the last day of the month, e.g. 2000-04 is equivalent to an interval of [2000-04-01T00:00, 2000-04-30T23:59]. --></li>
	</ul>
 </li>
 <li>Везде, где это возможно, система должна корректировать часовые пояса при совершении запросов. Даты не имеют часовых поясов, и часовые пояса не должны учитываться. Там, где и параметр поиска, и дата время элемента ресурса не имеют часового пояса, им следует присваивать локальный часовой пояс сервера.
 <!-- Where possible, the system should correct for timezones when performing queries. Dates do not have time zones, and time zones
   should not be considered. Where both search parameters and resource element date times do not have time zones, the servers local
   time zone should be assumed. -->
 </li>
</ul>
<p>
Чтобы найти все процедуры в модуле patient, которые произошли за двухлетний период:
<!-- To search for all the procedures in a patient compartment that occurred over a 2 year period: -->
</p>
<pre>
 GET [base]/Patient/23/Procedure?date=ge2010-01-01&amp;date=le2011-12-31
</pre>


<a name="string"> </a>
<h4>string</h4>
<p>
Для простого текстового поиска строковый параметр служит как входные данные для регистронезависимого и нечувствительного к диакритическим знакам поиска по последовательностям символов.
По умолчанию, поле соответствует строковому запросу, если значение этого поля равно или начинается со значения указанного параметра, после того как они оба были приведены к одному регистру и диакритическим знакам. Модификатор <code>:contains</code> возвращает результаты. которые включают в себя значение указанного параметра в любом месте в пределах области поиска. Модификатор <code>:exact</code> возвращает результаты, которые соответствуют указанному параметру полностью, включая регистр и диакритические знаки.
<!-- For a simple string search, a string parameter serves as the input for a case- and accent-insensitive search against sequences of characters. 
By default, a field matches a string query 
if the value of the field equals or starts with the supplied parameter value, after 
both have been normalized by case and accent. The <code>:contains</code> modifier 
returns results that include the supplied parameter value anywhere within the field 
being searched. The <code>:exact</code> modifier returns results that match 
the entire supplied parameter, including casing and accents. -->
</p>
<p>
Примеры:
<!-- Examples: -->
</p>
<table class="grid">
 <tr><td><code>[base]/Patient?given=eve</code></td><td>Все пациенты с именем, содержащим заданную часть "eve" в начале имени. Сюда войдут пациенты с (given) именами "Eve", "Evelyn".</td></tr>
 <tr><td><code>[base]/Patient?given:contains=eve</code></td><td>Все пациенты с именем, содержащим заданную часть "eve" в любом месте имени. Сюда войдут пациенты с (given) именами "Eve", "Evelyn", а также "Severine".</td></tr>
 <tr><td><code>[base]/Patient?given:exact=Eve</code></td><td>Все пациенты с именем с заданной частью в точности "Eve". Примечание: сюда не войдут пациенты с (given) именами "eve" или "EVE".</td></tr>
<!--  <tr><td><code>[base]/Patient?given=eve</code></td><td>Any patients with a name containing a given part with "eve" at the start of the name. This would include patients with the given name "Eve", "Evelyn".</td></tr>
 <tr><td><code>[base]/Patient?given:contains=eve</code></td><td>Any patients with a name with a given part containing "eve" at any position. This would include patients with the given name "Eve", "Evelyn", and also "Severine".</td></tr>
 <tr><td><code>[base]/Patient?given:exact=Eve</code></td><td>Any patients with a name with a given part that is exactly "Eve". Note: This would not include patients with the given name "eve" or "EVE".</td></tr> -->
</table>
<p>
 Дополнительный модификатор <code>:text</code> можно использовать для указания поиска с расширенными возможностями управления текста (см. <a href="#text">ниже</a>), однако такую возможность предлагает только несколько серверов.
<!-- An additional modifier <code>:text</code>
can be used to specify a search with advanced text handling (see <a href="#text">below</a>)
though only a few servers are expected to offer this facility. -->
</p>
<p>
Когда строковый параметр поиска ссылается на типы <a href="datatypes.html#HumanName">HumanName</a> и <a href="datatypes.html#Address">Address</a>, поиск идёт по элементам типа "string" и не охватывает такие элементы, как <code>use</code> и <code>period</code>. Для надёжности, сервер должен искать по элементам фамилии независимо. Например оба поиска по фамилии Carreno и по фамилии Quinones должны вернуть пациента с фамилией "Carreno Quinones". Филиалы HL7 могут вводить особые рекомендации по работе поиска в соответствии с культурой их страны.
<!-- When a string search parameter refers to the types <a href="datatypes.html#HumanName">HumanName</a> and <a href="datatypes.html#Address">Address</a>,
the search covers the elements of type string, and does not cover elements such as <code>use</code> and <code>period</code>.
For robust search, servers should search the parts of a family name independently.
E.g. Searching either Carreno or Quinones should match a family name of "Carreno Quinones".
HL7 affiliates may make more specific recommendations about how search should work 
in their specific culture. -->
</p>
<p>
Решение о том, делать ли предварительную обработку имен, адресов и контактной информации для удаления символов-разделителей до нахождения соответствия, чтобы гарантировать непротиворечивое поведение, остаётся на усмотрение сервера. Например сервер мог бы удалить все пробелы и символы  <code>-</code> из телефонных номеров. Что лучше всего подходит, варьируется в зависимости от культуры и контекста.
<!-- It is at the discretion of the server whether to pre-process names, addresses,
and contact details to remove separator characters prior to matching in order
to ensure more consistent behavior. For example, a server might remove all
spaces and <code>-</code> characters from phone numbers. What is most appropriate varies
depending on culture and context. -->

Сервер может также использовать свободный текстовый поиск по этому свойству для достижения наилучших результатов. При поиске по целому имени и адресу (не по их частям), сервер может также использовать гибкое соответствие или свободный текстовый поиск по именам для достижения наилучших результатов.
<!-- A server may also use a free-text style searches on this property to achieve the best results
When searching whole names and addresses (not parts), servers may also use flexible match 
or a free-text style searches on names to achieve the best results. -->
</p>

<!--
A server defined search (link to search page) that may consider matching any of the string fields in the HumanName, including family, give, prefix, suffix, suffix, and/or text
 -->
<a name="uri"> </a>
<h4>uri</h4>
<p>
Параметр URI относится к элементу URI (<a href="https://tools.ietf.org/html/rfc3986">RFC 3986</a>). 
Совпадения являются точными (регистр, диакритические знаки, экранирование), и весь URI целиком должен совпадать. С помощью модификатора  <code>:above</code> или <code>:below</code> можно указать, что используется частичное совпадение. Например:
<!-- The uri parameter refers to a URI (<a href="https://tools.ietf.org/html/rfc3986">RFC 3986</a>) element.
Matches are precise (e.g. case, accent, and escape) sensitive, and the entire URI must match. 
The modifier <code>:above</code> or <code>:below</code> can be used to indicate
that partial matching is used. For example: -->
</p>
<pre>
 GET [base]/ValueSet?url=http://acme.org/fhir/ValueSet/123
 GET [base]/ValueSet?url=http://acme.org/fhir/
 GET [base]/ValueSet?url=urn:oid:1.2.3.4.5
</pre>
<p>
Первый запрос - поиск набора значений с точным URL "http://acme.org/fhir/ValueSet/123". 
Второй запрос вернет все наборы значений, у которых URL начинается с "http://acme.org/fhir/".
Обратное утверждение - поиск всех наборов значений, кроме данного конкретного URL - может пригодиться для поиска систем назначения имён, но не так полезно, чем поиск с <code>:below</code>.
<!-- The first line is a request to find any value set with the exact url "http://acme.org/fhir/ValueSet/123". 
The second line performs a search that will return any value sets that have a URL that starts with "http://acme.org/fhir/".
The converse - the search for any value set above a given specific URL.  This approach may be useful for searching
name systems, but it is generally less useful than the <code>:below</code> search.  -->
На третьей строке показан пример поиска по OID. Отметьте, что модификаторы :above и :below применяются только к URL-ссылкам, а не к URN-именам (т.е. к OID не применяются).
<!-- The third line shows an 
example of searching by an OID. Note that the :above and :below modifiers only apply to URLs, and not URNS such as 
OIDs. -->
</p>
<p>
Отметьте, что для <a href="references.html#canonical">канонических URL-ссылок</a> сервер ДОЛЖЕН поддерживать поиск по каноническим URL-ссылкам, ДОЛЖЕН автоматически обнаруживать в них часть <code>|[version]</code> и интерпретировать её как поиск по версии.
<!-- Note that for <a href="references.html#canonical">Canonical URLs</a>, servers SHOULD support searching by
Canonical URL, and SHOULD support automatically detecting a <code>|[version]</code> portion as part of the 
Canonical URL, and interpreting that portion as a search on the version. -->
</p>

<a name="token"> </a>
<h4>token</h4>
<p>
Тип "токен" - это параметр для поиска точного соответствия по строке символов, потенциально ограниченный некоторым URI. Используется в основном для типов данных code и identifier, где значение может иметь URI, который ограничивает его значение, где поиск выполняется по паре из Coding или Identifier. Токены также часто используют для поиска по другим полям, когда требуется точное соответствие - это URI, булевы значения и <a href="datatypes.html#ContactPoint">ContactPoints</a>. В этих случаях часть параметра для поиска по URI не используется. 
<!-- A token type is a parameter that provides an exact match search, either on a string of characters, potentially 
scoped by a URI. It is mostly used against a code or identifier data type where the value may have a
URI that scopes its meaning, where the search is performed against the  pair from a Coding or an 
Identifier. Tokens are also used against other fields where exact matches are required - uris,
booleans, and <a href="datatypes.html#ContactPoint">ContactPoints</a>. In these cases, the URI portion is not used. -->
</p>
<p>
Поиск совпадения по токену должен быть буквальным (например не на основе <a href="codesystem.html#subsumption">отнесения к определённой категории</a> или других особенностей использования кодовых систем), но не чувствительным к регистру. Для поиска с применением логики классификации используйте модификаторы ниже или перечисляйте все коды в иерархии. Синтаксис для такого значения будет одним из следующих:
<!-- For tokens, matches are literal (e.g. not based on <a href="codesystem.html#subsumption">subsumption</a> or other code system features), 
but not case sensitive. To use subsumption based logic, use the modifiers below, or list 
all the codes in the heirarchy. The syntax for the value is one of the following: -->
</p>
<ul>
 <li><b><code>[parameter]=[code]</code></b>: значение <code>[code]</code> совпадает с Coding.code или Identifier.value не зависимо от значения свойства "system"</li>
 <li><b><code>[parameter]=[system]|[code]</code></b>: значение <code>[code]</code> совпадает с Coding.code или Identifier.value, а значение <code>[system]</code> совпадает со значением свойства "system" в Identifier или Coding</li>
 <li><b><code>[parameter]=|[code]</code></b>: значение <code>[code]</code> совпадает с Coding.code или Identifier.value, а Coding/Identifier не содержит свойства "system"</li>
 <li><b><code>[parameter]=[system]|</code></b>: любой элемент, в котором значение <code>[system]</code> совпадает со свойством "system" Identifier или Coding</li>
</ul>
<p>
Примечание: URI и код пространства имен необходимо корректно <a href="#escaping">экранировать</a>.
<!-- Note: The namespace URI and code both must be <a href="#escaping">escaped</a> correctly. -->
Если систему указать невозможно (например это элемент типа <a href="datatypes.html#uri">uri</a>), тогда используется просто форма [parameter]=[code].
<!-- If a system is not applicable (e.g. an element of type <a href="datatypes.html#uri">uri</a>,
then just the form [parameter]=[code] is used. -->
</p>
<p>
Параметры поиска по лексемам используются для следующих типов данных:
<!-- Token search parameters are used for the following data types: -->
</p>
<table class="lines">
 <tr>
  <td><b>Тип данных</b></td>
  <td><b>URI</b></td>
  <td><b>Код</b></td>
  <td><b>Комментарий</b></td>
 </tr>
 <tr>
  <td><a href="datatypes.html#Coding">Coding</a></td>
  <td>Coding.system</td>
  <td>Coding.code</td>
  <td></td>
 </tr>
 <tr>
  <td><a href="datatypes.html#CodeableConcept">CodeableConcept</a></td>
  <td>CodeableConcept.coding.system</td>
  <td>CodeableConcept.coding.code</td>
  <td>Поиск совпадений по всем coding в CodeableConcept<!-- Matches against any coding in the CodeableConcept --></td>
 </tr>
 <tr>
  <td><a href="datatypes.html#Identifier">Identifier</a></td>
  <td>Identifier.system</td>
  <td>Identifier.value</td>
  <td></td>
 </tr>
 <tr>
  <td><a href="datatypes.html#Identifier">ContactPoint</a></td>
  <td>ContactPoint.use</td>
  <td>ContactPoint.value</td>
  <td>The use is prepended by <a href="valueset-contact-point-system.html">http://hl7.org/fhir/contact-point-system</a>/<!-- The use is prepended by <a href="valueset-contact-point-system.html">http://hl7.org/fhir/contact-point-system</a>/ --></td>
 </tr>
 <tr>
  <td><a href="datatypes.html#code">code</a></td>
  <td>(implicit)</td>
  <td>code</td>
  <td>система определена в наборе значений (хотя обычно не требуется)<!-- the system is defined in the value set (though it's not usually needed) --></td>
 </tr>
 <tr>
  <td><a href="datatypes.html#boolean">boolean</a></td>
  <td>(implicit)</td>
  <td>boolean</td>
  <td>Неявно это система <a href="valueset-special-values.html">http://hl7.org/fhir/special-values</a><!-- The implicit system is <a href="valueset-special-values.html">http://hl7.org/fhir/special-values</a> --></td>
 </tr>
 <tr>
  <td><a href="datatypes.html#string">string</a></td>
  <td>n/a</td>
  <td>string</td>
  <td>Токен иногда используют для поиска по строкам, чтобы указать поиск по точному соответствию как корректную стратегию по умолчанию<!-- Token is sometimes used for string to indicate that exact matching is the correct default search stategy --></td>
 </tr>
</table>
<p>
Примечание: Использование параметров поиска по лексемам для булевых полей: булевы значения "true" и "false" также представлены в виде формальных кодов в кодовой системе <a href="valueset-special-values.html">Special Values</a>, которая полезна, когда булевы значения нужно представить в виде типа данных <a href="datatypes.html#coding">Coding</a>. Пространство имён для этих кодов - http://hl7.org/fhir/special-values, однако обычно нет причин использовать это, поскольку достаточно и простых значений true или false.
<!-- Note: The use of token search parameters for boolean fields: the boolean values "true" and "false" are also represented
as formal codes in the <a href="valueset-special-values.html">Special Values</a> code system, which is useful when boolean values 
need to be represented in a <a href="datatypes.html#coding">Coding</a> data type. The namespace for these codes is 
http://hl7.org/fhir/special-values, though there is usually no reason to use this, as a simple true or false is sufficient. -->
</p>

<p><b>Модификаторы<!-- Modifiers -->:</b></p>
<table class="lines">
 <tr> <td><b>Модификатор</b></td> <td><b>Применение</b></td> </tr>
 <tr> <td><code>:text</code></td> <td>Этот параметр поиска обрабатывается как строка поиска по тексту, ассоциированному с кодом/значением - <i>CodeableConcept.text</i>, <i>Coding.display</i>, либо <i>Identifier.type.text</i>.</td> </tr>
 <tr> <td><code>:not</code></td> <td>Изменяет на противоположное совпадение по коду, описанное в параграфе выше. Note that this includes resources that have no value for the parameter - e.g. ?gender:not=male includes all patients that do not have gender = male, including patients that do not have a gender at all</td> </tr>
 <tr> <td><code>:above</code><a name="subsumption"> </a></td> <td>Параметром поиска является концепт с формой <code>[system]|[code]</code>, и он проверяет, включает ли (<a href="codesystem.html#subsumption">subsumes</a>) кодинг в ресурсе указанный в поиске код. Например поисковый концепт имеет связь "is-a" с кодингом в ресурсе, и сюда входит сам кодинг.</td> </tr>
 <tr> <td><code>:below</code></td> <td>Параметром поиска является концепт с формой <code>[system]|[code]</code>, и он проверяет, относится ли кодинг в ресурсе к указанному в поиске коду. Например кодинг в ресурсе имеет связь "is-a" с поисковым концептом, и сюда входит сам кодинг.</td> </tr>
 <tr> <td><code>:in</code></td> <td>Параметром поиска является URI (относительный или абсолютный), который идентифицирует набор значений, и поисковый параметр проверяет, входит ли кодинг в указанный <a href="valueset.html">набор значений</a>. Ссылка может быть буквальной (адрес, где находится этот набор значений) или логической (ссылка на ValueSet.identifier). Если сервер может обработать эту ссылку как буквальный URL, он это делает, иначе пытается найти соответствие в известных логических значениях ValueSet.url.</td> </tr>
 <tr> <td><code>:not-in</code></td> <td>Параметром поиска является URI (относительный или абсолютный), который идентифицирует набор значений, и поисковый параметр проверяет, что кодинг не входит в указанный набор значений.</td> </tr>
</table>
<p>
Большинство серверов будут обрабатывать только заранее известные/зарегистрированные/поддерживаемые внутренние наборы значений. Однако серверы по выбору могут принимать любые валидные ссылки на наборы значений.
Серверы по выбору могут учитывать таблицы соответствий концептов при проверке связей категоризации (отнесения объекта к определённой категории).
<!-- Most servers will only process value sets that are already known/registered/supported internally.
However, servers can elect to accept any valid reference to a value set.
Servers may elect to consider concept mappings when testing for subsumption relationships. -->
</p>

<p>
Примеры запросов:
<!-- Example searches: -->
</p>
<table>
 <tr><td width="50%"><b>Поиск</b></td><td><b>Описание</b></td></tr>
 <tr><td><pre> GET [base]/Patient?identifier=http://acme.org/patient|2345</pre></td><td>Search for all the patients with an identifier with key = "2345" in the system "http://acme.org/patient"</td></tr>
 <tr><td><pre> GET [base]/Patient?gender=male</pre></td><td>Search for any patient with a gender that has the code "male"</td></tr>
 <tr><td><pre> GET [base]/Patient?gender:not=male</pre></td><td>Search for any patient with a gender that does not have the code "male"</td></tr>
 <tr><td><pre> GET [base]/Patient?active=true</pre></td><td>Search for any patients that are active</td></tr>
 <tr><td><pre> GET [base]/Condition?code=http://acme.org/conditions/codes|ha125</pre></td><td>Search for any condition with a code "ha125" in the code system "http://acme.org/conditions/codes"</td></tr>
 <tr><td><pre> GET [base]/Condition?code=ha125</pre></td><td>Search for any condition with a code "ha125". Note that there is not often any useful overlap in literal symbols between code systems, so the previous example is generally preferred </td></tr>
 <tr><td><pre> GET [base]/Condition?code:text=headache</pre></td><td>Search for any Condition with a code that has a text "headache" associated with it (either in the text, or a display)</td></tr>
 <tr><td><pre> GET [base]/Condition?code:in=http%3A%2F%2Fsnomed.info%2Fsct%3Ffhir_vs%3Disa%2F126851005</pre></td><td>Search for any condition in the SNOMED CT value set "http://snomed.info/sct?fhir_vs=isa/126851005" that includes all descendants of "Neoplasm of liver"</td></tr>
 <tr><td><pre> GET [base]/Condition?code:below=126851005</pre></td><td>Search for any condition that is subsumed by the SNOMED CT Code "Neoplasm of liver". Note: This is the same outcome as the previous search</td></tr>
 <tr><td><pre> GET [base]/Condition?code:in=http://acme.org/fhir/ValueSet/cardiac-conditions</pre></td><td>Search for any condition that is in the institutions list of cardiac conditions</td></tr>
</table>


<a name="quantity"> </a>
<h4>quantity</h4>
<p>
Параметр quantity ищет по типу данных <a href="datatypes.html#Quantity">Quantity</a>. Синтаксис для значения соответствует следующей форме:
<!-- A quantity parameter searches on the <a href="datatypes.html#Quantity">Quantity</a> data type.
The syntax for the value follows the form: -->
</p>
<ul>
 <li><b>[parameter]=[prefix][number]|[system]|[code]</b> соответствует количеству с заданными единицами измерения<!-- matches a quantity with the given unit --></li>
</ul>
<p>
Префикс является необязательным и, как описано <a href="#prefix">выше</a>, зависит от того, как интерпретируются точность и  операторы сравнения/диапазона. Примеры поиска:
<!-- The prefix is optional, and is as described <a href="#prefix">above</a>, both regarding how precision and comparator/range operators are interpreted. Example searches: -->
</p>

<table>
 <tr><td width="50%"><b>Поиск</b></td><td><b>Описание</b></td></tr>
 <tr><td><pre> GET [base]/Observation?value=5.4|http://unitsofmeasure.org|mg</pre></td><td>Search for all the observations with a value of 5.4 mg where mg is understood as a UCUM unit (<code>system</code>/<code>code</code>)</td></tr>
 <tr><td><pre> GET [base]/Observation?value=5.4||mg</pre></td><td>Search for all the observations with a value of 5.4 mg where the unit - either the code or the stated human unit (<code>unit</code>) are "mg"</td></tr>
 <tr><td><pre> GET [base]/Observation?value=le5.4|http://unitsofmeasure.org|mg</pre></td><td>Search for all the observations where the value of is less than 5.4 mg where mg is understood as a UCUM unit</td></tr>
 <tr><td><pre> GET [base]/Observation?value=ap5.4|http://unitsofmeasure.org|mg</pre></td><td>Search for all the observations where the value of is about 5.4 mg where mg is understood as a UCUM unit</td></tr>
</table>

<p>
Поисковый процессор может решить выполнить поиск, основанный на <a href="datatypes.html#quantity">канонических единицах измерений</a> (например любое значение, которое может быть преобразовано в значение в миллиграммах, для случая выше).
<!-- The search processor may choose to perform a search based on <a href="datatypes.html#quantity">canonical units</a> (e.g. any value where the units can be converted to a value in mg in the case above). -->
</p>


<a name="reference"> </a>
<h4>reference</h4>
<p>
Ссылочный параметр относится к <a href="references.html">ссылкам между ресурсами</a>. Например найти все Conditions, где объектом ссылки является определённый пациент, где пациент выбирается по имени или идентификатору. Интерпретация параметра <i>ссылка</i> одна из двух:
<!-- A reference parameter refers to <a href="references.html">references between resources</a>.  For example, find all
Conditions where the subject reference is a particular patient, where the patient is selected by name or identifier.
The interpretation of a <i>reference</i> parameter is either: -->
</p>
<ul>
 <li><b><code>[parameter]=[id]</code></b> the logical [id] of a resource using a local reference (i.e. a relative reference)</li>
 <li><b><code>[parameter]=[type]/[id]</code></b> the logical [id] of a resource of a specified type using a local reference (i.e. a relative reference), 
   for when the reference can point to different types of resources (e.g. <a href="observation-definitions.html#Observation.subject">Observation.subject</a>)</li>
 <li><b><code>[parameter]=[url]</code></b> where the [url] is an absolute URL - a reference to a resource by its absolute location</li>
</ul>
<p>
Примечание: относительная ссылка, разрешаемая в то же значение, что и указанный абсолютный URL-адрес, либо наоборот, также считается совпадением.
К примеру, если значением параметра поиска является Patient/123, тогда будут найдены подобные ссылки:
<!-- Note: A relative reference resolving to the same value as a specified absolute URL, or vice versa, qualifies as a match.
For example, if the search parameter value is Patient/123, then this will find references like this:  -->
</p>
<pre>
 &lt;patient&gt;
   &lt;reference value=&quot;Patient/123&quot;/&gt;
 &lt;/patient&gt;
</pre>
<p>
Если базовый адрес сервера http://example.org/fhir, тогда полный URL-адрес для этой ссылки будет ttp://example.org/fhir/Patient/123, что означает, что условию поиска будут соответствовать такие ссылки, как:
<!-- If the server base address is http://example.org/fhir, then the full URL for that reference is 
http://example.org/fhir/Patient/123, which means that the search term also matches patient
references like this: -->
</p>
<pre>
 &lt;patient&gt;
   &lt;reference value=&quot;http://example.org/fhir/Patient/123&quot;/&gt;
 &lt;/patient&gt;
</pre>
<p>
Кроме того, поиск <code>reference=http://example.org/fhir/Patient/123</code> соответствует обеим ссылкам.
<!-- In addition, searching for <code>reference=http://example.org/fhir/Patient/123</code> will also 
match both references. -->
</p>
<p>
Некоторым ссылкам можно указывать на более чем один тип ресурса; например subject : Reference(Patient|Group|Device|..).
В этом случае несколько ресурсов могут иметь одинаковый логический идентификатор. Серверы ДОЛЖНЫ отклонять поиск, где логический идентификатор ссылается более чем на один соответствующий поиску ресурс среди различных типов. Для того чтобы дать возможность клиенту выполнять поиск в таких ситуациях, тип указывается явно:
<!-- Some references are allowed to point to more than one type of resource; e.g. subject : Reference(Patient|Group|Device|..).
In these cases, multiple resources may have the same logical identifier. Servers SHOULD reject a search where 
the logical id refers to more than one matching resource across different types.
In order to allow the client to perform a search in these situations the type is specified explicitly: -->
</p>
<pre>
 GET [base]/Observation?subject=Patient/23
</pre>
<p>
Это запрос возвращает все ресурсы observations, у которых "subject" ведёт на ресурс Patient с логическим идентификатором "23". Также определён модификатор, чтобы клиенты могли явно указывать нужный тип:
<!-- This searches for any observations where the subject refers to the patient resource with the
logical identifier "23". A modifier is also defined to to allow the client to be explicit 
about the intended type: -->
</p>
<pre>
 GET [base]/Observation?subject:Patient=23
</pre>
<p>
Этот запрос возвращает те же результаты, что и предыдущий. Модификатор становится полезным, когда используется в цепочечных запросах, о которых будет рассказано в следующем разделе. Примечание: модификатор <code>[type]</code> нельзя использовать со ссылкой на ресурс, расположенный на другом сервере, поскольку серверу обычно не известно, какой тип имеет этот ресурс. Однако, поскольку это абсолютные ссылки, не может возникнуть неоднозначность относительно типа.
<!-- This has the same effect as the previous search. The modifier becomes useful when used with chaining
as explained in the next section. Note: The <code>[type]</code> modifier can't be used with a reference to a resource found on another server, 
since the server would not usually know what type that resource has.  However, since these are absolute references, 
there can be no ambiguity about the type. -->
</p>
<p>
В некоторых случаях параметры поиска определены неявно областью действия. К примеру, в ресурсе <a href="observation.html"><code>Observation</code></a> есть элемент <code>subject</code>, это ссылка на один из нескольких типов. Этому элементу соответствует параметр поиска <code>subject</code>, который ищет по любому из возможных типов. Кроме этого, есть другой параметр поиска <code>patient</code>, который ищет по элементу <code>Observation.subject</code>, но ограничен ссылками только типа <a href="patient.html"><code>Patient</code></a>. При использовании параметра поиска patient нет необходимости указывать модификатор ":Patient" или добавлять "Patient/" к строке поиска, т.к. это условие и так будет соблюдено.
<!-- In some cases, search parameters are defined with an implicitly limited scope. For example,
<a href="observation.html"><code>Observation</code></a> has an element <code>subject</code>, which is 
a reference to one of a number of types. This has a matching search parameter <code>subject</code>,
which refers to any of the possible types. In addition to this, there is another search parameter
<code>patient</code>, which also refers to <code>Observation.subject</code>, but is limited to
only include references of type <a href="patient.html"><code>Patient</code></a>. When using
the patient search parameter, there is no need to specify ":Patient" as a modifier, or "Patient/"
in the search value, as this must always be true. -->
</p>

<a name="chaining"> </a>
<h4>Цепочечные параметры<!-- Chained parameters --></h4>
<p>
Чтобы избавить клиента от необходимости выполнять серию операций поиска, ссылочные параметры могут быть "сцеплены" (объединены в последовательность) добавлением к ним точки <code>.</code>, за которой следует имя параметра поиска, указанного для целевого ресурса. Это может быть сделано рекурсивно, следуя логическому пути через граф связанных ресурсов, разделенных точкой <code>.</code>. К примеру дано, что ресурс <a href="diagnosticreport.html">DiagnosticReport</a> 
имеет параметр поиска с именем <i>subject</i>, который обычно является ссылкой на ресурс <a href="patient.html">Patient</a>, и этот ресурс Patient содержит параметр <i>name</i>, который ищет по имени пациента, тогда поиск вида
<!-- In order to save a client from performing a series of search operations,
reference parameters may be "chained" by appending them with
a period (<code>.</code>) followed by the name of a search parameter defined for the target
resource. This can be done recursively, following a logical path
through a graph of related resources, separated by <code>.</code>.
For instance, given that
the resource <a href="diagnosticreport.html">DiagnosticReport</a>
has a search parameter named <i>subject</i>, which is usually a
reference to a <a href="patient.html">Patient</a> resource, and
the Patient resource includes a parameter <i>name</i> which
searches on patient name, then the search -->
</p>
<pre>
 GET [base]/DiagnosticReport?subject.name=peter
</pre>
<p>
- это запрос на возвращение всех лабораторных отчетов, в которых имеется объект, чье имя содержит "peter". Так как  объект Diagnostic Report может быть одним из набора различных ресурсов, необходимо ограничить поиск определенным типом:
<!-- is a request to return all the lab reports that have a subject whose name includes "peter". Because
the Diagnostic Report subject can be one of a set of different resources, it's necessary to limit
the search to a particular type: -->
</p>
<pre>
 GET [base]/DiagnosticReport?subject:Patient.name=peter
</pre>
<p>
Этот запрос возвращает все лабораторные отчеты, имеющие в качестве объекта пациента, чье имя содержит "peter".
<!-- This request returns all the lab reports that have a subject which is a patient, whose name includes "peter". -->
</p>

<p>
Примечание к расширенным возможностям поиска:
Когда цепочечный параметр ищет ссылку на ресурс, целевым объектом которой может быть более одного типа ресурса, цепочка параметров может оканчиваться ссылкой на поисковые параметры с тем же самым именем на более чем одном типе ресурса одновременно. Серверы ДОЛЖНЫ отклонять поиск, в котором логический идентификатор ведёт на более чем один совпадающий ресурс среди различных типов. Например клиент должен указать тип явным образом, используя синтаксис во втором примере выше. 
<!-- Advanced Search Note:
Where a chained parameter searches a resource reference that may have more than one
type of resource as its target, the parameter chain may end up referring
to search parameters with the same name on more than one kind of resource at once.
Servers SHOULD reject a search where the logical id refers to more than one matching 
resource across different types.  For example, the client has to specify the type explicitly 
using the syntax in the second example above. -->
</p>

<a name="has"> </a>
<h4>Reverse Chaining</h4>

<p>
The _has parameter provides limited support for reverse chaining - that is, selecting 
resources based on the properties of resources that refer to them (instead of chaining,
above, where resources can be selected based on the properties of resources that they
refer to). Here is an example of the _has parameter:
</p>
<pre>
GET [base]/Patient?_has:Observation:patient:code=1234-5
</pre>
<p>
This requests the server to return Patient resources, where the patient resource is 
referred to by at least one Observation where the observation has a code of 1234, and
where the Observation refers to the patient resource in the patient search parameter.
</p>
<p>
"Or" searches are allowed (e.g. GET [base]/Patient?_has:Observation:subject:code=123,456), and multiple _has 
parameters are allowed (e.g. GET [base]/Patient?_has:Observation:subject:code=123&amp;_has:Observation:subject:code=456).
Note that each _has parameter is processed independently of other _has parameters.
</p>
<p>
The _has parameter can be chained, like this:
</p>
<pre>
GET [base]/Patient?_has:Observation:patient:_has:AuditEvent:entity:user=MyUserId
</pre>
<p>
Fetch all the patients that have an Observation where the observation has an audit event from a specific user.
</p>

<a name="composite"> </a>
<a name="combining"> </a>
<h4>Составные параметры поиска<!-- Composite Search Parameters --></h4>
<p>
Составные параметры поиска поддерживают объединение отдельных значений с помощью <code>$</code>. Например результатом операции поиска будет пересечение ресурсов, которые соответствуют критериям каждого поискового параметра по отдельности. Если параметр повторяется, например <code>/Patient?language=FR&amp;language=NL</code>, тогда это соответствует пациенту, который говорит на обоих языках. Этот параметр поиска называется "AND", поскольку предполагается, что сервер вернёт только те результаты, которые соответствуют обоим значениям.
<!-- Composite search parameters supports joining single values with a <code>$</code>. For example, the result 
of the search operation is the intersection of the resources that match the criteria specified by each
individual search parameter. If a parameter repeats, such as <code>/Patient?language=FR&amp;language=NL</code>, then
this matches a patient who speaks both languages. This is known as an AND search parameter, since the
server is expected to respond only with results which match both values. -->
</p>
<p>
Если вместо этого поиск должен найти пациентов, которые говорят на одном из этих языков, тогда это будет один параметр с несколькими значениями, разделёнными запятой <code>,</code>. Например <code>/Patient?language=FR,NL</code>. Этот параметр поиска называется "OR", поскольку предполагается, что сервер вернёт результаты, которые соответствуют одному из значений.
<!-- If, instead, the search is to find patients that speak either
language, then this is a single parameter with multiple values, separated by a <code>,</code>.
For example, <code>/Patient?language=FR,NL</code>. This is known as an OR search parameter,
since the server is expected to respond with results which match either value. -->
</p>
<p>
AND и OR параметры можно комбинировать, например <code>/Patient?language=FR,NL&amp;language=EN</code> относится к любому пациенту, который говорит по-английски, а также по-французски или по-голландски.
<!-- AND parameters and OR parameters may also be combined, for example:
<code>/Patient?language=FR,NL&amp;language=EN</code> would refer to any patient who speaks
English, as well as either French or Dutch. -->
</p>
<p>
Такой подход позволяет использовать простые комбинации AND/OR-значений, но не даёт возможности поиска на основе пар значений, например все наблюдения со значением натрия >150 ммоль/л (особенно в качестве последнего критерия цепочечного поиска), или поиск по Group.characteristic, где вам нужно найти комбинацию ключ/значение, а не пересечение отдельных совпадений по ключу и значению. Другим примером будут пространственные координаты при выполнении географических поисков.
<!-- This approach allows for simple combinations of and/or values, but doesn't allow a search based on
a pair of values, such as all observations with a sodium value >150 mmol/L (particularly
as the end criteria of a chained search), or searching on Group.characteristic where you need
find a combination of key/value, not an intersection of separate matches on key and value.
Another example is spatial coordinates when doing geographical searches. -->
</p>
<p>
Чтобы подобные поиски были возможны, ресурс может также указать <i>составные</i> параметры, которые принимают последовательности отдельных значений, которые соответствуют другим заданным параметрам в качестве аргумента. Соответствующий параметр каждого компонента в такой последовательности документируется в определении этого параметра. Эти последовательности формируются присоединением отдельных значений символом <code>$</code>. Примечание: эта последовательность является отдельным значением и сама может состоять из набора значений, чтобы, к примеру, несколько соответствующих параметров в состоянии на сегодняшнюю дату можно было указать как <code>state-on-date=new$2013-05-04,active$2013-05-05</code>.
<!-- To allow these searches, a resource may also specify <i>composite</i> parameters
that take sequences of single values that match other defined parameters as an
argument. The matching parameter of each component in such a sequence
is documented in the definition of the parameter. These sequences are formed by
joining the single values with a <code>$</code>.  Note: This sequence is a single
value and itself can be composed into a set of values, so that, for example,
multiple matching state-on-date parameters can be specified as
<code>state-on-date=new$2013-05-04,active$2013-05-05</code>. -->
</p>
<p>
Примечание: модификаторы в составных параметрах не используются.
<!-- Note: Modifiers are not used on composite parameters. -->
<!--
Future note: use \p and \m in search values? if we add a double = to parameter value for text, that would get rid 
of <code>:exact</code>.
Won't try to get rid of type modifier - that's the real use for modifiers because it has to be in a chaining line. 
Other modifier is <code>:text</code> on token - use "~"? or ""?
-->
</p>

<p>
Примеры использования составных параметров:
<!-- Examples of using composite parameters: -->
</p>

<table>
 <tr><td width="50%"><b>Запрос</b></td><td><b>Описание</b></td></tr>
 <tr><td><pre> GET [base]/DiagnosticReport?result.code-value-quantity=http://loinc.org|2823-3$gt5.4|http://unitsofmeasure.org|mmol/L</pre></td><td>Поиск всех диагностических отчётов, которые содержат наблюдение со показателем калия >5.4 ммоль/л (UCUM)</td></tr>
 <tr><td><pre> GET [base]/Observation?component-code-value-quantity=http://loinc.org|8480-6$lt60</pre></td><td>Поиск всех наблюдений с показателем систолического кровяного давления &lt; 60. Отметьте, что в этом случае единицы измерения предполагаются (все используют мм рт. ст.)</td></tr>
 <tr><td><pre> GET [base]/Group?characteristic-value=gender$mixed</pre></td><td>Поиск всех групп с характеристикой "gender", имеющей текстовое значение "mixed"</td></tr>
<!--  <tr><td width="50%"><b>Search</b></td><td><b>Description</b></td></tr>
 <tr><td><pre> GET [base]/DiagnosticReport?result.code-value-quantity=http://loinc.org|2823-3$gt5.4|http://unitsofmeasure.org|mmol/L</pre></td><td>Search for all diagnostic reports that contain on observation with a potassium value of >5.4 mmol/L (UCUM)</td></tr>
 <tr><td><pre> GET [base]/Observation?component-code-value-quantity=http://loinc.org|8480-6$lt60</pre></td><td>Search for all the observations with a systolic blood pressure &lt; 60. Note that in this case, the unit is assumed (everyone uses mmHg)</td></tr>
 <tr><td><pre> GET [base]/Group?characteristic-value=gender$mixed</pre></td><td>Search for all groups that have a characteristic "gender" with a text value of "mixed"</td></tr> -->
</table>

<a name="missing"> </a>
<h4>Handling Missing Data</h4>
<p>
Consider the case of searching for all AllergyIntolerance resources:
</p>
<pre>
GET [base]/AllergyIntolerance?clinical-status=active
</pre>
<p>
This search will only return resources that have a value for clinicalStatus:
</p>
<pre class="json" fragment="AllergyIntolerance">
{
  "resourceType" : "AllergyIntolerance",
  "clinicalStatus" : "active"
}
</pre>
<p>
Resources missing a clinicalStatus will not be returned. This is probably unsafe - it would not usually
be appropriate to ignore AllergyIntolerance warnings with an unknown clinical status, and
only return resources with an explicit clinicalStatus. Instead, it might be desired to return
AllergyIntolerance resources with either an explicit value for clinicalStatus, or none:
</p>
<pre>
GET [base]/AllergyIntolerance?clinical-status=active
GET [base]/AllergyIntolerance?clinical-status:exists=false
</pre>
<p>
Note that this is 2 separate queries. They can be <a href="http.html#transaction">combined in a batch</a>,
but not in a single operation. This query will always return an empty list, as no resource can satisfy both criteria at once:
</p>
<pre>
GET [base]/AllergyIntolerance?clinical-status=active&amp;clinical-status:exists=false
</pre>
<p>
There is no way to use the :exists modifier and mix with a value using the
comma syntax documented above for for composite search parameters.
</p>
<p>
An alternative approach is to use the <a href="#filter"><code>_filter</code></a> parameter,
for servers that support this parameter.
</p>

<a name="escaping"> </a>
<h4>Экранирование параметров поиска<!-- Escaping Search Parameters --></h4>
<p>
В правилах, описанных выше, введены особые правила для символом <code>$</code>, <code>,</code> и <code>|</code>. Как следствие, если эти символы появляются в реальном значении параметра, они должны различаться от своего использования в качестве символов-разделителей. Когда любой из этих символов появляется в реально значении параметра, они должны экранироваться символом <code>\</code>, который также должен использоваться для экранирования самого себя. Следовательно <code>param=xxx$xxx</code> означает, что это составной параметр, а <code>param=xx\$xx</code> означает, что этот параметр имеет буквальное значение <code>xx$xx</code>. Значение параметра <code>xx\xx</code> является допустимым, а значение параметра <code>param=xx\\xx</code> означает, что это буквальное значение <code>xx\xx</code>.
<!-- In the rules described above, special rules are defined for the characters <code>$</code>, <code>,</code>, and <code>|</code>.
As a consequence, if these characters appear in an actual parameter value,
they must be differentiated from their use as separator characters. When
any of these characters appear in an actual parameter value, they must be
prepended by the character <code>\</code>, which also must be used to prepend itself.
Therefore, <code>param=xxx$xxx</code> indicates that it is a composite parameter, while <code>param=xx\$xx</code> indicates that
the parameter has the literal value <code>xx$xx</code>. The parameter value <code>xx\xx</code> is illegal,
and the parameter value <code>param=xx\\xx</code> indicates a literal value of <code>xx\xx</code>. -->
</p>
<p>
Данная спецификация задаёт эту дополнительную форму экранирования не случайно. Классическое экранирование вида <code>%xx</code>, являющееся частью стандартных HTTP URL-адресов, гарантирует, что символ будет передан на FHIR-сервере корректно, в то время как <code>,</code> против <code>\</code> становится важным, как только он достигает сервера и запрос начинает обрабатываться. Поэтому:
<!-- This specification defines this additional form of escape
for a reason. The classic <code>%xx</code> escaping which is part of 
normal HTTP URLs ensures that the character appears at the FHIR server 
correctly, while the <code>,</code> versus <code>\</code> becomes important once it has 
reached the server and the query is parsed. Therefore: -->
</p>
<pre>
GET [base]/ValueSet?url=http://acme.org/fhir/ValueSet/123,http://acme.org/fhir/ValueSet/124%2CValueSet/125
</pre>
<p>
использует URL-экранирование для гарантии того, что FHIR-сервер получит:
<!-- uses url escaping to make sure the FHIR server received: -->
</p>
<pre>
GET [base]/ValueSet?url=http://acme.org/fhir/ValueSet/123,http://acme.org/fhir/ValueSet/124,125
</pre>
<p>
Этот запрос сравнит этот URL с тремя значениями: последнее является относительным и некорректным URL, что маловероятно является фактическим намерением. Однако:
<!-- This request will compare the URL against three values: the last one being a relative and incorrect url, 
which is likely not the actual intent. However: -->
</p>
<pre>
GET [base]/ValueSet?url=http://acme.org/fhir/ValueSet/123,http://acme.org/fhir/ValueSet/124\,125
</pre>
<p>
эквивалентно:
<!-- is equivalent to: -->
</p>
<pre>
GET [base]/ValueSet?url=http://acme.org/fhir/ValueSet/123,http://acme.org/fhir/ValueSet/124\%2C125
</pre>
<p>
что означает: url = <code>http://.....123</code> OR  <code>http://....124,125
<!-- which would mean: url = <code>http://.....123</code> OR  <code>http://....124,125 --></code>.
</p>

<a name="text"> </a>
<a name="content"> </a>
<h4>Параметры поиска по тексту<!-- Text Search Parameters --></h4>
<p>
Особые параметры поиска по тексту <code>_text</code> и <code>_content</code> ищут по описательной части ресурса и полному содержимому ресурса соответственно. Эти параметры ДОЛЖНЫ поддерживать функциональность сложного поиска этого типа, предлагаемого типичными службами индексирования текста. Значение этого параметра - это поиск на основе текста, который может включать поиск нескольких слов со словарём и соображения родства, а также такие логические операции, как AND, OR и др. Например:
<!-- The special text search parameters, <code>_text</code> and <code>_content</code>, search
on the narrative of the resource, and the entire content of the resource respectively.
These parameters SHOULD support a sophisticated search functionality of the type
offered by typical text indexing services.
The value of the parameter is a text based search, which may involve searching
multiple words with thesaurus and proximity considerations, and logical operations
such as AND, OR etc. For example: -->
</p>
<pre>
 GET [base]/Condition?_text=(bone OR liver) and metastases
</pre>
<p>
Этот запрос возвращает все ресурсы Condition со словом "metastases" и либо словом "bone", либо "liver" в описательной части. Сервер МОЖЕТ решить также искать родственные слова.
<!-- This request returns all Condition resources with the word "metastases" and either
"bone" or "liver" in the narrative. The server MAY choose to search
for related words as well. -->
</p>
<blockquote class="stu-note">
<a name="dstu2"> </a>
<p>
<b>Примечание к DSTU:</b>  проблемы, связанные со стандартизацией текстового поиска, решены не полностью. Во время периода пробного использования данной спецификации, мы рекомендуем системам использовать правила, описанные <a href="http://docs.oasis-open.org/odata/odata/v4.0/cs01/part1-protocol/odata-v4.0-cs01-part1-protocol.html#_The_$search_System">
спецификацией OData для параметра $<code>search</code></a>. Типичные реализации могут использовать Lucene - полнотекстовый поиск на основе SQL, или какую-нибудь службу индексирования. 
<!-- <b>STU Note:</b>  The issues around standardizing text search are not fully resolved.
During the trial use period for this specification, we recommend that systems use
the rules specified by <a href="http://docs.oasis-open.org/odata/odata/v4.0/cs01/part1-protocol/odata-v4.0-cs01-part1-protocol.html#_The_$search_System">
the OData specification for the $<code>search</code> parameter</a>.
Typical implementations would use Lucene, an sql-based full text search,
or some indexing service.  -->
</p>
<p>
Будем благодарны за ваши <a href="http://wiki.hl7.org/index.php?title=FHIR_Specification_Feedback_(STU_3)">отзывы</a>.
</p>
</blockquote>

<a name="list"> </a>
<h4>Searching by list</h4>

<p>
Параметр <code>_list</code> позволяет извлекать ресурсы, на которые ссылается ресурс <a href="list.html">List</a>.
<!-- The <code>_list</code> parameter allows for the retrieval of resources that are referenced by a <a href="list.html">List</a>
resource.  -->
</p>
<pre>
 GET [base]/Patient?_list=42
</pre>
<p>
Этот запрос возвращает все ресурсы Patient, на которые есть ссылки в списке, найденном по пути <code>[base]/List/42</code> в List.entry.item. Хотя и можно извлечь список и затем пройти по записям в этом списке, извлекая каждого пациента, использование списка в качестве критерия поиска позволяет указывать дополнительные критерии поиска. К примеру:
<!-- This request returns all Patient resources that are referenced from the list found at <code>[base]/List/42</code>) in List.entry.item.
While it is possible to retrieve the list, and then iterate the entries in the list fetching each
patient, using a list as a search criteria allows for additional search criteria to be specified. For 
instance: -->
</p>
<pre>
 GET [base]/Patient?_list=42&amp;gender=female
</pre>
<p>
Этот запрос вернёт всех пациентов женского пола из списка. Сервер может вернуть список, на который ссылается параметр поиска, в качестве включённого ресурса, но не обязан делать это. Дополнительно, система может поддерживать поиск по спискам в качестве своей логической функции. Например:
<!-- This request will return all female patients in the list. The server can return the list referred 
to in the search parameter as an included resource, but is not required to do so. 
In addition, a system can support searching by lists by their logical function. For example:   -->
</p>
<pre>
 GET [base]/AllergyIntolerance?patient=42&amp;_list=$current-allergies
</pre>
<p>
Этот запрос вернёт все аллергии из "Текущего списка аллергий" пациента с идентификатором 42. Сервер вернёт все релевантные ресурсы AllergyIntolerance, а также может по желанию вернуть этот список. За более подробной информацией обращайтесь к <a href="lifecycle.html#current">определению "$current-allergies"</a> и <a href="list-operations.html#find">операции со списками "Find"</a>. Примечание: серверы не обязаны давать клиентам доступ к этим спискам как к ресурсам List, но могут делать это по желанию.
<!-- This request will return all allergies in patient 42's "Current Allergy List".
The server returns all relevant AllergyIntolerance resources, and can also choose
to return the list. For further information, refer to the <a href="lifecycle.html#current">definition of "$current-allergies"</a>,
and the <a href="list-operations.html#find">List Operation "Find"</a>.
Note: Servers are not required to make these lists available to the clients as list resources,
but may choose to do so. -->
</p>

<a name="filter"> </a>
<a name="_filter"> </a>
<h4>Расширенные возможности фильтрации<!-- Advanced filtering --></h4>

<p>
Механизм поиска, описанный выше, является гибким и легко реализуемым для простых случаев, однако он ограничен в своей возможности выражать комбинированные запросы. В дополнение к этому механизму можно использовать параметр "_filter".
<!-- The search mechanism described above is flexible, and easy to implement
for simple cases, but is limited in its ability to express combination
queries. To complement this mechanism, a the "_filter" search expression
parameter can be used. -->
</p>
<p>
Например "найти все наблюдения пациента с именем, включающим <code>peter</code>, где есть LOINC-код <code>1234-5</code>":
<!-- For example, "Find all the
observations for patient with a name including <code>peter</code> that have a LOINC code <code>1234-5</code>": -->
</p>
<pre>
GET [base]/Observation?code=http://loinc.org|1234-5&amp;subject.name=peter
</pre>
<p>
Используя параметр <code>_filter</code>, запрос может быть выражен так:
<!-- Using the <code>_filter</code> parameter, the search would be expressed like this: -->
</p>
<pre>
GET [base]/Observation?_filter=name eq http://loinc.org|1234-5 and subject.name co "peter"
</pre>
<p>
Более подробно параметр <code>_filter</code> описан на странице <a href="search_filter.html">"Параметр _Filter"</a>.
<!-- The <code>_filter</code> parameter is described in detail on the <a href="search_filter.html">"_Filter Parameter" page</a>. -->
</p>

<a name="type"> </a>
<a name="_type"> </a>
<h4>Указание типа ресурса<!-- Specifying the type of Resource --></h4>

<p>
Обычно поиск вызывается по известному типу ресурса, например:
<!-- Normally, a search is initiated against a known type of resource, e.g. -->
</p>
<pre>
GET [base]/Observation?params...
</pre>
<p>
Однако в некоторых обстоятельствах поиск выполняется без фиксированного типа ресурса:
<!-- However in some circumstances, a search is executed where there is no fixed 
type of resource: -->
</p>
<ul>
 <li>Использование поиска по всем типам ресурсов (GET [base]?params...)</li>
 <li>Использование поиска в <a href="messaging.html">обмене сообщениями</a></li>
 <li>Некоторые спецификации поиска внутри других сервисов, например применение поддержки принятия решений</li>
<!--  <li>Using search across all resource types (GET [base]?params...)</li>
 <li>Using search with <a href="messaging.html">messaging</a></li>
 <li>Some search specifications inside other services e.g. decision support usage</li> -->
</ul>
<p>
В этих случаях в критериях поиска может потребоваться указать один или несколько типов ресурсов, по которым будет вестись поиск. Это можно сделать с помощью параметра <code>_type</code>:
<!-- In these circumstances, the search criteria may need to specify one or more  
resource types that the search applies to. This can be done by using the 
<code>_type</code> parameter: -->
</p>
<pre>
GET [base]/?_type=Observation,Condition&amp;other params...
</pre>
<p>
Отметьте, что только базовые параметры поиска можно использовать для глобального поиска наподобие этого, которые применяются ко всем ресурсам. В других контекстах для поиска по нескольким типам можно использовать специфичные для ресурсов параметры поиска, однако для определения корректной модели поведения в таких случаях потребуется опыт реализации.
<!-- Note that the only search parameters that be can be used in global search like 
this are the base parameters that apply to all resources. In other contexts,
searches on multiple types may allow resource specific search parameters, but 
implementation experience will be required to determine the correct behaviour in 
these cases. -->
</p>
<p>
Technically, the <code>_type</code> parameter is a token parameter on the
<a href="valueset-resource-types.html">Resource Types</a> Value Set.
</p>

<a name="return"> </a>
<h3>Управление возвращаемыми ресурсами<!-- Managing Returned Resources --></h3>

<a name="sort"> </a>
<a name="_sort"> </a>

<h4>Сортировка<!-- Sorting --></h4>
<p>
Клиент может указать, в каком порядке вернуть результаты, с помощью параметра <code>_sort</code>, который может содержать список правил сортировки, отделённых [друг от друга] запятыми, в порядке приоритета:
<!-- The client can indicate which order to return the results by
using the parameter <code>_sort</code>, which can contains a 
comma-separated list of sort rules in priority order: -->
</p>
<pre>
GET [base]/Observation?_sort=status,-date,category
</pre>
<p>
Каждый элемент в разделённом запятыми списке - это параметр поиска с необязательным префиксом '-'. Этот префикс обозначает обратный (убывающий) порядок; если он отсутствует, то такой параметр применяется в порядке возрастания.
<!-- Each item in the comma separated list is a search parameter, 
optionally with a '-' prefix. The prefix indicates decreasing 
order; in it's absence, the parameter is applied in increasing order. --> 
</p>
<p>
Примечания:
<!-- Notes: -->
</p>
<ul>
 <li>При сортировке реально используемое значение сортировки не возвращается явным образом сервером для содержимого каждого ресурса.</li>
 <li>Для сортировки по релевантности используйте <code>_score</code>.</li>
 <li>Сервер возвращает тип сортировки, которую он выполняет, в рамках возвращаемых параметров поиска (см. <a href="#conformance">ниже</a>).</li>
 <li>Параметр поиска может указывать на повторяющийся элемент, поэтому может быть несколько значений для заданного параметра поиска для отдельного ресурса. В таком случае сортировка будет основываться на элементе в наборе нескольких параметров, который идёт раньше всех в указанном порядке сортировки при упорядочивании возвращаемых ресурсов.</li>
  <li>При сортировке по строковым параметрам поиска, сортировка ДОЛЖНА выполняться независимо от регистра. Диакритические знаки можно либо игнорировать, либо сортировать по принятому соглашению.</li>
<li>This specification does not specify exacts rules for consistency of sorting 
     across servers. In general, this is deemed to be not as essential as 
     consistency of filtering (though even that is a little variable). The
     purpose of sorting is to provide data in a "reasonable" order for end-users.
    "Reasonable" may vary by use case and realm, particularly for accented characters.</li>
<!--  <li>When sorting, the actual sort value used is not returned explicitly by 
     the server for each resource, just the resource contents.</li>
 <li>To sort by relevance, use <code>_score</code>.</li>
 <li>The server returns the sort it performs as part of the returned 
     search parameters (see <a href="#conformance">below</a>).</li>
 <li>A search parameter can refer to an element that repeats, and therefore
     there can be multiple values for a given search parameter for a single
     resource. In this case, the sort is based on the item in the set of
     multiple parameters that comes earliest in the specified sort order
     when ordering the returned resources.</li>
  <li>When sorting on string search parameters, sorting SHOULD be performed 
     on a case-insensitive basis. Accents may either be ignored or sorted as 
     per realm convention.</li>
  <li>This specification does not specify exacts rules for consistency of sorting 
     across servers. In general, this is deemed to be not as essential as 
     consistency of filtering (though even that is a little variable). The
     purpose of sorting is to provide data in a "reasonable" order for end-users.
    "Reasonable" may vary by use case and realm, particularly for accented characters.</li> -->
</ul>

<a name="count"> </a>
<h4>Количество страниц<!-- Page Count --></h4>

<p>
Для того чтобы сохранять нагрузку на клиентов, серверы и сеть минимальной, сервер может по желанию возвращать результаты в виде серии страниц. Набор результатов поиска содержит URL-ссылки, которые клиент использует для запроса дополнительных страниц из поискового набора. Для простого RESTful поиска ссылки на эти страницы <a href="http.html#paging">содержатся в возвращаемом бандле</a>. 
<!-- In order to keep the load on clients, servers and the network
minimized, the server may choose to return the results in
a series of pages. The search result set contains the URLs
that the client uses to request additional pages from the
search set. For a simple RESTful search, the page links are
<a href="http.html#paging">contained in the returned bundle as links</a>. -->
</p>
<p>
Как правило, сервер предоставляет свои собственные параметры в ссылках, которые он использует для управления состоянием поиска при извлечении страниц. Эти параметры не требуется понимать или обрабатывать клиенту.
<!-- Typically, a server will provide its own parameters in the links
that it uses to manage the state of the search as pages are
retrieved. These parameters do not need to be understood
or processed by the client. -->
</p>

<p>
Параметр <code>_count</code> определён в качестве подсказки серверу относительно того, сколько ресурсов необходимо вернуть на одной странице. Серверы НЕ ДОЛЖНЫ возвращать больше ресурсов, чем запрашивается, даже если не поддерживают разбивку на страницы, однако они могут возвращать меньшее количество, чем запрашивает клиент. Сервер должен повторять первоначальный параметр <code>_count</code> в своих возвращаемых ссылках на страницы, чтобы последующие запросы с разбивкой на страницы учитывали первоначальный <code>_count</code>. Примечание: способ обработки текущих обновлений ресурсов во время выполнения поиска остаётся на усмотрение поисковой системы.
<!-- The parameter <code>_count</code> is defined as a hint to the server
regarding how many resources should be returned in a
single page. Servers SHALL NOT return more resources than
requested, even if they don't support paging, but are
allowed to return less than the client requested. The server should repeat 
the original <code>_count</code> parameter in its returned page links so that 
subsequent paging requests honor the original <code>_count</code>.  Note:
It is at the discretion of the search engine as to how to
handle ongoing updates to the resources while the search
is proceeding. -->
</p>

<p>
Примечание: комбинацию <code>_sort</code> и <code>_count</code> можно использовать для возвращения только самого свежего ресурса, который соответствует определённым критериям - задать критерии и затем отсортировать по дате в обратном порядке с <code>_count=1</code>. Таким образом будет возвращён самый свежий подходящий ресурс.
<!-- Note: The combination of <code>_sort</code> and <code>_count</code> can be used to return
only the latest resource that meets a particular criteria - set the
criteria, and then sort by date in descending order, with <code>_count=1</code>.
This way, the last matching resource will be returned. -->
</p>

<p>
Если <code>_count</code> имеет значение 0, это следует интерпретировать так же, как и <code>_summary=count</code>: сервер возвращает бандл, который сообщает общее количество совпадающих ресурсов в Bundle.total, но без записей и ссылок на пред/след/последнюю [страницу].
<!-- if <code>_count</code> has the value 0, this shall be treated the same as <code>_summary=count</code>: the
server resturns a bundle that reports the total number of resources that match in Bundle.total, 
but with no entries, and no prev/next/last links. -->
Note that the <code>Bundle.total</code> only 
include the total number of matching resources. It does not count extra resources such as 
<a href="operationoutcome.html">OperationOutcome</a> or <a href="#include">included</a> resources that may also be returned.
</p>

<a name="include"> </a>
<a name="revinclude"> </a>
<h4>Включение других ресурсов в результат (<code>_include</code> и <code>_revinclude</code>)<!-- Including other resources in result (<code>_include</code> and <code>_revinclude</code>) --></h4>
<p>
Клиенты могут запросить, чтобы система вернула ресурсы, связанные с результатами поиска, чтобы уменьшить общую сетевую задержку повторяющихся извлечений связанных ресурсов. Это полезно, когда клиент ищет клинический ресурс, однако для каждого такого возвращаемого ресурса клиенту также требуется ресурс-субъект (пациент), к которому относится данный клинический ресурс. Клиент может использовать параметр <code>_include</code> для указания, что ресурсы-субъекты должны быть включены в результаты. Альтернативным сценарием может быть такой, когда клиент хочет извлечь конкретный ресурс и все ресурсы, которые ссылаются на него. Например клиент может пожелать извлечь MedicationRequest и все ресурсы Provenance, которые ссылаются на это предписание. Это называется обратным включением и указывается с помощью параметра <code>_revinclude</code>.
<!-- Clients may request that the engine return resources related to the search results, in order to reduce 
the overall network delay of repeated retrievals of related resources. This is useful when the client 
is searching on a clinical resource, but for every such resource returned, the client will also need 
the subject (patient) resource that the clinical resource refers to. The client can use the 
<code>_include</code> parameter to indicate that the subject resources be included in the results. 
An alternative scenario is where the client wishes to fetch a particular resource, and any resources 
that refer to it. For example, the client may wish to fetch a MedicationRequest, and any provenance 
resources that refer to the prescription. This is known as a reverse include, and is specified by 
providing a <code>_revinclude</code> parameter. -->
</p>
<p>  
Оба параметра <code>_include</code> и <code>_revinclude</code> основываются на параметрах поиска, а не на путях в ресурсе, так как объединения, такие как <a href="#chaining">chaining</a>, уже сделаны параметром поиска.
<!-- Both <code>_include</code> and <code>_revinclude</code> are based on search parameters, rather than 
paths in the resource, since joins, such as <a href="#chaining">chaining</a>, are already done by 
search parameter. -->
</p> 
<p>
Каждый параметр <code>_include</code> описывает параметр поиска для объединения:
<!-- Each <code>_include</code> parameter specifies a search parameter to join on: -->
</p>
<pre>
 GET [base]/MedicationRequest?_include=MedicationRequest:patient&amp;criteria...
 GET [base]/MedicationRequest?_revinclude=Provenance:target&amp;criteria...
</pre>
<p>
Первый поисковый запрос запрашивает все подходящие MedicationRequests, чтобы включить всех пациентов, к которым относятся предписания медикаментов в наборе результатов. Второй поисковый запрос запрашивает все подходящие рецепты (предписания) и возвращает все ресурсы  Provenance, которые к ним относятся.
<!-- The first search requests all matching MedicationRequests, to include
any patient that the medication prescriptions in the result set refer to. 
The second search requests all matching prescriptions, return all 
the provenance resources that refer to them.  -->
</p>
<p>
Значения для обоих параметров <code>_include</code> и <code>_revinclude</code> содержат три части, разделённые двоеточием <code>:</code>
<!-- Parameter values for both <code>_include</code> and <code>_revinclude</code> have three parts, separated by a <code>:</code> character: -->
</p>
<ol>
 <li>Имя исходного ресурса, из которого идёт объединение</li>
 <li>Имя параметра поиска, который должен быть типа <i>reference</i></li>
 <li>(Необязательно) Конкретный тип целевого ресурса (для случаев, когда параметр поиска ведёт на несколько возможных целевых типов)</li>
<!--  <li>The name of the source resource from which the join comes</li>
 <li>The name of the search parameter which must be of type <i>reference</i></li>
 <li>(Optional) A specific of type of target resource (for when the search parameter refers to multiple possible target types)</li> -->
</ol>
<p>
Параметры <code>_include</code> и <code>_revInclude</code> не включают множественные значения. Вместо этого эти параметры повторяются для каждого отдельного критерия включения.
<!-- <code>_include</code> and <code>_revInclude</code> parameters do not include multiple values. Instead, the 
parameters are repeated for each different include criteria. -->
</p>
<p>
Для каждого возвращаемого ресурса сервер определяет ресурсы, которые соответствуют критериям поиска, выраженным в объединении, и добавляет к результатам с <a href="bundle-definitions.html#Bundle.entry.search.mode">entry.search.mode</a> установленным в значение "include" (в некоторых поисковых запросах не очевидно, какие ресурсы являются совпадениями, а какие - включениями-инклюдами). If there is no reference, or no matching resource, the resource
cannot be retrieved (e.g. on a different server), then the resource is omitted, and no
error is returned.
</p>
<p>
Процесс включения может быть рекурсивным, если используется модификатор <code>:recurse</code>. Например следующий поисковый запрос возвращает все ресурсы <a href="medicationrequest.html">Medication
Request</a> и их ресурсы <a href="practitioner.html">prescribing Practitioner</a> для соответствующих поиску ресурсов <a href="medicationdispense.html">Medication Dispense</a>:
<!-- The inclusion process can be recursive, if the modifier <code>:recurse</code> is included. 
  For example, this search returns all <a href="medicationrequest.html">Medication
Request</a> resources and their <a href="practitioner.html">prescribing Practitioner</a> Resources
for the matching <a href="medicationdispense.html">Medication Dispense</a> resources: -->
</p>
<pre>
GET [base]/MedicationDispense?_include=MedicationDispense:authorizingPrescription
    &amp;_include:recurse=MedicationRequest:prescriber&amp;criteria...
</pre>
<p>
Этот способ также применяется к циркулярным [рекурсивным] взаимосвязям. Например первый из этих двух поисковых запросов включает все связанные с целевыми взаимосвязями наблюдения, но только с теми, что связаны напрямую. Второй запрос запрашивает <code>_include</code> на основе параметра <code>related</code>, который выполняется рекурсивно, таким образом он извлечёт наблюдения, которые имеют прямую связь, а также все наблюдения, связанные со всеми наблюдениями, включёнными через <code>_include</code>.
<!-- This technique applies to circular relationships as well. For example, 
the first of these two searches includes any related observations to the 
target relationships, but only those directly related. The second search
asks for the <code>_include</code> based on <code>related</code> parameter to be executed
recursively, so it will retrieve observations that are directly related, and 
also any related observations to any other included observation. -->
</p>
<pre>
GET [base]/Observation?_include=Observation:related-target&amp;criteria...
GET [base]/Observation?_include:recurse=Observation:related-target&amp;criteria...
</pre>
<p>
В обоих параметрах <code>_include</code> и <code>_revInclude</code> можно использовать специальный символ "*" в качестве имени параметра поиска для обозначения, что любой поисковый параметр с типом reference будет включен. Хотя и клиентам, и серверам необходимо заботиться о том, чтобы не запрашивать или не возвращать слишком много ресурсов при выполнении таких запросов. В частности использование рекурсивных включений может привести к извлечению всей карты пациента и даже более того: ресурсы организованы в сопряжённую сеть и заданные в достаточно общем виде пути <code>_include</code> могут в итоге включить все возможные пути на сервере. Для серверов такие рекурсивные и со звёздочкой инклюды (<code>_include</code>) являются достаточно требовательными и могут существенно замедлить время ответа на поиск.
<!-- Both <code>_include</code> and <code>_revInclude</code> use the wild card "*" for the search parameter
name, indicating that any search parameter of type=reference be included.  Though 
though both clients and servers need to take care not to request or return too many resources
when doing this. Most notably, using recursive inclusions might lead to the retrieval of the 
full patient's record, or even more: resources are organized into an interlinked network 
and broad <code>_include</code> paths may eventually traverse all possible paths on the server. For 
servers, these recursive and wildcard <code>_include</code>s are demanding and may slow the search 
response time significantly.  -->
</p>
<p>
На усмотрение сервера, насколько глубоко рекурсивно вычислять включения. Предполагается, что серверы будут ограничивать число итераций, выполняемых до уместного уровня, и что они не обязаны учитывать запросы на включение дополнительных ресурсов в результаты поиска.
<!-- It is at the server's discretion how deep to recursively evaluate the inclusions. 
Servers are expected to limit the number of iterations done to an appropriate level 
and are not obliged to honor requests to include additional resources in the search results. -->
</p>
<p>
Когда результаты поиска разбиваются на страницы, каждая страница результатов поиска должна включать все соответствующие инклюды для ресурсов на каждой странице, чтобы каждая страница была отдельным связным пакетом.
<!-- When search results are paged, each page of search results should include 
the matching includes for the resources in each page, so that each page stands
alone as a coherent package. -->
</p>


<a name="contained"> </a>
<a name="containedType"> </a>


<h4>Вложенные ресурсы<!-- Contained Resources --></h4>

<p>
По умолчанию результаты поиска включают только те ресурсы, которые не являются вложенными в другие ресурсы. Цепочечное условие будет вычисляться внутри вложенных ресурсов. Для иллюстрации этого рассмотрим ресурс MedicationRequest, который содержит вложенный ресурс Medication, описывающий пользовательскую рецептуру, где есть ингредиент с <code>itemCodeableConcept</code> "abc" в "http://acme.com./medications". В таком случае поисковый запрос:
<!-- By default, search results only include resources that are not contained in other resources. 
A chained condition will be evaluated inside contained resources. To illustrate this, consider
a MedicationRequest resource that has a contained Medication resource specifying 
a custom formulation that has ingredient with a <code>itemCodeableConcept</code> "abc" in "htp://acme.com./medications". 
In this case, a search: -->
</p>
<pre>
GET MedicationRequest?medication.ingredient-code=abc
</pre>
<p>
 будет включать в результаты ресурс MedicationRequest. Однако следующий поисковый запрос:
<!--   will include the MedicationRequest resource in the results. However, this search: -->
</p>
<pre>
GET Medication?ingredient-code=abc
</pre>
<p>
не будет включать в результаты вложенный ресурс Medication, поскольку либо неправильный тип ресурса был бы возвращён, либо вложенный ресурс был бы возвращён без своего ресурса-контейнера, который обеспечивает контекст для вложенного ресурса.
<!-- will not include the contained Medication resource in the results, since either the 
wrong type of resource would be returned, or the contained resource would be returned
without its container resource, which provides context to the contained resource. -->
</p>
<p>
Клиенты могут менять эту модель поведения с помощью параметра <code>_contained</code>, который может иметь одно из следующих значений:
<!-- Clients are able to modify this behavior using the <code>_contained</code> parameter, which
can have one of the following values: -->
</p>
<ul>
 <li>false (по умолчанию): не возвращать вложенные ресурсы</li>
 <li>true: вернуть только вложенные ресурсы</li>
 <li>both: вернуть и вложенные, и не вложенные (обычные) ресурсы</li>
<!--  <li>false (default): Do not return contained resources</li>
 <li>true: return only contained resources</li>
 <li>both: return both contained and non-contained (normal) resources</li> -->
</ul>
<p>
При возвращении вложенных ресурсов, сервер должен вернуть либо ресурс-контейнер, либо только вложенный ресурс отдельно. Клиент может указать способ через параметр <code>_containedType</code>, который может иметь одно из следующих значений:
<!-- When contained resources are being returned, the server 
should return either the container resource, or the contained resource alone. The 
client can specify which by using the <code>_containedType</code> parameter, which can have one of the 
following values: -->
</p>
<ul>
 <li>container (по умолчанию): вернуть ресурсы-контейнеры</li>
 <li>contained: вернуть только вложенный ресурс</li>
<!--  <li>container (default): Return the container resources</li>
 <li>contained: return only the contained resource</li> -->
</ul>
<p>
При возвращении ресурса-контейнера, сервер просто помещает его в результаты поиска:
<!-- When returning a container resource, the server simply puts this in the 
search results: -->
</p>
<pre class="xml">
&lt;Bundle&gt;
  ...
  &lt;entry&gt;
    &lt;resource&gt;
      &lt;MedicationRequest&gt;
        &lt;id value=&quot;23&quot;&gt;
        ....
        &lt;contained&gt;
          &lt;Medication&gt;
            &lt;id value=&quot;m1&quot;&gt;
            ...
          &lt;/Medication&gt;
        &lt;contained&gt;

      &lt;/MedicationRequest&gt;
    &lt;/resource&gt;
    &lt;search&gt;
      &lt;mode value=&quot;match&quot;/&gt;
    &lt;/search&gt;
  &lt;/entry&gt;
&lt;/Bundle&gt;
</pre>
<p>
В случае возвращения ресурсов-контейнеров, сервер ДОЛЖЕН заполнить элемент entry.search.mode так, чтобы клиент мог разделить совпадения и инклюды (стандартный подход сделать это исходя из типа может не сработать). Если типом результата является вложенный ресурс, это следует делать по-другому: In the case of returning container resources, the server SHALL populate the entry.search.mode
element, as shown, so that the client can pick apart matches and includes (since the usual approach of doing it
by type may not work).
</p>
<p>
If the return type is the contained resource, this must be done slightly 
differently:
</p>
<pre class="xml">
&lt;Bundle&gt;
  ...
  &lt;entry&gt;
    &lt;fullUrl value=&quot;http://example.com/fhir/MedicationRequest/23#m1&quot;/&gt;
    &lt;resource&gt;
      &lt;Medication&gt;
        &lt;id value=&quot;m1&quot;&gt;
        ...
      &lt;/Medication&gt;
    &lt;/resource&gt;
    &lt;search&gt;
      &lt;mode value=&quot;match&quot;/&gt;
    &lt;/search&gt;
  &lt;/entry&gt;
&lt;/Bundle&gt;
</pre>
<p>
В этом случае fullUrl сообщает клиенту о том, что это вложенный ресурс, наряду с указанием идентификатора содержащего его ресурса.
<!-- In this case, the fullUrl informs the client that this is a contained resource,
along with indicating the identity of the containing resource. -->
</p>

<a name="external"> </a>

<h4>Внешние ссылки<!-- External References --></h4>
<p>
Если путь в параметре <code>_include</code> выбирает ссылку, которая ведёт на ресурс на другом сервере, то сервер может по своему выбору включить тот ресурс в результаты поиска для удобства клиента.
<!-- If the <code>_include</code> path selects a reference that refers to a resource on another server,
the server can elect to include that resource in the search results for the convenience
of the client. -->
</p>
<p>
Если путь параметра <code>_include</code> выбирает ссылку, которая ведёт на сущность, не являющуюся ресурсом, например на вложение-картинку, сервер может также по своему выбору включать это в возвращаемые результаты в виде ресурса <a href="binary.html">Binary</a>. Например путь включения может указывать на вложение с помощью ссылки следующим образом:
<!-- If the <code>_include</code> path selects a reference that refers to an entity that is not a Resource, such as
an image attachment, the server may also elect to include this in the returned
results as a <a href="binary.html">Binary</a> resource. For example, the include
path may point to an attachment which is by reference, like this: -->
</p>
<pre>
 &lt;content&gt;
   &lt;contentType&gt;image/jpeg&lt;/contentType&gt;
   &lt;url&gt;http://example.org/images/2343434/234234.jpg&lt;/url&gt;
 &lt;/content&gt;
</pre>
<p>
Сервер может извлекать целевой объект этой ссылки и добавлять его к результатам для удобства клиента.
<!-- The server can retrieve the target of this reference, and add it to the
results for the convenience of the client. -->
</p>

<h4>Разбивка на страницы<!-- Paging --></h4>
<p>
При возвращении разбитых на страницы результатов поиска с включением ресурсов через <code>_include</code>, все включенные ресурсы, связанные с главными ресурсами, возвращёнными на странице, ДОЛЖНЫ тоже возвращаться в рамках этой же самой страницы, даже если некоторые из экземпляров этих ресурсов ранее были возвращены на предыдущих страницах. Такой подход позволяет как отправителю, так и получателю избежать кеширования результатов других страниц.
<!-- When returning paged results for a search with <code>_include</code> resources, all <code>_include</code> resources that are
related to the primary resources returned for the page SHOULD also be returned as part of that
same page, even if some of those resource instances have previously been returned on previous
pages.  This approach allows both sender and receiver to avoid caching results of other pages. -->
</p>

<a name="summary"> </a>
<h4>Суммарность<!-- Summary --></h4>
<p>
Клиент может запросить сервер вернуть только часть ресурсов с помощью параметра <code>_summary</code>:
<!-- The client can request the server to return only a portion of the resources
by using the parameter <code>_summary</code>: -->
</p>
<pre>
   GET [base]/ValueSet?_summary=true
</pre>
<p>
Параметр <code>_summary</code> запрашивает сервер вернуть подмножество ресурса. Он может иметь одно из следующих значений:
<!-- The <code>_summary</code> parameter requests the server to return a subset of the 
resource. It can contain one of the following values: -->
</p>
<table class="codes">
 <tr><td><a href="#summary-true">true</a></td><td>Вернуть только те элементы, которые помечены как "суммарные" в базовых определениях ресурсов (см. <a href="elementdefinition-definitions.html#ElementDefinition.isSummary">ElementDefinition.isSummary</a>)</td></tr>
 <tr><td><a href="#summary-text">text</a></td><td>Вернуть только элемент "text", элемент 'id', 'meta' и только верхнеуровневые обязательные элементы</td></tr>
 <tr><td><a href="#summary-data">data</a></td><td>Убрать элемент "text"</td></tr>
 <tr><td><a href="#summary-count">count</a></td><td>Только поиск: вернуть только количество соответствующих ресурсов, не возвращая сами совпадения</td></tr>
 <tr><td><a href="#summary-false">false</a></td><td>Вернуть все части ресурсов</td></tr>
</table>
<p>
Параметр <code>_summary</code> предназначен для уменьшения общей процессинговой загрузки сервера, клиента и ресурсов между ними, таких как сеть. Он наиболее полезен для больших ресурсов, в честности тех, что включают в себя изображения или элементы, которые могут повторяться много раз. Назначение суммарной формы в том, чтобы позволить клиенту быстро извлечь большой набор ресурсов и позволить пользователю выбрать подходящий. Свойство суммарности для элемента задаётся для того, чтобы позволить пользователю быстро сортировать и фильтровать ресурсы, как правило опуская важное содержимое на основании того, что весь ресурс целиком будет извлечён уже после того, как пользователь выберет ресурс.
<!-- The intent of the <code>_summary</code> parameter is to reduce the total processing load on
server, client, and resources between them such as the network. It is most useful for
resources that are large, particularly ones that include images or elements that
may repeat many times. The purpose of the summary form is to allow a client to quickly
retrieve a large set of resources, and let a user pick the appropriate one. The
summary for an element is defined to allow a user to quickly sort and filter the 
resources, and typically omit important content on the basis that the entire 
resource will be retrieved when the user selects a resource. -->
</p>
<p>
Серверы не обязаны возвращать всего лишь суммарные элементы по запросу. Имеется ограниченное количество суммарных форм, определённых для ресурсов, чтобы позволить серверам сохранять суммарные формы заранее. Серверы ДОЛЖНЫ помечать ресурсы тегом <a href="v3/SecurityIntegrityObservationValue/cs.html#SUBSETTED"><code>SUBSETTED</code></a> для гарантии того, что неполный ресурс не будет случайно использован для перезаписи полного ресурса.
<!-- Servers are not obliged to return just a summary as requested. There are only 
a limited number of summary forms defined for resources in order to allow servers 
to store the summarized form(s) in advance. Servers SHOULD mark the resources with the 
tag <a href="v3/SecurityIntegrityObservationValue/cs.html#SUBSETTED"><code>SUBSETTED</code></a> 
to ensure that the incomplete resource is not acidentally used to overwrite 
a complete resource. -->
</p>
<p>
Note that the <code>_include</code> and <code>_revinclude</code> parameters cannot be mixed with <code>_summary=text</code>.
</p>

<blockquote class="stu-note">
<a name="dstu-tc"> </a>
<p>
<b>STU Note:</b>  There are open issues around the definitions of which elements are in the summary for each resource.
There are 2 kinds of problems in the existing definitions:
</p>
<ul>
 <li>Elements are marked as 'include in summary', but their parent element is not</li>
 <li>Elements have minimum cardinality &gt; 0, but are not included in the summary (and their parent element is) - so sumarised resources will not be schema valid</li>
</ul>
<p>
These issues will be resolved for FHIR Release 4. In the meantime, implementers may choose to
override which elements are marked as 'included in summary', and implementations may vary.
</p>
<p>
Feedback on which elements should be in the summaries is welcome <a href="http://wiki.hl7.org/index.php?title=FHIR_Specification_Feedback_(STU_3)">here</a>.
</p>
</blockquote>

<a name="elements"> </a>
<h4>Элементы<!-- Elements --></h4>
<p>
Если одно из суммарных представлений, определённых выше, не подходит, клиент может запросить вернуть особый набор элементов как часть ресурса, используя параметр <code>_elements</code>:
<!-- If one of the summary views defined above is not appropriate, a client can 
request a specific set of elements be returned as part of a resource using
the <code>_elements</code> parameter: -->
</p>
<pre>
   GET [base]/Patient?_elements=identifier,active,link
</pre>
<p>
Параметр <code>_elements</code> состоит из списка имён базовых элементов, разделённых запятыми, то есть элементов, определённых на корневом уровне в этом ресурсе. Только те элементы, которые перечислены, должны быть возвращены. Клиенты ДОЛЖНЫ перечислять все обязательные элементы и элементы-модификаторы в ресурсе в рамках этого списка элементов. Этот список элементов не применяется к <a href="#include">включенным ресурсам</a>.
<!-- The <code>_elements</code> parameter consists of a comma separated list of base element
names such as, elements defined at the root level in the resource. Only 
elements that are listed are to be returned. Clients SHOULD list all mandatory and modifier
elements in a resource as part of the list of elements. The list of elements
does not apply to <a href="#include">included resources</a>. -->
</p>
<p>
Серверы не обязаны возвращать только лишь запрашиваемые элементы. Серверы ДОЛЖНЫ всегда возвращать обязательные элементы независимо от того, запрашивались они или нет. Серверы ДОЛЖНЫ помечать ресурсы тегом <a href="v3/SecurityIntegrityObservationValue/cs.html#SUBSETTED"><code>SUBSETTED</code></a> для гарантии того, что неполный ресурс не будет случайно использован для перезаписи полного ресурса.
<!-- Servers are not obliged to return just the requested elements. 
Servers SHOULD always return mandatory elements whether they are 
requested or not. Servers SHOULD mark the resources with the 
tag <a href="v3/SecurityIntegrityObservationValue/cs.html#SUBSETTED"><code>SUBSETTED</code></a> 
to ensure that the incomplete resource is not actually used to overwrite 
a complete resource. -->
</p>

<a name="score"> </a>
<h4>Релевантность<!-- Relevance --></h4>
<p>
Где поиск указывает неопределённую сортировку, поисковый алгоритм может создать некоторый вид рейтинговой оценки для обозначения, какие результаты удовлетворяют указанным критериям лучше, чем другие. Сервер может верннуть эту оценку в <a href="bundle-definitions.html#Bundle.entry.score">entry.score</a>:
<!-- Where a search specifies a non-deterministic sort, the search algorithm
may generate some kind of ranking score to indicate which resources meet
the specified criteria better than others. The server can return this
score in <a href="bundle-definitions.html#Bundle.entry.score">entry.score</a>: -->
</p>
<pre class="xml">
  &lt;entry&gt;
    &lt;score value=&quot;.45&quot;/&gt;
    &lt;Patient&gt;
      ... patient data ...
    &lt;/Patient&gt;
  &lt;/entry&gt;
</pre>
<p>
Балл - это десятичное число со значением между (и включая) 0 и 1, где 1 - это наилучшее соответствие, а 0 - наименьшее соответствие.
<!-- The score is a decimal number with a value between (and including) 0 and 1, where 1 is best match, and 0 is least match. -->
</p>

<a name="conformance"> </a>
<h3>Соответствие сервера<!-- Server Conformance --></h3>
<p>
Для того, чтобы позволить клиенту быть уверенным о том, какие параметра поиска были использованы в качестве критериев сервером, сервер ДОЛЖЕН вернуть параметры, которые были фактически использованы при обработке поиска. Приложения, обрабатывающие результаты поиска, ДОЛЖНЫ проверить эти возвращённые значения, где это необходимо. Например, если сервер не поддерживает некоторые из фильтров, указанных в поиске, клиент мог бы вручную применить эти фильтры к полученному итоговому набору, показать предупреждающее сообщение пользователю или предпринять какое-то другое действие.
<!-- In order to allow the client to be confident about what search parameters
were used as criteria by the server, the server SHALL return the parameters
that were actually used to process the search. Applications processing search
results SHALL check these returned values where necessary. For example, if
the server did not support some of the filters specified in the search, a
client might manually apply those filters to the retrieved result set,
display a warning message to the user or take some other action. -->
</p>
<p>
В случае RESTful-поиска эти параметры кодируются в ссылку типа "self" в бандле, который будет возвращён:
<!-- In the case of a RESTful search, these parameters are encoded in the
self link in the bundle that is returned: -->
</p>
<pre class="xml">
  &lt;link&gt;
    &lt;relation value="self"/&gt; 
    &lt;url value="http://example.org/Patient?name=peter"/&gt;
  &lt;/link&gt;
</pre>
<p>
В остальном, серверы обладают значительной свободой действий в отношении
поддержки поиска:
<!-- In other respects, servers have considerable discretion with regards
to supporting search: -->
</p>
<ul>
 <li>Серверы могут выбирать, какие параметры поддерживать (за исключением <code>_id</code>, описанного выше).</li>
 <li>Серверы могут выбирать, когда и где реализовывать цепочечные параметры, а также когда и где они будут поддерживать параметр <code>_include</code>.</li>
 <li>Серверы могут декларировать дополнительные параметры в профилях, на которые ссылаются их заявления о Capability. Серверы должны определять параметры поиска, начинающиеся с символа "-", чтобы гарантировать отсутствие конфликтов имён, которые они выберут, с будущими параметрами, определяемыми в рамках самой спецификации.</li>
 <li>Серверам не требуется обеспечивать соблюдение чувствительности к регистру имён параметров, хотя эти имена и являются чувствительными к регистру (и URL-адреса, как правило, являются чувствительными к регистру).</li>
 <li>Серверы могут выбирать, сколько результатов возвращать, хотя клиент может использовать <code>_count</code>, как описано выше.</li>
 <li>Серверы могут выбирать, каким образом сортировать возвращаемые результаты, хотя они ДОЛЖНЫ учитывать параметр <code>_sort</code>.</li>
<!--  <li>Servers can choose which parameters to support (other than <code>_id</code> above).</li>
 <li>Servers can choose when and where to implement parameter chaining, and when and where they support the <code>_include</code> parameter.</li>
 <li>Servers are able to declare additional parameters in the profiles referenced from their Capability statements. Servers should define search parameters
    starting with a "-" character to ensure that the names they choose do not clash with future parameters defined by this specification.</li>
 <li>Servers are not required to enforce case sensitivity on parameter names, though the names are case sensitive (and URLs are generally case-sensitive).</li>
 <li>Servers may choose how many results to return, though the client can use <code>_count</code> as above</li>
 <li>Servers can choose how to sort the return results, though they SHOULD honor the <code>_sort</code> parameter.</li> -->
</ul>

<hr/>
<a name="advanced"> </a>
<a name="query"> </a>
<h3>Расширенные возможности поиска<!-- Advanced Search --></h3>
<p>
Система поиска, описанная выше - это полезный фреймворк для обеспечения простого поиска, основанного на индексируемых критериях, однако нужна возможность создания более сложных запросов для обработки точных запросов, сложных запросов на основе поддержки принятия решений и прямых запросов, интерпретируемых человеком.
<!-- The search framework described above is a useful framework
for providing a simple search based on indexed criteria,
but more sophisticated query capability is needed to handle precise
queries, complex decision support based requests, and
direct queries that have human resolution. -->
</p>
<p>
Более расширенные операции поиска задаются с помощью параметра <code>_query</code>:
<!-- More advanced search operations are specified by the
<code>_query</code> parameter: -->
</p>
<pre>
   GET [base]/Patient?_query=name&amp;parameters...
</pre>
<p>
Параметр <code>_query</code> называет пользовательский профиль поиска, который описывает конкретную операцию запроса. Именованный запрос может задавать дополнительные именованные параметры, которые используются с определённым именованным запросом. Серверы могут определять свои собственные дополнительные именованные запросы для удовлетворения своих собственных нужд с помощью <a href="operationdefinition.html">OperationDefinition</a>.
<!-- The <code>_query</code> parameter names a custom search profile that
describes a specific query operation. The named query
may define additional named parameters that are used with that
particular named query. Servers can define their own additional
named queries to meet their own uses using an <a href="operationdefinition.html">OperationDefinition</a>. -->
</p>
<p>
В наборе параметров поиска может быть только один параметр <code>_query</code>. Серверы обрабатывающие поисковые запросы, ДОЛЖНЫ отказывать обрабатывать поисковый запрос, если они не понимают значение параметра <code>_query</code>.
<!-- There can only ever be one <code>_query</code> parameter in a set of search
parameters. Servers processing search requests SHALL
refuse to process a search request if they do not recognize
the <code>_query</code> parameter value. -->
</p>

<a name="currency"> </a>
<h3>Устаревание результатов поиска<!-- Search Result Currency --></h3>

<p>
Результаты операции поиска будут гарантированно текущими только на момент выполнения операции. После выполнения операции текущие действия над ресурсами, по которым выполнялся поиск, делают результаты всё более устаревшими. Значимость этого зависит от характера поиска, а также вида использования результатов.
<!-- The results of a search operation are only guaranteed to be current
at the moment the operation is executed. After the operation is executed,
ongoing actions performed on the resources against which the search was
executed will render the results increasingly stale. The significance
of this depends on the nature of the search, and the kind of use that
is being made of the results. -->
</p>
<p>
Особенно это имеет значение, когда сервер возвращает результаты в виде серии страниц. Способ обработки текущих обновлений ресурсов во время выполнения поиска остаётся на усмотрение поисковой системы.
<!-- This is particularly relevant when the server is returning the results
in a series of pages. It is at the discretion of the search engine of
how to handle ongoing updates to the resources while the search
is proceeding. -->
</p>
<p>
Примечание: выполнение операции поиска не изменяет набор ресурсов на сервере, за исключением создания ресурсов <a href="auditevent.html">Audit Event</a> для ведения аудита самого поиска.
<!-- Note: Performing a search operation does not change the set of
resources on the server, with the exception of the creation
of <a href="auditevent.html">Audit Event</a> resources
auditing the search itself. -->
</p>

<a name="table"> </a>
<h3>Итоговые таблицы<!-- Summary Tables --></h3>

<table class="list">
<tr><td colspan="4">Общие параметры, определённые для всех ресурсов:<!-- Common Parameters defined for all resources: --></td></tr>
<tr><td><b>Имя</b></td><td><b>Тип</b></td><td><b>Описание</b></td><td><b>Пути</b></td></tr>
<tr><td><a href="#id"><code>_id</code></a></td><td><a href="#string">token</a></td><td>Идентификатор ресурса (а не полный URL)<!-- Resource id (not a full URL) --></td><td>Resource.id</td></tr>
<tr><td><a href="#lastUpdated"><code>_lastUpdated</code></a></td><td><a href="#date">date</a></td><td>Дата последнего обновления. Сервер может по своему усмотрению устанавливать границы точности<!-- Date last updated. Server has discretion on the boundary precision --></td><td>Resource.meta.lastUpdated</td></tr>
<tr><td><a href="#tag">_tag</a></td><td><a href="#token">token</a></td><td>Поиск по тегу ресурса<!-- Search by a resource tag --></td><td>Resource.meta.tag</td></tr>
<tr><td><a href="#profile"><code>_profile</code></a></td><td><a href="#uri">uri</a></td><td>Поиск всех ресурсов, помеченных профилем<!-- Search for all resources tagged with a profile --></td><td>Resource.meta.profile</td></tr>
<tr><td><a href="#security"><code>_security</code></a></td><td><a href="#token">token</a></td><td>Поиск по метке уровня безопасности<!-- Search by a security label --></td><td>Resource.meta.security</td></tr>
<tr><td><a href="#text"><code>_text</code></a></td><td><a href="#string">string</a></td><td>Текстовый поиск по описательной части<!-- Text search against the narrative --></td><td></td></tr>
<tr><td><a href="#content"><code>_content</code></a></td><td><a href="#string">string</a></td><td>Текстовый поиск по всему ресурсу целиком<!-- Text search against the entire resource --></td><td></td></tr>
<tr><td><a href="#list"><code>_list</code></a></td><td><a href="#string">string</a></td><td>Все ресурсы в названном списке (по идентификатору, а не полному URL)<!-- All resources in nominated list (by id, not a full URL) --></td><td></td></tr>
<tr><td><a href="#query">_query</a></td><td><a href="#string">string</a></td><td>Custom named query</td><td></td></tr>
<tr><td colspan="4">Search Control Parameters:</td></tr>
<tr><td><b>Имя</b></td><td><b>Тип</b></td><td><b>Описание</b></td><td><b>Допустимое содержимое</b></td></tr>
<tr><td><a href="#sort"><code>_sort</code></a></td><td><a href="#string">string</a></td><td>Порядок сортировки результатов (может повторяться для внутренних порядков сортировки)<!-- Order to sort results in (can repeat for inner sort orders) --></td><td>Имя допустимого параметра поиска<!-- Name of a valid search parameter --></td></tr>
<tr><td><a href="#count"><code>_count</code></a></td><td><a href="#number ">number </a></td><td>Количество результатов на странице<!-- Number of results per page --></td><td>Общее количество<!-- Whole number --></td></tr>
<tr><td><a href="#include"><code>_include</code></a></td><td><a href="#string">string</a></td><td>Другие ресурсы для включения в результаты поиска, на которые указывают найденные при поиске совпадения<!-- Other resources to include in the search results that search matches point to --></td><td>SourceType:searchParam(:targetType)</td></tr>
<tr><td><a href="#revinclude"><code>_revinclude</code></a></td><td><a href="#string">string</a></td><td>Другие ресурсы для включения в результаты поиска, когда они ссылаются на найденные при поиске совпадения<!-- Other resources to include in the search results when they refer to search matches --></td><td>SourceType:searchParam(:targetType)</td></tr>
<tr><td><a href="#summary"><code>_summary</code></a></td><td><a href="#string">string</a></td><td>Просто верните суммарные элементы (для ресурсов, где это определено)<!-- Just return the summary elements (for resources where this is defined) --></td><td><code>true</code> | <code>false</code> (<code>false</code> is default)</td></tr>
<tr><td><a href="#contained"><code>_contained</code></a></td><td><a href="#string">string</a></td><td>Возвращать ли ресурсы, вложенные в другие ресурсы при поиске совпадений<!-- Whether to return resources contained in other resources in the search matches --></td><td><code>true</code> | <code>false</code> | <code>both</code> (<code>false</code> is default)</td></tr>
<tr><td><a href="#containedType"><code>_containedType</code></a></td><td><a href="#string">string</a></td><td>Возвращать ли вложенные или родительские ресурсы при возвращении вложенных ресурсов<!-- If returning contained resources, whether to return the contained or container resources --></td><td><code>container</code> | <code>contained</code></td></tr>
</table>

<p>
Перекрёстное отображение между типами параметров поиска и типами данных:
<!-- Cross-map between search parameter types and Data types: -->
</p>
<table class="list">
 <tr>
  <td><b>Data Type</b></td>
  <td><b><a href="#number">number</a></b></td>
  <td><b><a href="#date">date</a></b></td>
  <td><b><a href="#string">string</a></b></td>
  <td><b><a href="#token">token</a></b></td>
  <td><b><a href="#reference">reference</a></b></td>
  <td><b><a href="#quantity">quantity</a></b></td>
  <td><b><a href="#uri">uri</a></b></td>
 </tr>
 <tr>
  <td><a href="datatypes.html#boolean">boolean</a></td>
  <td><%xcm boolean:number%></td> <!-- number -->
  <td><%xcm boolean:date%></td> <!-- date -->
  <td><%xcm boolean:string%></td> <!-- string -->
  <td><%xcm boolean:token%>. true|false (System = http://hl7.org/fhir/special-values, однако обычно не требуется<!-- but not usually needed -->)</td> <!-- token -->
  <td><%xcm boolean:reference%></td> <!-- reference -->
  <td><%xcm boolean:quantity%></td> <!-- quantity -->
  <td><%xcm boolean:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#code">code</a></td>
  <td><%xcm code:number%></td> <!-- number -->
  <td><%xcm code:date%></td> <!-- date -->
  <td><%xcm code:string%></td> <!-- string -->
  <td><%xcm code:token%>. Система, при желании, определяется в лежащем в основе наборе значений для каждого кода<!-- (System, if desired, is defined in the underlying value set for eeach code) --></td> <!-- token -->
  <td><%xcm code:reference%></td> <!-- reference -->
  <td><%xcm code:quantity%></td> <!-- quantity -->
  <td><%xcm code:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#date">date</a></td>
  <td><%xcm date:number%></td> <!-- number -->
  <td><%xcm date:date%></td> <!-- date -->
  <td><%xcm date:string%></td> <!-- string -->
  <td><%xcm date:token%></td> <!-- token -->
  <td><%xcm date:reference%></td> <!-- reference -->
  <td><%xcm date:quantity%></td> <!-- quantity -->
  <td><%xcm date:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#dateTime">dateTime</a></td>
  <td><%xcm dateTime:number%></td> <!-- number -->
  <td><%xcm dateTime:date%></td> <!-- date -->
  <td><%xcm dateTime:string%></td> <!-- string -->
  <td><%xcm dateTime:token%></td> <!-- token -->
  <td><%xcm dateTime:reference%></td> <!-- reference -->
  <td><%xcm dateTime:quantity%></td> <!-- quantity -->
  <td><%xcm dateTime:number%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#decimal">decimal</a></td>
  <td><%xcm integer:number%></td> <!-- number -->
  <td><%xcm integer:date%></td> <!-- date -->
  <td><%xcm integer:string%></td> <!-- string -->
  <td><%xcm integer:token%></td> <!-- token -->
  <td><%xcm integer:reference%></td> <!-- reference -->
  <td><%xcm integer:quantity%></td> <!-- quantity -->
  <td><%xcm integer:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#instant">instant</a></td>
  <td><%xcm instant:number%></td> <!-- number -->
  <td><%xcm instant:date%></td> <!-- date -->
  <td><%xcm instant:string%></td> <!-- string -->
  <td><%xcm instant:token%></td> <!-- token -->
  <td><%xcm instant:reference%></td> <!-- reference -->
  <td><%xcm instant:quantity%></td> <!-- quantity -->
  <td><%xcm instant:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#integer">integer</a></td>
  <td><%xcm integer:number%></td> <!-- number -->
  <td><%xcm integer:date%></td> <!-- date -->
  <td><%xcm integer:string%></td> <!-- string -->
  <td><%xcm integer:token%></td> <!-- token -->
  <td><%xcm integer:reference%></td> <!-- reference -->
  <td><%xcm integer:quantity%></td> <!-- quantity -->
  <td><%xcm integer:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#string">string</a></td>
  <td><%xcm string:number%></td> <!-- number -->
  <td><%xcm string:date%></td> <!-- date -->
  <td><%xcm string:string%></td> <!-- string -->
  <td><%xcm string:token%></td> <!-- token -->
  <td><%xcm string:reference%></td> <!-- reference -->
  <td><%xcm string:quantity%></td> <!-- quantity -->
  <td><%xcm string:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#uri">uri</a></td>
  <td><%xcm uri:number%></td> <!-- number -->
  <td><%xcm uri:date%></td> <!-- date -->
  <td><%xcm uri:string%> </td> <!-- string -->
  <td><%xcm uri:token%></td> <!-- token -->
  <td><%xcm uri:reference%></td> <!-- reference -->
  <td><%xcm uri:quantity%></td> <!-- quantity -->
  <td><%xcm uri:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#Address">Address</a></td>
  <td><%xcm Address:number%></td> <!-- number -->
  <td><%xcm Address:date%></td> <!-- date -->
  <td><%xcm Address:string%> Поиск по любому строковому элементу в адресе<!-- search on any string element in the address --></td> <!-- string -->
  <td><%xcm Address:token%></td> <!-- token -->
  <td><%xcm Address:reference%></td> <!-- reference -->
  <td><%xcm Address:quantity%></td> <!-- quantity -->
  <td><%xcm Address:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#Annotation">Annotation</a></td>
  <td><%xcm Annotation:number%></td> <!-- number -->
  <td><%xcm Annotation:date%></td> <!-- date -->
  <td><%xcm Annotation:string%></td> <!-- string -->
  <td><%xcm Annotation:token%></td> <!-- token -->
  <td><%xcm Annotation:reference%></td> <!-- reference -->
  <td><%xcm Annotation:quantity%></td> <!-- quantity -->
  <td><%xcm Annotation:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#CodeableConcept">CodeableConcept</a></td>
  <td><%xcm CodeableConcept:number%></td> <!-- number -->
  <td><%xcm CodeableConcept:date%></td> <!-- date -->
  <td><%xcm CodeableConcept:string%></td> <!-- string -->
  <td><%xcm CodeableConcept:token%></td> <!-- token -->
  <td><%xcm CodeableConcept:reference%></td> <!-- reference -->
  <td><%xcm CodeableConcept:quantity%></td> <!-- quantity -->
  <td><%xcm CodeableConcept:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#Coding">Coding</a></td>
  <td><%xcm Coding:number%></td> <!-- number -->
  <td><%xcm Coding:date%></td> <!-- date -->
  <td><%xcm Coding:string%></td> <!-- string -->
  <td><%xcm Coding:token%></td> <!-- token -->
  <td><%xcm Coding:reference%></td> <!-- reference -->
  <td><%xcm Coding:quantity%></td> <!-- quantity -->
  <td><%xcm Coding:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#ContactPoint">ContactPoint</a></td>
  <td><%xcm ContactPoint:number%></td> <!-- number -->
  <td><%xcm ContactPoint:date%></td> <!-- date -->
  <td><%xcm ContactPoint:string%></td> <!-- string -->
  <td><%xcm ContactPoint:token%></td> <!-- token -->
  <td><%xcm ContactPoint:reference%></td> <!-- reference -->
  <td><%xcm ContactPoint:quantity%></td> <!-- quantity -->
  <td><%xcm ContactPoint:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#Duration">Duration</a></td>
  <td><%xcm Duration:number%></td> <!-- number -->
  <td><%xcm Duration:date%></td> <!-- date -->
  <td><%xcm Duration:string%></td> <!-- string -->
  <td><%xcm Duration:token%></td> <!-- token -->
  <td><%xcm Duration:reference%></td> <!-- reference -->
  <td><%xcm Duration:quantity%></td> <!-- quantity -->
  <td><%xcm Duration:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#HumanName">HumanName</a></td>
  <td><%xcm HumanName:number%></td> <!-- number -->
  <td><%xcm HumanName:date%></td> <!-- date -->
  <td><%xcm HumanName:string%> Поиск по любому строковому элементу в имени<!-- Search on any string element in the name --></td> <!-- string -->
  <td><%xcm HumanName:token%></td> <!-- token -->
  <td><%xcm HumanName:reference%></td> <!-- reference -->
  <td><%xcm HumanName:quantity%></td> <!-- quantity -->
  <td><%xcm HumanName:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#Identifier">Identifier</a></td>
  <td><%xcm Identifier:number%></td> <!-- number -->
  <td><%xcm Identifier:date%></td> <!-- date -->
  <td><%xcm Identifier:string%></td> <!-- string -->
  <td><%xcm Identifier:token%></td> <!-- token -->
  <td><%xcm Identifier:reference%></td> <!-- reference -->
  <td><%xcm Identifier:quantity%></td> <!-- quantity -->
  <td><%xcm Identifier:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#Period">Period</a></td>
  <td><%xcm Period:number%></td> <!-- number -->
  <td><%xcm Period:date%></td> <!-- date -->
  <td><%xcm Period:string%></td> <!-- string -->
  <td><%xcm Period:token%></td> <!-- token -->
  <td><%xcm Period:reference%></td> <!-- reference -->
  <td><%xcm Period:quantity%></td> <!-- quantity -->
  <td><%xcm Period:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#Quantity">Quantity</a></td>
  <td><%xcm Quantity:number%></td> <!-- number -->
  <td><%xcm Quantity:date%></td> <!-- date -->
  <td><%xcm Quantity:string%></td> <!-- string -->
  <td><%xcm Quantity:token%></td> <!-- token -->
  <td><%xcm Quantity:reference%></td> <!-- reference -->
  <td><%xcm Quantity:quantity%></td> <!-- quantity -->
  <td><%xcm Quantity:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#Range">Range</a></td>
  <td><%xcm Range:number%></td> <!-- number -->
  <td><%xcm Range:date%></td> <!-- date -->
  <td><%xcm Range:string%></td> <!-- string -->
  <td><%xcm Range:token%></td> <!-- token -->
  <td><%xcm Range:reference%></td> <!-- reference -->
  <td><%xcm Range:quantity%></td> <!-- quantity -->
  <td><%xcm Range:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#Reference">Reference</a></td>
  <td><%xcm Reference:number%></td> <!-- number -->
  <td><%xcm Reference:date%></td> <!-- date -->
  <td><%xcm Reference:string%></td> <!-- string -->
  <td><%xcm Reference:token%></td> <!-- token -->
  <td><%xcm Reference:reference%></td> <!-- reference -->
  <td><%xcm Reference:quantity%></td> <!-- quantity -->
  <td><%xcm Reference:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#SampledData">SampledData</a></td>
  <td><%xcm SampledData:number%></td> <!-- number -->
  <td><%xcm SampledData:date%></td> <!-- date -->
  <td><%xcm SampledData:string%></td> <!-- string -->
  <td><%xcm SampledData:token%></td> <!-- token -->
  <td><%xcm SampledData:reference%></td> <!-- reference -->
  <td><%xcm SampledData:quantity%></td> <!-- quantity -->
  <td><%xcm SampledData:uri%></td> <!-- uri -->
 </tr>
 <tr>
  <td><a href="datatypes.html#Timing">Timing</a></td>
  <td><%xcm Timing:number%></td> <!-- number -->
  <td><%xcm Timing:date%></td> <!-- date -->
  <td><%xcm Timing:string%></td> <!-- string -->
  <td><%xcm Timing:token%></td> <!-- token -->
  <td><%xcm Timing:reference%></td> <!-- reference -->
  <td><%xcm Timing:quantity%></td> <!-- quantity -->
  <td><%xcm Timing:uri%></td> <!-- uri -->
 </tr>
</table>

</div>

[%file newfooter%]
</body>
</html>

