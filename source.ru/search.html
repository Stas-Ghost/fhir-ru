<!DOCTYPE HTML>


[%settitle Search (RESTful API) %]
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
[%file newheader%]
</head>
<body>
[%file newnavbar%]

<div class="col-9">

<a name="base"> </a>
<h2>Поиск</h2>

<p>
Один из основополагающих аспектов в работе FHIR - это механизм поиска набора ресурсов. Операции поиска ищут в существующем наборе ресурсов в соответствии с критериями поиска, переданными в качестве параметров механизму поиска. На этой странице задокументирована система поиска FHIR от простых примеров до самых сложных случаев. Реализациям требуется внедрить только ту степень сложности, которая им необходима.
</p>
<p>
В простейшем случае поиск выполняется операцией GET в RESTful-системе:
</p>
<pre>
 GET [base]/[resourcetype]?name=value&amp;...
</pre>
<p> 
Для такого RESTful-поиска (см. <a href="http.html#search">определение в RESTful API</a>) параметры представляют собой последовательность пар вида имя=[значение] (name=[value]), кодированных в URL [процентная кодировка] или в формате application/x-www-form-urlencoded для [запроса] POST. Сервер возвращает результаты в HTTP-ответе в виде комплекта (в XML-формате это Atom-фид), который включает в себя ресурсы, являющиеся результатами этого поиска. Сервер также может включить в набор результатов дополнительные ресурсы, например <a href="operationoutcome.html">OperationOutcome</a>. Клиентам следует игнорировать ресурсы, не соответствующие ожидаемому типу. Код HTTP-статуса 403 означает отказ сервера выполнять поиск, тогда как некоторые другие коды вида 4xx или 5xx сигнализируют о том, что произошла какая-то ошибка. 
</p>
<p>
<a href="http.html#search">Операции поиска</a> исполняются в одном из трех заданных контекстов, определяющих, в каком наборе ресурсов будет осуществляться поиск:
</p>
<ul>
 <li>Определенный тип ресурса: GET [base]/[resourcetype]?parameter(s)</li>
 <li>Определенный <a href="extras.html#compartments">модуль</a>, возможно с указанием типа ресурса в этом модуле: GET [base]/patient/[id]/[resourcetype]?parameter(s)</li>
 <li>Все ресурсы: GET [base]/_search?parameter(s)</li>
</ul>
<p>
Операции поиска также могут инициироваться другими, более сложными и гибкими методами, описанными ниже, которые модифицируют и способ запуска поиска, и возвращаемые результаты. 
</p>
<a name="standard"> </a>
<h3>Стандартные параметры</h3>

<a name="all"> </a>
<h4>Параметры для всех ресурсов</h4>
<p>
Эти параметры <a href="resource.html#search">описаны здесь</a> и применяются ко всем ресурсам: [%allparams%].
</p>
<p>
Параметр поиска _id относится к логическому id ресурса и может быть использован, когда в качестве контекста поиска указан тип ресурса:
</p>
<pre>
 GET [base]/Patient?_id=23
</pre>
<p>
В этом примере поиска ищется ресурс patient с указанным id (может быть только один ресурс с таким id). С функциональной точки зрения это эквивалентно <a href="http.html#read">простой операции чтения</a>:
</p>
<pre>
 GET [base]/Patient/23
</pre>
<p>
за исключением того, что он возвращает комплект с требуемым ресурсом, а не сам ресурс. Могут быть добавлены дополнительные параметры, которые  предоставят дополнительную функциональность к этой базовой, эквивалентной чтению.
</p>
<p>
Параметр поиска _language относится к основному языку ресурса:
</p>
<pre>
 GET [base]/Composition?_language=fr
</pre>
<p>
В этом примере поиска ищутся все ресурсы Composition с обозначенным языком French.
Обратите внимание, что это заявленный язык ресурса, а не фактический язык его содержимого.
</p>
<p>
Параметр поиска _lastUpdated может использоваться для выбора ресурсов по дате их последнего изменения:
</p>
<pre>
 GET [base]/Observation?_lastUpdated=>2010-10-01
</pre>
<p>
В этом примере поиска ищутся все Observations, измененные после 1-Окт 2010. При использовании этого параметра поиска приложениям следует принимать во внимание подходы к синхронизации (<a href="http.html#history">RESTful история</a>
или <a href="subscription.html">ресурс Subscription</a>.
</p>
<a name="tag" />
<a name="tags" />
<a name="profile" />

<p>
Параметры поиска _tag, _profile и _security ищут по соответствующим элементам в <a href="resource.html#meta">элементе meta</a>.
Например
</p>
<pre>
 GET [base]/Condition?_tag=http://acme.org/codes|needs-review
</pre>
<p>
ищет все ресурсы Condition с тегом:
</p>
<pre class="json">
{
  "system" : "http://acme.org/codes", 
  "code" : "needs-review"
}
</pre>
<p>
Таким же образом:
</p>
<pre>
 GET [base]/DiagnosticReport?_profile=http://hl7.org/fhir/Profile/lipid
 GET [base]/DiagnosticReport?_profile=Profile/lipid
</pre>
<p>
ограничивает поиск только ресурсами DiagnosticReport с тегом, что они согласуются с определенным профилем. Вторая ссылка относительная и ссылается на локальный профиль на том же сервере.
</p>
<p>
Параметры _tag, _profile и _security имеют тип токен (см. <a href="#token">ниже</a>).
</p>


<h4>Указание параметров для каждого ресурса</h4>
<p>
Кроме параметра _id, который применяется ко всем ресурсам, каждый тип FHIR-ресурса определяет свой собственный набор параметров поиска по именам, типам и значениям. Эти параметры поиска можно найти на той же самой странице, где и определения ресурса, также они опубликованы как часть стандартного заявления о соответствии (<a href="conformance-base.xml.html">XML</a> и <a href="conformance-base.json.html">JSON</a>).
</p>
<p>
Обычно, заданные параметры поиска соответствуют одному элементу в ресурсе, однако это не является обязательным, и некоторые параметры поиска относятся к одному типу элемента в нескольких местах или относятся к их значениям.
</p>
<p>
Некоторые из параметров поиска, заданные ресурсами, ассоциируются с более чем одним путем в ресурсе. Это означает, что этот параметр поиска соответствует, если любой из путей содержит совпадающее содержимое, и который из путей соответствует, ресурс целиком возвращается в результатах поиска. Клиент может потребоваться проверить ресурс, чтобы определить, который из путей содержит совпадение.
</p>
<p>
Серверам не обязательно реализовывать ни один из этих параметров поиска (за исключением параметра _id, описанного выше), и они могут определять свои собственные дополнительные параметры, если хотят. 
</p>

<a name="ptypes" />
<h4>Типы параметров поиска</h4>
<p>Каждый параметр поиска указывается с типом, которые определяет способ поведения параметра поиска. Далее следуют определения типов параметров:
</p>
<%codelist SearchParamType%>
<p>
Эти параметры поиска также могут иметь "модификаторы", добавленные к ним, которые управляют их поведением. Вид модификаторов, который может использоваться, зависит от типа параметра. 
</p>

<a name="modifiers" />
<h4>Модификаторы</h4>
<p>Параметры определены для каждого ресурса, и их имена могут дополнительно указывать модификатор в качестве суффикса, отделенного от имени параметра двоеточием. Модификаторами являются:</p>
<ul>
 <li>Для всех параметров (кроме комбинации): ":missing". Например gender:missing=true (or false). Поиск по "gender:missing=true" вернет все ресурсы, которые не имеют никакого значения параметра gender (что, как правило, приравнивается к отсутствию соответствующего элемента в ресурсе). Поиск по "gender:missing=false" вернет все ресурсы, имеющие значение параметра "gender".</li>
 <li>Для строки: ":exact" (совпадение должно быть точным, не частичным совпадением, чувствительным к регистру и диакритическим знакам), вместо поведения по умолчанию, когда допускается частичное совпадение. Решение о том, выполнять ли левый частичный поиск, остается на усмотрение сервера.</li>
 <li>Для лексемы (token): ":text" (совпадение совершает частичные поиски по части text в CodeableConcept или 
части display в Coding), вместо поиска по умолчанию, который использует коды. Other define modifiers are ";in", ":below", ":above", ":in" and ":not-in" which are described below</li>
 <li>Для ссылки: ":[type]", где [type] - это имя типа ресурса.</li>
</ul>

<a name="number" />
<h4>number</h4>
<p>
В значение параметра могут использоваться префиксы &gt;, &gt;=, &lt;= и &lt; в своем обычном значении (note that "=" must be <a href="http://en.wikipedia.org/wiki/Percent-encoding">URL-encoded</a> in the 
value in a URL). Примеры:
</p>
<table class="grid">
 <tr><td>[parameter]=100</td><td>Значения, равные 100 с точностью до 2 значимых знаков, таким образом диапазон [99.5 ... 100.5)</td></tr>
 <tr><td>[parameter]=100.00</td><td>Значения, равные 100 с точностью до 4 значимых знаков, таким образом диапазон [99.995 ... 100.005). Целые числа также равны 100.00, но не 100.01</td></tr>
 <tr><td>[parameter]=&lt;100</td><td>Значения, которые меньше 100</td></tr>
 <tr><td>[parameter]=&lt;=100</td><td>Значения, которые меньше или равны 100</td></tr>
 <tr><td>[parameter]=&gt;100</td><td>Значения, которые больше 100</td></tr>
 <tr><td>[parameter]=&gt;=100</td><td>Значения, которые больше или равны 100</td></tr>
 <tr><td>[parameter]=!=100</td><td>Values that are not equal to 100. Precision works as for equals (this operation is the logical converse of equals)</td></tr>
</table>
<p>
Для сравнений, включающих &lt; или &gt;, неточность не играет роли, и точность чисел полагается произвольно высокой. Следует отметить, что то, как эти параметры поиска работают здесь, отличается от того, являются ли два числа равными друг другу в математическом смысле.
</p>

<a name="date" />
<h4>date</h4>
<p>
Параметр даты ищет по дате/времени или периоду. Префиксы &gt;, &gt;=, &lt;= и &lt; могут использоваться со значением параметра в своем обычном значении. Однако, как это обычно для связанной с датой/временем функциональности, хотя эти понятия и относительно простые, имеется целый ряд тонкостей, связанных с обеспечением согласованного поведения.
</p>
<ul>
 <li>Формат параметра даты yyyy-mm-ddThh:nn:ss(TZ) (стандартный XML-формат). 
   <ul>
     <li>Технически это любой из типов данных <a href="datatypes.html#date">date</a>, <a href="datatypes.html#dateTime">dateTime</a> и <a href="datatypes.html#instant">instant</a> data types</li>
     <li>например любая степень точности может быть приведена, однако это ДОЛЖНО быть заполнено слева (например нельзя указать месяц без года), за исключением того, что минуты ДОЛЖНЫ присутствовать, если указан час, и вы ДОЛЖНЫ указать часовой пояс, если присутствует время</li>
     <li>Некоторые пользовательские агенты могут экранировать символы ":" в URL, и серверы ДОЛЖНЫ корректно обрабатывать это</li>
   </ul>
 </li>
 <li>[parameter]=[date] ищет ресурсы, где дата соответствует периоду, подразумеваемому данным значением в [date] . "[parameter]=&gt;[date]" [date]" ищет все ресурсы, где указанная дата больше [date]. "[parameter]=&lt;=[date]" =[date]" ищет все ресурсы, где указанная дата равна или меньше [date], и т. д. </li>
 <li>Элемент, к которому относится поиск, может иметь тип данных <a href="datatypes.html#date">date</a>, 
 <a href="datatypes.html#dateTime">dateTime</a>, <a href="datatypes.html#instant">instant</a>, 
 <a href="datatypes.html#Period">Period</a> или <a href="datatypes.html#Schedule">Schedule</a>. 
 Все эти типы, связанные со временем, в действительности задают интервал времени, как, собственно, и сам параметр поиска.
  <ul>
    <li>Для типов Period и Schedule тот факт, что они относятся к интервалу времени, является явным (однако верхняя или нижняя граница может не быть фактически указана в ресурсах)</li>
 	<li>Для типов date и dateTime (и параметра поиска) интервал не выражен явно. Например дата 2013-01-10 указывает на все время от 00:00 10-Jan 2013 до, непосредственно, 00:00 on 11-Jan 2013.</li>
    <li>instant (что то же самое, что и полностью указанная dateTime с миллисекундами) полагается фиксированной точкой во времени с интервалом меньшим, чем точность системы, т. е. интервалом с рабочей шириной 0.</li>
   </ul>
 </li>
 <li>Поиски по параметру даты всегда находят совпадения на основе поведения интервалов, как изложено ниже:
   <ul>
     <li>Для [parameter]=[date] требование состоит в том, что интервал поиска полностью содержит время цели, т. е.  [parameter]=2013-01-14 включает в себя 2013-01-14T00:00 (что очевидно) и также 2013-01-14T10:00, однако не 2013-01-15T00:00</li>
     <li>For [parameter]=!=[date], the requirement is that the search interval does not fully contain the time of the target. i.e. [parameter]=!=2013-01-14 includes 2013-01-15T00:00 but not 2013-01-14T00:00 or 2013-01-14T10:00</li>


	 <li>Для "[parameter]=&lt;[date]" требование состоит в том, что интервал времени до [date] пересекается (т. е. накладывается) с интервалом времени в соответствующем элементе ресурса. Например время ресурса 2013-01-14 включается в набор значений, которые идут ранее 2013-01-14T10:00, потому что он включает часть 14-Jan 2013 до 10am</li>
	 <li>Для "[parameter]=&gt;[date]" требование состоит в том, что интервал времени после [date] пересекается (т. е. накладывается) с интервалом времени в соответствующем элементе ресурса. Например время ресурса 2013-01-14 включено в набор значений, которые идут после 2013-01-14T10:00, потому что он включает часть 14-Jan 2013 после 10am</li>
   </ul>
   Неявно, опущенная нижняя граница "меньше чем" любая фактическая дата. Опущенная верхняя граница "больше чем" любая фактическая дата. Например, период от 21-Jan 2013 и далее включен в совпадения для date=&gt;=2013-03-14, потому что он может включать время после 14-Mar 2013.
 </li>
 <li>Таким же образом, когда параметр даты указан не полностью, совпадения с ним основываются на свойстве интервалов, где:
	<ul>
		<li>Даты, где указан только год, эквивалентны интервалу, который начинается в первое мгновение 1го января до последнего мгновения 31го декабря, например 2000 эквивалентно интервалу [2000-01-01T00:00, 2000-12-31T23:59]</li>
		<li>Даты, где указан год и месяц, эквивалентны интервалу, который начинается в первое мгновение первого дня месяца и заканчивается в последнее мгновение последнего дня месяца, например 2000-04 эквивалентно интервалу [2000-04-01T00:00, 2000-04-30T23:59]</li>
	</ul>
 </li>
 <li>Где это возможно, система должна корректировать часовые пояса при совершении запросов. Даты не имеют часовых поясов, и часовые пояса не должны учитываться. Там, где и параметр поиска, и дата время элемента ресурса не имеют часового пояса, им следует присваивать локальный часовой пояс сервера.
 </li>
 <li>
   Обратите внимание, что для типа данных Schedule указанные подробности расписания игнорируются и только внешние лимиты имеют значение. К примеру расписание, которое определяет каждый второй день между 31-Jan 2013 и 24-Mar 2013, включает в себя 1-Feb 2013, хотя это будет и нечетный день, который не соответствует расписанию. Это делается для того, чтобы сохранить загрузку обрабатывающего запросы сервера разумной.
 </li>
</ul>
<p>
В качестве примера следующий поиск ищет все процедуры в модуле patient, которые произошли за двухлетний период:
</p>
<pre>
 GET [base]/Patient/23/Procedure?date=&gt;2010-01-01&amp;date=&lt;2011-12-31
</pre>


<a name="string" />
<h4>string</h4>
<p>
Строковый параметр относится к простому строковому поиску в последовательностях символов. Совпадения являются нечувствительными к регистру и диакритическим знакам. По умолчанию совпадение существует, если часть значения параметра содержит указанную строку. Решение о том, выполнять ли левый частичный поиск, остается на усмотрение сервера. Модификатор :exact можно использовать для указания, что совпадение должно быть точным (целая строка, включая регистр и диакритические знаки). Например:
</p>
<pre>
 GET [base]/Patient?name=eve
 GET [base]/Patient?name:exact=Eve
</pre>
<p>
 Первое - это запрос на поиск всех пациентов с "eve" в любой части имени. Результат будет включать в себя пациентов с именами "Eve", "Severine" и пр. Второй поиск вернет только пациентов с именем "Eve".
</p>
<p>
 Дополнительный модификатор :text можно использовать для указания поиска с продвинутым управлением текста  (см. <a href="#text">ниже</a>), однако такую возможность предлагает небольшое количество серверов.
</p>
<p>
Решение о том, делать ли предварительную обработку имен, адресов и контактной информации для удаления символов-разделителей до нахождения соответствия, чтобы гарантировать непротиворечивое поведение, остается на усмотрение сервера. Например сервер мог бы удалить все пробелы и символы "-" из телефонных номеров. Что лучше всего подходит, варьируется в зависимости от культуры и контекста.
</p>

<a name="token" />
<h4>token</h4>
<p>
Тип токен - это параметр, который ищет по значению кода или идентификатора, где это значение может иметь URI, который ограничивает свое значение (типы <a href="datatypes.html#Coding">Coding</a>, 
<a href="datatypes.html#CodeableConcept">CodeableConcept</a> и <a href="datatypes.html#Identifier">Identifier</a>, а также <a href="datatypes.html#code">code</a>, где URI не выражен явно).
</p>
<p>
Если у параметра нет модификатора, поиск осуществляется по URI/value из Кодинга или Идентификатора. Синтаксис для этого значения один из следующих:
</p>
<ul>
 <li><b>[parameter]=[code]</b>: значение [code] совпадает с Coding.code или Identifier.value не зависимо от значения свойства "system"</li>
 <li><b>[parameter]=[system]|[code]</b>: значение [code] совпадает с Coding.code или Identifier.value, а значение [system] совпадает со значением свойства "system" в Identifier или Coding</li>
 <li><b>[parameter]=|[code]</b>: значение [code] совпадает с Coding.code или Identifier.value, а Coding/Identifier не содержит свойства "system" </li>
</ul>
<p>
Обратите внимание, что URI пространства имен и код необходимо <a href="#escaping">экранировать</a>.
</p>
<p><b>Модификаторы:</b></p>
<table class="lines">
 <tr> <td><b>Модификатор</b></td> <td><b>Использование</b></td> </tr>
 <tr> <td>:text</td> <td>этот параметр поиска обрабатывается как строка поиска по тексту, ассоциированному с кодом/значением - либо <i>CodeableConcept.text</i>, <i>Coding.display</i>, либо <i>Identifier.label</i></td> </tr>
 <tr> <td>:not</td> <td>изменяет на противоположное совпадение по коду, описанное в параграфе выше</td> </tr>
 <tr> <td>:above</td> <td>параметром поиска является концепт с формой [system]|[code], и он проверяет, включает ли кодинг в ресурсе указанный в поиске код (например поисковый концепт имеет связь "is-a" с кодингом в ресурсе)</td> </tr>
 <tr> <td>:below</td> <td>параметром поиска является концепт с формой [system]|[code], и он проверяет, относится ли кодинг в ресурсе к указанному в поиске коду (например кодинг в ресурсе имеет связь "is-a" с поисковым концептом)</td> </tr>
 <tr> <td>:in</td> <td>параметром поиска является URI (относительный или абсолютный), который идентифицирует набор значений, и поисковый параметр проверяет, входит ли кодинг в указанный  <a href="valueset.html">набор значений</a>. Ссылка может быть буквальной (адрес, где нахоидтся этот набор значений) или логической (ссылка на ValueSet.identifier)</td> </tr>
 <tr> <td>:not-in</td> <td>параметром поиска является URI (относительный или абсолютный), который идентифицирует набор значений, и поисковый параметр проверяет, что кодинг не входит в указанный набор значений</td> </tr>
</table>
<p>
Большинство серверов будут обрабатывать только уже известные/зарегистрированные/поддерживаемые внутри наборы значений, но могут принимать любые валидные ссылки на наборы значений.
Серверы могут учитывать таблицы соответствий концептов при проверке связей категоризации (отнесения объекта к определённой категории).
</p>

<p>
Вот несколько примеров поиска:
</p>
<table>
 <tr><td width="50%"><b>Поисковый запрос</b></td><td><b>Описание</b></td></tr>
 <tr><td><pre> GET [base]/Patient?identifier=http://acme.org/patient|2345</pre></td><td>Ищет всех пациентов с идентификатором с ключом = "2345" в системе "http://acme.org/patient"</td></tr>
 <tr><td><pre> GET [base]/Patient?gender=male</pre></td><td>Ищет всех пациентов с полем gender, имеющим код "male", вне зависимости от системы. Заметим, что это, как правило, не очень полезно - системы обычно определяют символы, где перекрытия являются случайными и не информативными</td></tr>
 <tr><td><pre> GET [base]/Patient?gender=http://hl7.org/fhir/v2/0001|M</pre></td><td>Ищет всех пациентов с полем gender, которое закодированым значением "M" из таблицы HL7 Administrative Gender</td></tr>
 <tr><td><pre> GET [base]/Patient?gender:text=male</pre></td><td>Ищет всех пациентов с полем gender, содержащим текст "male", ассоциированный с ним (примечание: результат будет включать и значение "female")</td></tr>
</table>

<a name="quantity" />
<h4>quantity</h4>
<p>
Параметр величины ищет по типу данных <a href="datatypes.html#Quantity">Quantity</a>. Синтаксис для значения соответствует следующей форме:
</p>
<ul>
 <li><b>[parameter]=[comparator][number]|[system]|[code]</b> соответствует количеству с заданными единицами измерения</li>
</ul>
<p>
Компаратор является необязательным; если не указан, по умолчанию компаратором является "=". Специальное значение "~" может использоваться как символ приближения. Примеры поисков:
</p>

<table>
 <tr><td width="50%"><b>Поисковый запрос</b></td><td><b>Описание</b></td></tr>
 <tr><td><pre> GET [base]/Observation?value=5.4|http://unitsofmeasure.org|mg</pre></td><td>Находит все результаты обследований со значением 5.4 mg, где mg понимается как UCUM-единица измерения (система/код)</td></tr>
 <tr><td><pre> GET [base]/Observation?value=5.4||mg</pre></td><td>Находит все результаты обследований со значением 5.4 mg, где единицей измерений - либо код, либо официально утверждённая человеческая единица измерения - является "mg"</td></tr>
 <tr><td><pre> GET [base]/Observation?value=&lt;5.4|http://unitsofmeasure.org|mg</pre></td><td>Находит все результаты обследований, в которых значение меньше, чем 5.4 mg, где mg понимается как UCUM-единица измерения</td></tr>
 <tr><td><pre> GET [base]/Observation?value=~5.4|http://unitsofmeasure.org|mg</pre></td><td>Находит все результаты обследований со значением около 5.4 mg, где mg понимается как UCUM-единица измерения. Рекомендованное значение приближения 10% от установленного значения, однако системы могут выбирать другие значения, где это необходимо</td></tr>
</table>

<p>
Поисковый процессор может решить выполнить поиск, основанный на <a href="datatypes.html#quantity">канонических единицах измерений</a> (например любое значение, которое может быть преобразовано в значение в миллиграммах, для случая выше)
</p>


<a name="chaining" />
<a name="reference" />
<h4>reference</h4>
<p>
Ссылочный параметр относится к <a href="references.html">ссылкам между ресурсами</a>, например найти все Conditions, где объектом ссылки является определенный пациент, где пациент выбирается по имени или идентификатору. Интерпретация параметра <i>ссылка</i> одна из двух: 
</p>
<ul>
 <li><b>[parameter]=[id]</b> логический [id] ресурса, имеющего локальную ссылку (т. е. относительную ссылку) </li>
 <li><b>[parameter]=[url]</b> где [url] - это абсолютный URL-адрес  - ссылка на ресурс по его абсолютному местоположению</li>
</ul>
<p>
Обратите внимание, что если относительная ссылка разрешается тем же значением, что и указанный абсолютный URL-адрес, либо наоборот, это также считается совпадением.
</p>
<p>
У некоторых ссылок есть возможность указывать на более чем один тип ресурса, например объект : Reference(Patient|Group|Device|..). В таких случаях несколько различных ресурсов могут иметь один и тот же логический идентификатор. В этом случае клиент может указать модификатор типа после имени параметра, чтобы явно задать желаемый тип:
</p>
<pre>
 GET [base]/Condition?subject:Patient=23
</pre>
<p>
Этот запрос ищет все условия (conditions), в которых объект ссылается на ресурс patient с логическим идентификатором "23". Сервер ДОЛЖЕН отклонить поиск, в котором логический идентификатор ссылается на более чем один совпадающий ресурс среди нескольких типов. Следует отметить, что модификатор :[type]  не может быть использован со ссылкой на ресурс, находящийся на другом сервере, т. к. сервер не будет знать, какой тип имеет этот ресурс (но т. к. это абсолютные ссылки, то двусмысленность относительно типа отсутствует).
</p>

<h4>Цепочечные параметры (Chained parameters)</h4>
<p>
Чтобы избавить клиента от необходимости выполнять серию операций поиска, ссылочные параметры могут быть "сцеплены" (объединены в последовательность) добавлением к ним точки (.), за которой следует имя параметра поиска, указанного для целевого ресурса. Это может быть сделано рекурсивно, следуя логическому пути через граф связанных ресурсов, разделенных точкой ".". К примеру дано, что ресурс <a href="diagnosticreport.html">DiagnosticReport</a> 
имеет параметр поиска с именем <i>subject</i>, который обычно является ссылкой на ресурс <a href="patient.html">Patient</a>, и этот ресурс Patient содержит параметр <i>name</i>, который ищет по имени пациента, тогда поиск вида
</p>
<pre>
 GET [base]/DiagnosticReport?subject.name=peter
</pre>
<p>
- это запрос на возвращение всех лабораторных отчетов, в которых имеется объект, чье имя содержит "peter". Так как  объект Diagnostic Report может быть одним из набора различных ресурсов, имеется возможность ограничить поиск определенным типом:
</p>
<pre>
 GET [base]/DiagnosticReport?subject:Patient.name=peter
</pre>
<p>
Это запрос на возвращение всех лабораторных отчетов, имеющих в качестве объекта пациента, чье имя содержит "peter".
</p>

<p>
Примечание к продвинутому поиску: Там, где цепочечный параметр ищет ссылку на ресурс, который может иметь более одного ресурса различного типа в качестве цели, цепочка параметров может заканчиваться ссылкой на параметры поиска с тем же именем на более чем один вид ресурса одновременно. Имена параметров, установленные в FHIR, имеют непротиворечивые типы, где бы они не использовались. Разработчикам, вводящим свои собственные названия, необходимо удостовериться, что они не создают комбинации, которые будет невозможно обработать. Серверам СЛЕДУЕТ отклонять цепочечные запросы, которые ведут к нарушению структуры типов наряду с путем (например клиент должен явно указать тип с помощью синтаксиса во втором примере выше). 
</p>

<a name="composite" />
<a name="combining" />
<h3>Комбинированные параметры поиска</h3>
<p>
Результатом операции поиска является пересечение ресурсов, которые соответствуют критериям, указанным в каждом отдельном параметре поиска. Если параметр повторяется, например /patient?language=FR&amp;language=NL, тогда это соответствует пациенту, который говорит на обоих языках. Это называется параметром поиска И (AND), так как от сервера ожидается ответ с результатами, которые соответствуют обоим значениям.
</p>
<p>
Если, наоборот, поиск ищет пациентов, которые говорят на одном из этих языков, тогда это будет один параметр с несколькими значениями, разделенными запятой ','. 
Например: "/patient?language=FR,NL". Это называется параметром поиска ИЛИ (OR), так как от сервера ожидается ответ с результатами, которые соответствуют одному из значений.
</p>
<p>
AND-параметры и OR-параметры можно комбинировать, например: 
"/patient?language=FR,NL&amp;language=EN" будет относиться к любому пациенту, который говорит на 
английском, а также французском или голландском языках.
</p>
<p>
Это позволяет использовать простые комбинации and/or значений, однако не позволяет поиски, основанные на паре значений, такие как все обследования со значением натрия >150 mmol/L  (в особенности как конечный критерий цепочечного поиска), или поиск по Group.characteristic: вам необходимо найти комбинацию ключ/значение, а не пересечение отдельных совпадений по ключу и значению. Другой пример - это пространственные координаты в географических поисках.
</p>
<p>
Для осуществления этих поисков ресурс может также указать <i>комбинированные</i> параметры, которые принимают последовательность отдельных значений, которые соответствуют другим определенным параметрам в качестве аргумента. Совпадающий параметр каждого компонента в такой последовательности задокументирован в определении этого параметра. Эти последовательности формируются присоединением отдельных значений через символ "$". Обратите внимание, что эта последовательность является отдельным значением и сама может входить в состав набора значений для того чтобы, например, несколько совпадающих параметров state-on-date могли быть указаны наподобие state-on-date=new$2013-05-04,active$2013-05-05.
</p>
<p>
В комбинированных параметрах модификаторы не используются.
<!--
Future note: use \p and \m in search values? if we add a double = to parameter value for text, that would get rid 
of :exact. 
Won't try to get rid of type modifier - that's the real use for modifiers because it has to be in a chaining line. 
Other modifier is :text on token - use "~"? or ""?
-->
</p>

<a name="escaping" />
<h4>Экранирование параметров поиска</h4>
<p>
В правилах выше особые правила определены для символов "$", ",", и "|". Как следствие, если эти символы встречаются в самом значении параметра, они должны отличаться от их использования в качестве разделительных символов. Когда любой из этих символов входит непосредственно в значение параметра, перед ним необходимо добавлять символ "\" (который также должен быть использован для экранирования самого себя). Таким образом 
"param=xxx$xxx" означает комбинированный параметр, в то время как "param=xx\$xx" означает, что этот параметр имеет буквальное значение 'xx$xx'. Значение параметра "xx\xx" является недопустимым, а значение параметра "param=xx\\xx" означает буквальное значение 'xx\xx'.
</p>


<a name="text" />
<h4>Текстовые параметры поиска</h4>
<p>
Имеется два особых параметра текстового поиска, _text and _content, которые ищут по описательной части ресурса и по всему содержимому ресурса соответственно. Эти параметры ДОЛЖНЫ поддерживать тип функциональности продвинутого поиска, предлагаемый типовыми службами индексирования текста, ??? уместно (подходяще). Значением параметра является текстовый поиск, который может включать поиск нескольких слов  по словарю и соображениям близости, и такие логические операции, как AND, OR и т. п. Например:
</p>
<pre>
 GET [base]/Condition?_text=(bone OR liver) and metastases
</pre>
<p>
 Запрос ищет все ресурсы Condition со словами "metastases" и либо "bone", либо "liver" в описательной части. Сервер МОЖЕТ также выбрать поиск по связанным словам.
</p>
<a name="dstu"> </a>
<blockquote>
<p><b>Примечание DSTU</b>: Не все вопросы стандартизации текстового поиска решены. Во время пробного периода использования данной спецификации мы рекомендуем системам использовать правила, описанные в <a href="http://docs.oasis-open.org/odata/odata/v4.0/cs01/part1-protocol/odata-v4.0-cs01-part1-protocol.html#_The_$search_System">
a forth coming release of the OData specification for the $search parameter</a>.
Типовые разработки будут использовать Lucene - полнотекстовый поиск на основе sql-запросов, либо некоторую службу индексирования. Обратную связь о непротиворечивости реализации в этой области можно только приветствовать.
</p>
</blockquote>

<a name="filter"> </a>
<a name="_filter"> </a>
<h4>Расширенные возможности фильтрации</h4>

<p>
Хотя поисковый механизм, описанный выше, гибкий и легко осуществимый для простых случаев, однако он ограничен в способности комбинировать запросы. В дополнение к этому механизму может быть использован особый параметр поискового выражения "_filter".
</p>
<p>
Например такой умеренно простой поиск: найти все результаты обследований пациента с именем, содержащим "peter", которые имеют LOINC-код 1234-5:
</p>
<pre>
GET [base]/Observation?name=http://loinc.org|1234-5&amp;subject.name=peter
</pre>
<p>
С использованием параметра _filter поиск будет выражаться следующим образом:
</p>
<pre>
GET [base]/Observation?_filter=name eq http://loinc.org|1234-5 and subject.name co "peter"
</pre>
<p>
Параметр _filter подробно описан на странице <a href="search_filter.html">"Параметр _Filter"</a>.
</p>

<a name="return"> </a>
<h3>Управление возвращаемыми ресурсами</h3>

<h4>Релевантность</h4>
<p>
Там, где поиск содержит недетерминированную сортировку, алгоритм поиска может сгенерировать некоторую разновидность оценки для ранжирования (расположения в определенном порядке, установления очередности), чтобы обозначить, какие ресурсы отвечают указанным критериям лучше, чем другие. Сервер может вернуть эти оценки в <a href="bundle-definitions.html#Bundle.entry.score">entry.score</a>:
</p>
<pre class="xml">
  &lt;entry&gt;
    &lt;score value=&quot;.45&quot;/&gt;
    &lt;Patient&gt;
      ... patient data ...
    &lt;/Patient&gt;
  &lt;/entry&gt;
</pre>
<p>
score - это десятичное число со значением между (и включительно) 0 и 1. 
</p>

<a name="sort" />
<h4>Сортировка</h4>
<p>
Клиент может указать порядок возвращения результатов с помощью параметра "_sort", который может иметь значением одного из параметров поиска. Параметр _sort может повторяться для указания порядка сортировки с повторением, указывающим более низкий приоритет сортировки последовательно. 
</p>
<p>
Параметр _sort принимает один из двух спецификаторов, ":asc" and ":desc", который указывает возрастающий или убывающий порядок сортировки, соответственно. Значением по умолчанию является ":asc".
</p>
<p>
Примечания:
</p>
<ul>
 <li>При сортировке фактическое значение, используемое для сортировки, не выводится явно сервером для каждого ресурса, только содержимое ресурса</li>
 <li>Для сортировки по релевантности используйте "_sort:asc=_score"</li>
 <li>Сервер возвращает сортировку, которую он совершает как часть возвращаемых параметров поиска (см. <a href="#conformance">ниже</a>)</li>
 <li>Параметр поиска может относиться к элементу, который повторяется, и следовательно могут быть несколько значения для данного параметра поиска для одного ресурса. В таком случае сортировка основывается на элементе в наборе нескольких параметров, которые идут раньше всех в указанном порядке сортировки во время упорядочения возвращаемых ресурсов.</li> 
</ul>


<h4>Количество страниц</h4>

<p>
С целью поддержания загрузки на клиентах, серверах и сети минимизированной, сервер может решить возвращать результаты в виде серии страниц. Набор результатов поиска содержит URL-адреса, которые клиент использует для запроса дополнительных страниц из поискового набора. Для простого RESTful-поиска ссылки на страницы 
<a href="http.html#paging">содержатся в возвращаемом комплекте в виде ссылок</a>.
</p>
<p>
Обычно сервер предоставляет свои собственные параметры в ссылках, которые он использует для управления состоянием поиска во время получения страниц. Эти параметры нет необходимости понимать или обрабатывать клиентом.
</p>

<p>
Параметр _count определяется как подсказка серверу в отношении как много ресурсов следует возвращать на одной странице. Серверам НЕ СЛЕДУЕТ возвращать больше ресурсов, чем запрошено (даже если они не поддерживаю пагинацию), однако разрешается возвращать меньше, чем запросил клиент. Обратите внимание, что решение о том, каким образом обрабатывать происходящие в настоящее время обновление ресурсов во время действия поиска, остается на усмотрение поискового механизма.
</p>

<a name="include" />
<h4>Включение других ресурсов в результат (_include)</h4>
<p>
Клиенты могут запросить, чтобы система вернула дополнительные ресурсы, относящиеся к результатам поиска, с целью уменьшения общую сетевую задержку. Типичный случай, когда это полезно, это когда клиент ищет некоторый тип клинического ресурса, однако для каждого возвращения такого ресурса клиенту также нужен ресурс-объект (пациент), к которому относится клинический ресурс. Клиент запрашивает включение зависимых ресурсов в набор результатов указанием одного или нескольких параметров _include.
</p>
<p>  
Каждый параметр _include содержит путь к URL (обычно ссылку на ресурс):
</p>
<pre>
 GET [base]/MedicationDispense?_include=MedicationDispense.authorizingPrescription
    &amp;_include=MedicationPrescription.prescriber&amp;criteria...
</pre>
<p>
Для каждого возвращаемого ресурса сервер собирает элементы, описанные в пути, и все ресурсы, на которые они указывают, что сервер также хранит, добавляются к результату,
with the <a href="bundle-definitions.html#Bundle.entry.status">entry.status</a>
set to "include" (in some searches, it is not obvious which resources are 
matches, and which are includes). 
Этот пример поиска возвращает все ресурсы типа <a href="medicationprescription.html">Medication 
Prescription</a> и их ресурсы <a href="practitioner.html">prescribing Practitioner</a> для соответствующих ресурсов <a href="medicationdispense.html">Medication Dispense</a>.
</p>
<h4>Пути включения (Include Paths)</h4>
<p>
Путь включения начинается как корень FHIR-ресурса и должен включать в точности одно свойство типа <a href="references.html#Identification">Reference</a> или <a href="datatypes.html#uri">uri</a>, 
которое должно быть в последней позиции. Это значит, что путь включения не может "пересекать границы" из одного ресурса к другому. Поэтому например `CarePlan.activity.simple.performer` является допустимым путем включения, потому что он начинается в корне ресурса CarePlan и заканчивается ссылкой на другой ресура (Practitioner|Organization|RelatedPerson|Patient). С другой стороны `CarePlan.patient.managingOrganization` является недопустимым путем включения, потому что он содержит два 
References (patient и managingOrganization), и `CarePlan.goal` является недопустимым путем включения, потому что он не заканчивается Reference или URI.
</p>
<p>
Во время поиска ссылок, указанных с помощью пути включения, все вхождения компонента, встретившиеся последний раз по этому пути, необходимо рассматривать, включая вхождения это же самого компонента, доступные через более глубокие (вложенные) отношения. Примером является путь включения  Composition.section.content, где ссылка на содержимое на высшем уровне Section включено, однако также те доступные через вложенную зависимость section. Подобно этому, Questionnaire.group.subject вернет все субъекты по всем Groups, включая доступные с более глубоким путем через вложенный Question и вложенный Groups внутри этих вопросов.
</p>
<p>
Пути включения могут содержать шаблоны подстановки, например MedicationDispense.results.*, или даже _include=*,
хотя и клиентам, и серверам требуется заботиться о том, чтобы не запрашивать или возвращать слишком много ресурсов, выполняя это. Наиболее примечательно, что повторное применение путей включения надо заново включенными ресурсами могло бы привести к циклам или получения полного файла пациента: ресурсы организованы в связанную сеть и широкие пути _include могут в конце концов обойти все возможные пути на сервер. Для серверов эти рекурсивные и с шаблонами подстановки _includes являются требовательными и могут существенно замедлить время отклика поиска. От серверов ожидается ограничить число совершаемых итераций и не требуется выполнять запросы на включение дополнительных ресурсов в результаты поиска. 
</p>
<p>
<b>Примечание</b>: от сервера в основном будет требоваться только одна итерация на параметр _include
</p>

<h4>Внешние ссылки</h4>
<p>
Если путь _include выбирает ссылку, которая относится к ресурсу на другом сервере, сервер может предпочесть включить этот ресурс в результаты поиска для удобства клиента.
</p>
<p>
Если путь _include выбирает ссылку, которая относится к сущности, не являющейся Ресурсом (например вложенное изображение), сервер может также решить включить это в возвращаемые результаты в виде <a href="extras.html#binary">Binary</a> ресурса. Например, путь включения может указывать на вложение с помощью ссылки, как здесь:
</p>
<pre>
 &lt;content&gt;
   &lt;contentType&gt;image/jpeg&lt;/contentType&gt;
   &lt;url&gt;http://example.org/images/2343434/234234.jpg&lt;/url&gt;
 &lt;/content&gt;
</pre>
<p>
Сервер может запросить цель этой ссылки и добавить её к результатам для удобства клиента.
</p>

<a name="dstu-2"> </a>
<blockquote>
<p><b>Примечание DSTU</b>: HL7 ожидает фидбеков от разработчиков о том, следует ли ввести дополнительные правила работы _include, основанных на опыте внедрения.
</p>
</blockquote>


<h4>Пагинация (разбиение на страницы)</h4>
<p>
При возвращении разбитых на страницы результатов поиска с ресурсами _include, все _include-ресурсы, относящиеся к первичным ресурсам, возвращаемым на странице, ДОЛЖНЫ также быть возвращены в рамках этой же страницы, даже если некоторые их этих экземпляров ресурсов уже были ранее показаны на предыдущих страницах. Это позволит и отправителю, и получателю избежать кеширования результатов на других страницах.
</p>

<a name="summary"> </a>
<h4>Ресурсы с кратким содержанием (Summary)</h4>
<p>
Клиент может запросить сервер вернуть только суммарные ресурсы с помощью параметра "_summary":
</p>
<pre>
   GET [base]/ValueSet?_summary=true
</pre>
<p>
Параметр <i>_summary</i> требует от сервера вернуть только те элементы, которые помечены как "summary" в своем определении. Это используется для уменьшения общей загрузки на сервер, на клиента и на ресурсы между ними, например на сеть. Наиболее применимо к ресурсам, которые могут быть большими, особенно те, что включают изображения или элементы, повторяющиеся много раз.
</p>
<p>
Серверы не обязаны возвращать только суммарные ресурсы, а суммарность не определена для ресурсов, где нет необходимости в резюмировании. Имеется только одна краткая форма, определенная для каждого ресурса, чтобы позволить серверам хранить резюмированную форму заранее.
</p>

<a name="conformance" />
<h3>Заключение о соответствии сервера (Server Conformance)</h3>
<p>
Чтобы позволить клиенту быть уверенным о том, что параметры поиска были использованы сервером в качестве критериев, серверу СЛЕДУЕТ возвращать параметра, которые были фактически использованы при обработке поиска. Приложениям, обрабатывающим результаты поиска, следует проверять эти возвращаемые значения при необходимости. Например, если сервер не поддерживает некоторые фильтры, указанные в поиске, клиент мог бы вручную применить эти фильтры к полученному набору результатов, показать предупреждающее сообщение пользователю или совершить какое-то другое действие.
</p>
<p>
В случае RESTful-поиска эти параметра закодированы в ссылку с типом отношения self в ATOM-фиде, который будет возвращен:
</p>
<pre class="xml">
  &lt;link&gt;
    &lt;relation value="self"/&gt; 
    &lt;url value="http://example.org/Patient?name=peter"/&gt;
  &lt;/link&gt;
</pre>
<p>
В остальном серверы имеют значительную свободу действий в отношении поддерживаемого поиска:
</p>
<ul>
 <li>Серверы могут выбирать, какие параметры поддерживать (кроме _id выше)</li>
 <li>Серверы могут выбирать, когда и где применять формирование цепочки параметров, и когда и где они поддерживают параметр _include</li>
 <li>Серверы могут объявлять дополнительные параметры в профилях, на которые есть ссылки из их заявлений о соответствии. Серверам следует определять параметры поиска, начинающиеся с символа "-", чтобы гарантировать, что имена, они выбрали, не будут конфликтовать с параметрами, определенным в данной спецификации в будущем</li>
 <li>От серверов не требуется навязывать чувствительность к регистру именам параметров, хотя имена являются чувствительными к регистру (и URL-адреса в основном являются регистрозависимыми)</li>
 <li>Серверы могут выбирать, сколько результатов возвращать, хотя клиент может использовать _count как описано выше</li>
 <li> Серверы могут выбирать способ сортировки возвращаемых результатов, хотя они ДОЛЖНЫ принимать на обработку параметр _sort</li>
</ul>

<hr/>
<a name="advanced"> </a>
<h3>Продвинутый поиск</h3>
<p>
Система поиска, описанная выше - это пригодная основа для обеспечения простого поиска, основанного на индексированных критериях, однако необходима возможность более сложных запросов для обработки точных запросов, комбинированных  требований для поддержки принятия решений, и прямых запросов, имеющих человеческую интерпретацию.
</p>
<p>
Более продвинутые операции поиска определяются параметром _query:
</p>
<pre>
   GET [base]/Patient?_query=name&amp;parameters...
</pre>
<p>
 Параметр _query присваивает имя пользовательскому профилю поиска, который описывает определенную операцию поиска. Именованный запрос может определять дополнительные именованные параметры, которые используются с этим конкретным именованным запросом. Серверы могут определять свои собственные дополнительные именованные запросы для удовлетворения собственных нужд с помощью <a href="operationdefinition.html">OperationDefinition</a>.
</p>
<p>
 В наборе параметров поиска может быть всего один параметр _query. Серверы, обрабатывающие запросы поиска, ДОЛЖНЫ отказывать в обработке запроса поиска, если они не могут распознать значение параметра _query.
</p>

<h3>Выполнение поиска</h3>
<p>
В дополнение к стандартной операции <a href="http.html#search">поиска</a> в RESTful-интерфейсе (описанной выше), поиск может быть также выполнен с помощью фреймворка обмена сообщениями.
</p>
<p>
<i>TODO: describe how this is done</i>
</p>

<a name="currency"> </a>
<h3>Актуальность результатов поиска</h3>

<p>
 Актуальность результатов операции поиска гарантируется только на момент выполнения операции. После того, как операция выполнена, продолжающиеся в настоящее время действия, совершаемые над ресурсами, полученными с помощью выполнения поиска, будут делать результаты всё более и более неактуальными. Значимость этого зависит от типа поиска и вида использования результатов.
</p>
<p>
 В частности, это важно, когда сервер возвращает результаты в виде ряда страниц. Решение о том, каким образом обрабатывать происходящие в настоящее время обновления ресурсов во время действия поиска, остается на усмотрение поискового механизма.
</p>
<p>
Следует отметить, что выполнение операции поиска не меняет набор ресурсов на сервере, за исключением создания ресурсов <a href="securityevent.html">Security Event</a>, которые выполняют аудит самого поиска.
</p>

</div>

[%file newfooter%]
</body>
</html>

