<!DOCTYPE HTML>
      
[%settitle Element Definition%]
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
[%file newheader%]
</head>
<body>
[%file newnavbar%]

<div class="col-9">


<!--
 no repeating primitives in datatypes? No id's on primitives in datatypes...No dar on primitives in datatypes. It would be worthwhile to document that and the reason for it.
-->

<%edheader base%>
<h1>Element Definition</h1>

<p>
Introduction
</p>

<a name="definition"></a>
<h2 style="margin-bottom: 1px">
Content
</h2>

[%dt ElementDefinition%]

<p>
Commentary
</p>

<div class="use">
<p><b>Constraints</b></p>
[%dt.constraints ElementDefinition%]
<p>
Further Commentary
</p>
</div>

<h2>Interpretation of ElementDefinition in different contexts</h2>
<p>The pseudo-datatype <code>ElementDefinition</code> is used both in <code>StructureDefinition</code> and <code>ExtensionDefinition</code>, and even within  those resources, the way its elements are to be used and interpreted depend on the context where <code>ElementDefinition</code> used.</p>
<!-- ### Visual
<table>
	<tr><th>Element</th><th>Root element<br/>of a structure</th><th>Nested element<br/>in structure
	<th>Slice<br/>entry</th><th>Simple<br/>extension</th><th>Root element<br/>of extension</th>
	<th>Nested element<br/>in extension</th></tr>
	<tr><td>path</td><td align="center"><img src="ok.png"><a href="#note1">1</a></td></tr>
</table>  -->
<h3>Common properties</h3>
<ul>
<li><code>short</code>, <code>formal</code>, <code>comments</code>, <code>requirements</code>, <code>synonym</code> can be used in any context to convey a change to the interpretation of the constrained element as compared to the base definition.</li>
<li><code>condition</code> and <code>constraint</code> may be used in all contexts</li>
<li><code>mapping</code> may be used in all contexts</li>
</ul>

<h3>First (root) element in a structure</h3>
<ul>
<li><code>path</code> is equal to the name of the type indicated in Structure.type</li>
<li><code>representation</code> may not be used</li>
<li><code>name</code> associates a name </li>
<li><code>slicing</code> may not be used</li>
<li><code>min</code> and <code>max</code> may not be used</li>
<li><code>type</code> is set to &quot;Resource&quot; for constraints on Resources, &quot;Element&quot; for constraints on data types</li>
<li><code>nameReference</code> may not be used</li>
<li><code>fixed</code>, <code>pattern</code> indicate a value that an instance of a while complex type constrained by this structure must match. May be used instead of applying constraints to the nested elements of the datatype.</li>
<li><code>example</code> example value for a complex type in an instance that complies to the structure</li>
<li><code>maxLength</code> may not be used</li>
<li><code>mustSupport</code> may not be used</li>
<li><code>isModifier</code> may not be used</li>
<li><code>isSummary</code> may not be used</li>
<li><code>binding</code> may not be used</li>
</ul>
<h3>Nested element in a structure</h3>
<ul>
<li><code>representation</code> may only be used on elements of a primitive type (and currently only on the &quot;value&quot; element of FHIR primitive types and &quot;url&quot; element of Extension)</li>
<li><code>slicing</code> can only be used on the first repeat of an element, this element is considered the slicing entry</li>
<li><code>mustSupport</code> may be used, but if it is not present it defaults to &quot;false&quot;</li>
<li><code>isModifier</code> must be the same as the base definition for the datatype or Resource</li>
<li><code>isSummary</code> must be the same as the base definition for the datatype or Resource</li>
</ul>
<h3>Element in a structure acting as the slicing entry</h3>
<p>The <code>ElementDefinition</code> is understood to be the set of constraints to be used for the &quot;open&quot; slice, i.e. when the slice is open, this definition is used as a constraint on elements in the instance that are not part of a slice and belong to the open portion of the slice. Its use follows the &quot;normal case&quot;, except:</p>
<ul>
<li><code>representation</code> may not be used</li>
<li><code>name</code> may not be used?</li>
<li><code>slicing</code> must be present</li>
<li><code>min</code> and <code>max</code> are considered to govern the number of total occurrences of the sliced element including the number of occurrences in the open portion of the slice. </li>
<li><code>isModifier</code> must be the same as the base definition for the datatype or Resource</li>
<li><code>isSummary</code> must be the same as the base definition for the datatype or Resource</li>
</ul>
<h3>Only element in a simple extension</h3>
<ul>
<li><code>path</code> is equal to ExtensionDefinition.name</li>
<li><code>representation</code> may not be used</li>
<li><code>name</code> may not be used</li>
<li><code>slicing</code> may be used to express constraints on the use of specific types when the element allows a choice of type (name ends in [x])</li>
<li><code>min</code>, <code>max</code> defines the allowed number of occurrences of this extension in an instance. Actual use in the target context of an extension may governed by slicing the (modifier)extension element of the target and must be compatible with this number. Note that having a min &gt; 0 can only be guaranteed where such slicing rules are in place in the target.</li>
<li><code>type</code> indicates the (choice of) types of the extension's value</li>
<li><code>nameReference</code> may not be used</li>
<li><code>mustSupport</code> may be used, but if it is not present it defaults to &quot;false&quot;</li>
<li><code>isModifier</code> indicates whether the extension appears in the &lt;extension&gt; of &lt;modifierExtension&gt; element in the instance. If it is not present it defaults to &quot;false&quot;</li>
<li><code>isSummary</code> indicates whether the extension will appear in a summary</li>
</ul>
<h3>First (root) element in a complex extension</h3>
<ul>
<li><code>path</code> is equal to ExtensionDefinition.name</li>
<li><code>representation</code> may not be used</li>
<li><code>name</code> may not be used</li>
<li><code>slicing</code> may not be used</li>
<li><code>min</code>, <code>max</code> defines the allowed number of occurrences of this extension in an instance. Actual use in the target context of an extension may governed by slicing the (modifier)extension element of the target and must be compatible with this number. Note that having a min &gt; 0 can only be guaranteed where such slicing rules are in place in the target.</li>
<li><code>type</code> is set to <code>Extension</code></li>
<li><code>nameReference</code> may not be used</li>
<li><code>fixed</code>, <code>pattern</code> may not be used. (Lloyd may describe a usecase)</li>
<li><code>example</code> example value for the complex extension in an instance</li>
<li><code>maxLength</code> may not be used</li>
<li><code>mustSupport</code> may not be used</li>
<li><code>isModifier</code> indicates whether the extension appears in the &lt;extension&gt; of &lt;modifierExtension&gt; element in the instance. If it is not present it defaults to &quot;false&quot;</li>
<li><code>isSummary</code> indicates whether the extension will appear in a summary (depends on modifierExtension?)</li>
<li><code>binding</code> may not be used</li>
</ul>
<h3>Nested element in a complex extension</h3>
<ul>
<li><code>representation</code> may not be used</li>
<li><code>slicing</code> may be used to express constraints on the use of specific types when the element allows a choice of type (name ends in [x])</li>
<li><code>mustSupport</code> may be used, but if it is not present it defaults to &quot;false&quot;</li>
<li><code>isModifier</code> may be used, but if it is not present it defaults to &quot;false&quot;</li>
</ul>


<p>
ElementDefinition is used in the following places: [%dtusage ElementDefinition%]
</p>

</div>

[%file newfooter%]
  
</body>
</html>
