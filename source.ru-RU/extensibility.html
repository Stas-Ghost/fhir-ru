<!DOCTYPE HTML>



[%settitle Extensibility%]
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
[%file newheader%]
</head>
<body>
[%file newnavbar%]


<div class="col-12">

<%extheader base%>

<a name="root"></a>
<h1>Extensibility</h1>
<table class="colsn"><tr><td id="wg"><a _target="blank" href="[%wg fhir%]">[%wgt fhir%]</a> Work Group</td><td id="fmm"><a href="versions.html#maturity">Maturity Level</a>: 5</td><td id="ballot"><a href="ballot-intro.html#process">Ballot Status</a>:<!--!ns!--><a href="versions.html#std-process">Normative</a></td></tr></table>
[%normative page infrastructure%]

<p>
Данный стандарт обмена данными основывается на универсальных и общепринятых клинических требованиях, учитывает 
различные функциональные подходы, соответствует предметным областям здравоохранения и реалиям стран и территорий мира. Для конкретных реализаций характерно иметь действующие требования, которые не являются частью этих согласованных общепринятых требований. Стремление учесть все возможные требования в рамках одной спецификации сделало бы её слишком объёмной и труднореализуемой. Поэтому ожидается, что все специфические требования будут реализованы в расширениях.
This exchange specification is based on generally agreed common
requirements across healthcare - covering many jurisdictions, domains, and
different functional approaches. It is common for
specific implementations to have valid requirements that are not
part of these agreed common requirements. Incorporating all valid requirements
would make this specification very cumbersome and difficult to
implement. Instead, this specification expects that additional
valid requirements will be implemented as extensions.
</p>
<p>
По существу, расширения - это фундаментальная часть проекта этой спецификации. Любой элемент ресурса может иметь элемент-потомок, 
являющийся его расширением (extension), для представления дополнительной информации, которая не входит в базовое 
определение ресурса (basic definition of the resource). Приложения не должны отказываться от обработки ресурса только
из-за наличия расширений, однако причиной отказа может служить содержимое расширения.
As such, extensibility is a fundamental part of the design of this
specification. Every element in a resource can have extension child elements
to represent additional information that is not part of the basic definition
of the resource. Applications should not reject resources merely because
they contain extensions, though they may need to reject resources
because of the specific contents of the extensions.
</p>
<p>
Обратите внимание, что, в отличие от других стандартов, FHIR не имеет "предрассудков" в отношении использования 
расширений каким-либо программным обеспечением, проектом или стандартом вне зависимости от учреждения или страны или 
территории, определяющей раcширение. Использование расширений позволяет спецификации FHIR сохранить свою простоту для 
каждого.
Note that, unlike in many other specifications, there can be no stigma
associated with the use of extensions by any application, project, or
standard - regardless of the institution or jurisdiction that uses or defines the
extensions.  The use of extensions is what allows the FHIR specification to retain a core
simplicity for everyone.
</p>
<p>
Для того чтобы сделать применение расширений безопасным и контролируемым, были приняты строгие правила их определения и 
использования. Хотя разработчики могут самостоятельно давать определения и использовать расширения, существует набор 
требований, соблюдение которых обязательно.
To make the use of extensions safe and manageable, there is
strict governance applied to the definition and use of extensions. Although
any implementer can define and use extensions, there is a set of requirements
that must be met as part of their use and definition.
</p>
<a name="Extension"></a>
<a name="extension"></a>
<h2>Элемент "extension"</h2>
<p>
Все элементы в ресурсе или типы данных могут иметь неограниченное число необязательных элементов-потомков "extension". Ниже представлена модель содержимого расширения, применимая ко всем ресурсам:
Every element in a resource or data type includes an optional "extension" child element that may
be present any number of times. This is the content model of the extension as it appears in each resource:
</p>
<%dt Extension 1%>
<p>
Примечания:
</p>
<ul>
 <li><code>url</code> - это обязательный атрибут / свойство, который используется как идентификатор извлекаемого <a href="defining-extensions.html">extension definition</a>, применяемого по отношению к данному ресурсу и определяющего содержимое и семантику элемента расширения
The <code>url</code> is a mandatory attribute / property and identifies a retrievable <a href="defining-extensions.html">extension definition</a> that defines the content and meaning of the extension</li>
 <li>The <code>url</code> SHALL be a URL, not a URN (e.g. not an OID or a UUID), and it SHALL be the canonical URL of a StructureDefinition that defines the extension. Except for child extensions defined within complex extensions, the URL SHALL be an absolute URL. </li>
 <li>The structure definitions for the extension SHOULD be available to consumers of an instance.  The preferred mechanisms for achieving this availability are the direct resolvability of the extension's canonical URL and/or the publishing of the extension definition on a registry that is available and known to those systems that will be consuming the instances containing the extension</li>
 <li>Расширение ДОЛЖНО иметь либо значение (т. е. элемент value[x]), либо вложенные расширения, но не и то, и другое. Если присутствует, элемент value[x] ДОЛЖЕН иметь содерижмое (атрибует value или другие элементы)
An extension SHALL have either a value (i.e. a value[x] element) or sub-extensions, but not both. If present, the value[x] element SHALL have content (value attribute or other elements)</li>
 <li>Если для приложения, обрабатывающего содержимое ресурса, не безопасно игнорировать расширение, то следует использовать <a href="#isModifier">Modifier Extension</a> вместо элемента <code>extension</code>.
If it is not safe for an application processing the content of the resource to ignore the extension it SHALL be represented using a <a href="#isModifier">Modifier Extension</a> rather than an <code>extension</code> element</li>
 <li>There are a few resources (ones that do not specialize <a href="domainresource.html">DomainResource</a>) where extensions are not allowed on the root element, but extensions can appear elsewhere through the resource</li>
 <li>Фактическим именем элемента <i>value[x]</i> является слово "value", к которому добавляется с большой буквы имя одного из следующих определенных типов, а его содержимым будет то, которое определено для этого типа: <a name="list"></a>
The <i>value[x]</i> element has an actual name of "value" and then the TitleCased name of one of these defined types, and its contents are those as defined for that type: <a name="list"></a>
  <ul class="dense">
   [%extension-type-list%]
  </ul>
 </li>
</ul>
<div class="example">
<p>
Вот пример расширения в XML-формате (<a href="extension-iso21090-en-use.html">см. определение</a>):
Here is an example of an extension in XML (<a href="extension-iso21090-en-use.html">see definition</a>):
</p>
<pre class="xml" fragment="HumanName">
&lt;name&gt;
  &lt;extension url=&quot;http://hl7.org/fhir/StructureDefinition/iso-21090-EN-use&quot; &gt;
    &lt;valueCode value=&quot;I&quot; /&gt;
  &lt;/extension&gt;
  &lt;text value=&quot;Chief Red Cloud&quot;/&gt;
&lt;/name&gt;
</pre>
<p>
В этом примере элемент name с текстом = "Chief Red Cloud" расширен кодом использования со значением "Indigenous" (определено в ISO 21090, однако редко используется на практике).
In this example the name with text = "Chief Red Cloud" is extended to have a
name use code of "Indigenous" (defined in ISO 21090, but very rarely used in
practice).
</p>
<p>
В JSON-формате расширения описываются точно также:
</p>
<pre class="json" fragment="HumanName">
{
  "extension" : [{
    "url" : "http://hl7.org/fhir/StructureDefinition/iso-21090-EN-use",
    "valueCode" : "I"
  }],
  "text" : "Chief Red Cloud"
}
</pre>
</div>
<p>
Явное указание типов в представлении означает, что все системы могут читать и писать (и, следовательно, хранить и/или обмениваться) расширениями корректно без необходимости доступа к определению расширения.
Making the types explicit in the representation means that all systems can read and write
(and therefore store and/or exchange) extensions correctly without needing to access the
definition of the extension.
</p>
<p>
Отметьте, что JSON-представление расширений для примитивных типов данных обрабатывается по-другому. См. более подробную информацию в разделе <a href="json.html#primitive">Представление примитивных типов в JSON</a>.
Note that the JSON representation for extensions on primitive data types is handled
differently. See <a href="json.html#primitive">Representing primitive types in JSON</a> for further information.
</p>
<p>
Расширения также могут содержать расширения либо потому, что определение расширения само описывает сложносоставное содержимое - то есть вложенное дерево значений в расширении, либо потому, что расширение расширено дополнительным расширением, определенным отдельно.
Extensions can also contain extensions, either because the extension
definition itself defines complex content - that is, a nested tree of values
in the extension - or because the extension is extended with an additional
extension defined separately.
</p>
<p>
В случае, когда расширение описывает сложное содержимое, идентификаторы частей расширения являются локальными/относительными по отношению к ссылке на определение расширения.
In the case where an extension defines complex content, the identity of the parts of the extension are local/relative to the reference
to the extension definition.
</p>

<div class="example">

<p>
As an example, consider extending a patient with information about citizenship (<a href="extension-patient-citizenship.html">see definition</a>) containing 2 fields: code and period. In XML:
</p>
<pre class="xml" fragment="Patient">
&lt;Patient&gt;
  &lt;extension url=&quot;http://hl7.org/fhir/StructureDefinition/patient-citizenship&quot; &gt;
    &lt;extension url=&quot;code&quot; &gt;
      &lt;valueCodeableConcept&gt;
        &lt;coding&gt;
          &lt;system value=&quot;urn:iso:std:iso:3166&quot; /&gt;
          &lt;code value=&quot;DE&quot; /&gt;
        &lt;/coding&gt;
      &lt;/valueCodeableConcept&gt;
    &lt;/extension&gt;
    &lt;extension url=&quot;period&quot; &gt;
      &lt;valuePeriod&gt;
        &lt;start value=&quot;2009-03-14&quot; /&gt;
      &lt;/valuePeriod&gt;
    &lt;/extension&gt;
  &lt;/extension&gt;
  &lt;!-- other data for patient --&gt;
&lt;/Patient&gt;
</pre>
<p>
Или в JSON:
</p>
<pre class="json" fragment="Patient">
{
  "resourceType" : "Patient",
  "extension" : [{
    "url" : "http://hl7.org/fhir/StructureDefinition/patient-citizenship",
    "extension" : [{
      "url" : "code",
      "valueCodeableConcept" : {
          "coding" : [{
             "system" : "urn:iso:std:iso:3166",
             "code" : "DE"
          }]
       }
    }, {
      "url" : "period",
      "valuePeriod" : {
         "start" : "2009-03-14"
      }
    }]
	}]
}
</pre>
</div>
<p>
This extension can be extended again, by adding a "passport-number" extension:
</p>
<div class="example">
<p>
Номер паспорта определен как отдельное расширение (например организацией-реализатором), а не как часть официального расширения clinical-trial. Поэтому URL-адрес расширения будет другим. В XML:
The passport number is defined as a separate extension (e.g. by
an implementing organization, not in this specification) rather than part of the official citizenship extension.
The URL of the extension is thus different. In XML:
</p>
<pre class="xml" fragment="Patient">

&lt;Patient&gt;
  &lt;extension url=&quot;http://hl7.org/fhir/StructureDefinition/patient-citizenship&quot; &gt;
    &lt;extension url=&quot;code&quot; &gt;
      &lt;valueCodeableConcept&gt;
        &lt;coding&gt;
          &lt;system value=&quot;urn:iso:std:iso:3166&quot; /&gt;
          &lt;code value=&quot;DE&quot; /&gt;
        &lt;/coding&gt;
      &lt;/valueCodeableConcept&gt;
    &lt;/extension&gt;
    &lt;extension url=&quot;period&quot; &gt;
      &lt;valuePeriod&gt;
        &lt;start value=&quot;2009-03-14&quot; /&gt;
      &lt;/valuePeriod&gt;
    &lt;/extension&gt;
    &lt;extension url=&quot;http://acme.org/fhir/StructureDefinition/passport-number&quot; &gt;
        &lt;valueString value=&quot;12345ABC&quot; /&gt;
      &lt;/extension&gt;
    &lt;!-- other data for patient --&gt;
  &lt;/extension&gt;
&lt;/Patient&gt;
</pre>
<p>
или в JSON:
</p>
<pre class="json" fragment="Patient">

{
  "resourceType" : "Patient",
  "extension" : [{
    "url" : "http://hl7.org/fhir/StructureDefinition/patient-citizenship",
    "extension" : [{
      "url" : "code",
      "valueCodeableConcept" : {
        "coding" : [{
          "system" : "urn:iso:std:iso:3166",
          "code" : "DE"
        }]
      }
    },{
      "url" : "period",
      "valuePeriod" : {
        "start" : "2009-03-14"
      }
    },
		{
      "url": "http://acme.org/fhir/StructureDefinition/passport-number",
      "valueString": "12345ABC"
    }]
  }]
}
</pre>
</div>

<a name="mustUnderstand"></a>
<a name="isModifier"></a>
<a name="modifierExtension"></a>
<h2>Элементы-расширения, изменяющие значения ресурса (Modifier Extensions)</h2>
<p>
В некоторых случаях содержащаяся в расширении информация изменяет значение родительского элемента. 
Обычно это означает, что элемент "extension" выполняет логическую функцию отрицания (negation) или уточняет (qualifier) 
значение родительского элемента. Рассмотрим некоторые примеры:
There are some cases where the information provided in an extension modifies the meaning
of the element that contains it. Typically, this means information that qualifies or
negates the primary meaning of the element that contains it. Some examples:
</p>
<ul>
 <li>Антипредписание: с помощью элемента "extension" можно выразить <b>запрет</b> на прием лекарственного средства
An anti-prescription: recording an instruction <b>not</b> to take a medication</li>
 <li>Элемент "extension" ресурса <a href="condition.html">Condition (Клиническое состояние)</a> позволяет сформировать запись, в которой говорится о том, что у пациента есть не само это клиническое состояние, а запись о нем в семейном анамнезе
Using the <a href="condition.html">Condition</a> resource to record an assertion that a patient has a family history of the condition rather than the condition itself</li>
 <li>Элемент "extension" информирует о том, что исполнитель (performer) <b>не</b> принимал участие в выполнении<a href="procedure.html">процедуры (Procedure)</a>
Asserting that a performer was <b>not</b> actually involved in a <a href="procedure.html">Procedure</a></li>
 <li>Элемент "extension" декларирует дополнительную взаимосвязь категоризации для концепта в <a href="valueset.html">value set</a>
Asserting an additional subsumption relationship on a concept in a <a href="valueset.html">value set</a></li>
</ul>
<p>
Такие расширения называются расширениями-модификаторами.
Such extensions are known as "modifier extensions". For further information, see <a href="conformance-rules.html#modifier">the definition of what makes an element - or 
an extension - a modifier</a>.
If modifier extensions are present, an application cannot safely process the resource unless it knows
what the extension means for its own use of the data.
</p>
<p>
Implementers SHOULD avoid the use of modifier extensions where possible.  Any use should be carefully considered against its possible downstream consequences. Inclusion of modifier 
extensions in an instance would be expected to significantly limit the ability of other systems to process the instance. However, implementers
are often forced into these situations by the business arrangements around
the use of resources, so this specification creates a framework for handling such cases.
Implementers who are introducing an extension and are uncertain whether the extension should be marked as a modifier are encouraged to raise the question on <a href="http://chat.fhir.org">chat.fhir.org</a>.
</p>
<p>
Стандарт FHIR разрешает выносить расширения-модификаторы (Modifier Extensions) в базовую структуру ресурса или в структуру любого другого элемента, которому не соответствует какой-либо тип данных (например элементы, которые соответсвуют классам в UML-диаграммах ресурсов).
This specification allows for such modifier elements to be included at the base of a resource or in any elements
that do not have a data type (e.g. the elements that correspond to classes in the resource UML
diagrams), and on a <a href="datatypes.html#modifiers">few specially selected data types</a>. 
Other data types and elements inside data types SHALL NOT have modifier extensions, 
and extensions SHALL NOT have modifier extensions internally (except for the reusable structures
allowed to appear in extensions, listed above).
</p>
<p>
Отметьте, что сложные расширения могут иметь элементы, помеченные как модификаторы (<a href="conformance-rules.html#isModifier">Is-Modifier = true</a>), что означает, что эти элементы изменяют само значение расширения.
Note that complex extensions are allowed to have elements in the complex extension that are marked 
<a href="conformance-rules.html#isModifier">Is-Modifier = true</a>, which means that these elements modify the extension value itself.
Internal extensions like this marked "Is-Modifier" are still represented using the <code>extension</code> element , not <code>modifierExtension</code>
because the impact of the modifier element is expected to be known by applications that understand the containing extension.
</p>
<p>
Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
Any modifierExtension defined outside an extension cannot be placed in another extension.
</p>

<p>
В XML эти элементы-модификаторы представлены с помощью элемента <code>modifierExtension</code>, который имеет такое же содержимое, как и элемент <code>extension</code>, описанный выше:
In XML, these modifier elements are represented using an element named <code>modifierExtension</code>, which has same content as the
<code>extension</code> element documented above:
</p>
<div class="example">
<p>
Пример: у ресурса <a href="medicationrequest.html">MedicationRequest</a> нет элемента, чтобы сделать "антипредписание" - инструкцию не принимать медикамент некоторый период времени. Классические системы медицинских записей не записывают это как предписание, а какая-то одна система записывает, и эти "антипредписания" необходимо совместно использовать в учреждении, где это происходит, так как они являются важной частью рабочего процесса. Поэтому приложениям разрешается расширять ресурс такими данными, как:
  Example: There's no element on <a href="medicationrequest.html">MedicationRequest</a>
to write an "anti-prescription" - an instruction not to take a medication for a particular period.
Classical clinical recording systems do not record this as a prescription - but one particular
system does, and these "anti-prescription" records need to be shared within the institution
where this happens as they are an important part of the workflow.  Hence, applications are allowed to extend a resource with data like this:
</p>
<pre class="xml">
&lt;MedicationRequest&gt;
  &lt;modifierExtension url=&quot;http://example.org/fhir/StructureDefinition/anti-prescription&quot;&gt;
    &lt;valueBoolean value="true"/&gt;
  &lt;/modifierExtension&gt;
  &lt;!-- ... other content ... --&gt;
&lt;/MedicationRequest&gt;
</pre>
<p>
Или в JSON:
</p>
<pre class="json">
{
  "resourceType" : "MedicationRequest",
  "modifierExtension" : [{
    "url" : "http://example.org/fhir/StructureDefinition/anti-prescription",
    "valueBoolean" : true
  }],
  .. other content ...
}
</pre>
</div>

<p>
Реализации стандарта, обеспечивающие обработку данных в ресурсах, ДОЛЖНЫ проверять наличие модификаторов везде, где они могли бы появиться, и если расширение-модификатор присутствует в элементе данных, которое обрабатывает приложение, ДОЛЖНЫ выполнить одно из следующих действий:
Implementations processing the data in resources SHALL
check for modifiers anywhere they could appear, and if
a modifier extension is present on a data element that the application 'processes', SHALL do one of these
things:
</p>
<ol>
 <li>recognize the modifier extension, and understand the impact of the extension when using the data</li>
 <li>reject instances that contain the modifier extension</li>
 <li>treat such instances as "for rendering purposes only" - i.e. check that the narrative status = <code>extensions</code> or <code>generated</code>, display the narrative and don't process the discrete data</li>
 <li>Ask for a human to check the modifier extension before proceeding to process the data</li>
 <li>выдать предупреждение относительно данных и любых действий или выходных данных, которые возникают в результате их обработки, чтобы проинформировать пользователей о неполном понимании информации источника
carry a warning concerning the data along with any action or output that results from processing the data to inform users that it has not fully understood the source information</li>
</ol>


<p>
Обработка данных ресурса обычно представляет собой копирование или фильтрацию данных ресурса для последующего их использования в ином контексте (для представления пользователю, 
в целях поддержки принятия решения, для частичного обмена данных в ином формате или их сохранения для этого вида использования). Серверы и фоновые 
процессы, которые обеспечивают простое перемещение данных без каких-либо изменений, не выполняют "обработку данных ресурса", а значит этим приложениям не требуется выполнять проверку наличия неизвестных расширений-модификаторов. 
Processing the data of a resource typically means
copying or filtering data out of a resource for use in another
context (display to a human, decision support, exchange in another
format where not all information is included, or storing it for this kind of use).
Servers and background processes that simply move whole resources around unchanged
are not "processing the data of the resource", and therefore these applications
are not required to check for unknown modifier extensions.
</p>
<p>
<b>#1</b>: Если приложение понимает семантику расширения, это является результатом того, что разработчик подготовил соответствующие
инструкции по интерпретации содержимого с учетом существования расширения-модификатора.
<b>#1</b>: When an application understands this extension, it means that some developer
has provided appropriate instructions for what to do with the data contained
in it because of the existence of the modifier extension.
</p>
<b>#2</b>: Это значит, что от конкретных реализаций, по сути, не требуется "поддерживать" расширение-модификатор любым существенным способом - они могут достигнуть этого понимания отклонением экземпляров, которые содержат это расширение (a server, for instance, could return a HTTP 422 status code with
an <a href="operationoutcome.html">OperationOutcome</a> if a client
PUTs or POSTs a modifier extension it does not know. Приложения могут также игнорировать расширение-модификатор, если знают, что это безопасно делать в своем собственном контексте, хотя это не будет, как правило, иметь место.
<p><b>#2</b>:
This means that implementations are not inherently required to "support"
a modifier extension in any meaningful way - they can achieve this
understanding by rejecting instances that contain this extension
(a server, for instance, could return a HTTP 422 status code with
an <a href="operationoutcome.html">OperationOutcome</a> if a client
PUTs or POSTs a modifier extension it does not know).
Applications might also be able to ignore a modifier extension if they know 
that it is safe to do so in their own context, though this would not usually be the case.
</p>
<p>
Реализации должны удостоверяться, что они не обрабатывают данные, содержащие нераспознанные расширения-модификаторы.
Обратите внимание, что конкретные реализации могут иметь возможность быть уверенными благодаря их среде реализации (например особое соглашение торговых партнеров), что расширения-модификаторы никогда не будут использоваться, и, следовательно, выполнить требование проверки наличия модификаторов уже на стадии проектирования. Тем не менее, так как условия интеграции и внедрения часто изменяются, приложениям всё равно СЛЕДУЕТ всегда проверять наличие расширений-модификаторов при обработке ресурсов.
Implementations SHALL ensure that they do not process data containing unrecognized modifier 
extensions. Note that implementations might be able to be sure, due to their
implementation environment (e.g. specific trading partner agreement),
that modifier extensions will never occur, and can therefore meet
the requirement to check for modifiers at the design stage.
However, since integration and deployment options often change, 
applications SHOULD always check for modifier extensions when
processing resources.
</p>

<p><b>#3</b>: 
Один из способов предупредить пользователя - это загрузить определение расширения по имеющемуся URL и затем использовать заданный элемент display name для представления расширения пользователю. Сообщение об ошибке может выглядеть так:
<b>#3</b>:
One way to warn the user is to download the extension definition
from the given URL, and then use the defined display name to present
the extension to the user. An error message could look something like
this:
</p>
<img src="modifier-extension-warning.png"/>
<p>
Обратите внимание: описательная (человекочитаемая) часть ресурса (narrative) ДОЛЖНА содержать эту модифицирующую информацию, чтобы её можно было безопасно показать пользователю в качестве выражения содержимого ресурса.  Диалоговое окно с предупреждением можно расширить и предложить пользователю просмотреть оригинальный текст описательной части ресурса.
Note that the narrative of the resource SHALL contain modifying
information, so it is safe to show this to the user as an expression
of the resource's content. A warning dialog box could be extended to
offer the user the choice to see the original narrative.
</p>
<div class="example">
<p>
Вот пример предписания, приведенного выше, с описательной частью:
</p>
<pre class="xml">
&lt;MedicationRequest xmlns=&quot;http://hl7.org/fhir&quot;&gt;
  &lt;text&gt;
    &lt;status value=&quot;generated&quot;/&gt;
    &lt;div xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
      &lt;p&gt;&lt;b&gt;Note: This prescription is an instruction NOT to take a medication&lt;/b&gt;&lt;/p&gt;
      &lt;!-- snip actual narrative --&gt;
    &lt;/div&gt;
  &lt;/text&gt;
  &lt;!-- ...data... --&gt;
  &lt;modifierExtension url=&quot;http://example.org/fhir/StructureDefinition/anti-prescription&quot;&gt;
    &lt;valueBoolean value="true"/&gt;
  &lt;/modifierExtension&gt;
  &lt;!-- ...data... --&gt;
&lt;/MedicationRequest&gt;
</pre>
</div>
<p>
Приложению необходимо беспокоиться о расширениях-модификаторах только тех элементов, которые она обрабатывает. Возьмем, к примеру, случай, где в ресурсе procedure на одном из элементов <code>performer</code> есть modifierExtension, обозначающее, что они не участвовали в этой процедуре. Если приложение не обрабатывает элемент performer вообще, то тот факт, что один из элементов performer содержит modifierExtension, будет несущественным, и приложение может свободно игнорировать его. Если оно всё же обрабатывает элементы performer и встречает модифицирующее расширение, оно должно действовать одним из перечисленных выше способов.
An application only needs to concern itself with modifier extensions on elements that
it processes. Take, for example, a case where a procedure resource
has a modifier extension on one of the <code>performer</code> elements indicating that they did
not participate in the procedure. If an application is not using the performer details at all,
the fact that one of the performers has a modifier extension is irrelevant and the
application is free to ignore it. If the application does process the performers, and it sees the
modifier extension, it must act in one of the ways outlined above.
</p>

<p>
<a href="implementationguide.html">Implementation Guides</a> might place limitations on the appearance 
of modifier extensions within instances that comply with the implementation guide. 
</p>
 

<a name="Summary"></a>
<h3>Правила обеспечения соответствия для Modifier Extensions</h3>
<ul>
 <li>Расширение-модификатор ДОЛЖЕН влиять только на тот элемент и/или потомки этого элемента, который их содержит
A Modifier Extension SHALL only modify the element which contains it and/or that element's children</li>
 <li>Всегда ДОЛЖНО быть безопасно показать описательную часть людям; все расширения-модификаторы дОЛЖНЫ быть представлены в этой описательной части
It SHALL always be safe to show the narrative to humans; any modifier extension SHALL be represented in the narrative</li>
 <li>Приложения всегда ДОЛЖНЫ проверять, что нераспознанные расширения-модификаторы отсутствуют, при обработке данных из любого элемента, который может их содержать
Applications SHALL always ensure unrecognized modifier extensions are not present when processing the data from any element that might have carry modifier extensions</li>
 <li>Если присутствует расширение-модификатор, который приложение не понимает, приложение ДОЛЖНО либо отказаться обрабатывать такой ресурс или затронутый элемент, либо должно выдать соответствующее предупреждение своим пользователям
If a Modifier Extension that an application does not understand is present, the application SHALL refuse to process the resource or affected element, or SHALL provide an appropriate warning to its users</li>
</ul>

<a name="Special-Case"></a>
<h3>Особый случай: Отсутствие данных</h3>
<p>
В некоторых случаях разработчики могут обнаружить, что у них нет данных для элемента с минимальным кардинальным числом = 1. В таком случае элемент обязательно должен присутствовать, но пока ресурс или соответствующий ему интеграционный профиль не потребует наличия реального значения (соответствующего простым типам данных), такой элемент может иметь расширение, объясняющее, почему значение примитивного типа отсутствует.
In some cases, implementers might find that they do not have appropriate data for an
element with minimum cardinality = 1. In this case, the element must be present, but
unless the resource or a profile on it has made the actual value of the primitive
data type mandatory, it is possible to provide an extension that explains why the
primitive value is not present:
</p>
<pre class="xml">
&lt;uri&gt;
  &lt;extension url=&quot;http://hl7.org/fhir/StructureDefinition/data-absent-reason&quot;&gt;
    &lt;valueCode=&quot;unknown&quot;/&gt;
  &lt;/extension&gt;
&lt;/uri&gt;
</pre>
<p>
В данном примере вместо значения (value) указывается <a href="general-extensions.html">код отсутствия данных (data missing code)</a>. 
Обратите внимание, что использование расширения такого типа необязательно. Данный элемент-расширение <b>нельзя</b> считать модификатором
(modifier extension), т. к. ему не присваиваются значения, соответствующие примитивным типам данных.
In this example, instead of a value, a <a href="general-extensions.html">data missing code</a> is provided. Note that
it is not required that this particular extension be used. This extension
is <b>not</b> a modifier extension, because the primitive data type has no
value.
</p>
<p>
Неправильно создавать формальное наполнение элемента (fictional piece of data) с содержимым, соответствующим примитивным типам данных, а затем включать в элемент расширение, определяющее добавление данных в целях обеспечения соответствия. Точно также плохой идеей будет и использование расширения-модификатора, которое запрещено на простых типах данных.
It is not valid to create a fictional piece of data for the primitive value,
and then add an extension indicating that the data has been constructed
to meet the data rules. This would be both a bad idea as well as a modifier
extension, which is not allowed on simple data types.
</p>

<a name="exchange"></a>
<h2>Обмен расширениями</h2>

<p><i>Note: This section describes the use of "non-modifier extensions", except where "modifier extensions" are explicitly mentioned (see <a href="#isModifier">Modifier Extensions</a> above for details).</i></p>

<p>
Элементы-расширения позволяют отражать локальные потребности здравоохранения с помощью подхода, основанного на универсальной [модели] информации. Это необходимо, чтобы медицинские системы могли работать с ресурсами с помощью одинаковых средств и инструментов. Однако, когда речь идет об обработке информации (содержищейся в ресурсах и уточненной расширениями), приложения будут ограничены в обработке расширений в той степени, в которой они располагают данными о них.
Extensions are a way of allowing local requirements to be reflected in a resource using
a common information based approach so that all systems can confidently process them
using the same tools. However, when it comes to processing the information, applications
will be constrained in their ability to handle extensions by the degree to which they
are informed about them.
</p>
<p>
Несмотря на то, что каждое выражение (expression) должно сопровождаться описанием его структуры (structure definition) (см. далее подробности), само по себе наличие описания не означает, что приложение понимает, как правильно обрабатывать расширение. В целом, всегда требуется решение человека, чтобы определить, каким образом будут использоваться данные в элементах-расширениях, и какие обязательства в отношении данной информации должны выполняться.
While the structured definition of an extension should always be available (see below for
details), the mere availability of a definition does not automatically mean that applications
know how to handle them correctly - generally, human decisions are required to determine 
how the data in extensions should be handled, along with the implicit obligations
that surround the information.
</p>
<p>
По этой причине локальные потребности, которые находят отражение в форме расширений, препятствуют интеграции и совместимости.
Чем больше требований являются универсальными (например на региональном или общегосударственном уровне), тем меньшее
влияние они оказывают на процессы интеграции. Согласованное представление, определение и регистрация расширений, 
описанных в данной спецификации, не поможет решить существующую проблему. Необходима методология, которая упростит работу с локальными вариантами ресурсов.
For this reason, local requirements that manifest as extensions are an obstacle to
integration and interoperability. The more the requirements are shared (i.e. regional or national scale),
the less of an obstacle they will represent. The consistent representation, definition and registration of
extensions that this specification defines cannot resolve that problem - it only provides a framework
within which such local variations can be handled more easily.
</p>
<p>
Внедрение медицинских приложений, обеспечивающих поддержку локальных потребностей, часто сопровождается ситуацией,
при которой обменивающиеся информацией приложения поддерживают разные наборы расширений. Спецификация FHIR
устанавливает ряд простых правил, направленных на управления такими ситуациями, однако не способна предложить решения
для такого рода несоответствий.
When it comes to deploying applications that support local requirements, situations
will very likely arise where different applications
exchanging information with each other are supporting different sets of extensions.
This specification defines some basic rules that are intended to make management
of these situations easier, but it cannot resolve them.
</p>
<ul>
 <li>При обмене ресурсами системы МОГУТ, по возможности, сохранять неизвестные расширения (так же как и базовые элементы ресурса)
When exchanging resources, systems SHOULD retain unknown extensions when they are capable of doing so (just as they SHOULD retain core elements when they are capable of doing so)</li>
 <li>Если система изменяет ресурс, она МОЖЕТ удалить любые расширения, семантика которых для нее непонятна. Необходимо
 удалять элемент-модификатор и все его элементы-потомки, потому что изменения, вносимые в ресурс, могут сделать
 элемент-расширение некорректным
If a system modifies a resource it SHOULD remove any extensions that it does not understand from the
modified element and its descendants, because it cannot know whether the modifications it has made
might invalidate the value of the unknown extension</li>
 <li>Системы, удаляющие (drop) существующие элементы, занимаются "обрабаткой ресурса" ("processing the resource")
Systems that drop existing elements are considered to be "processing the resource"</li>
 <li>Система НЕ ДОЛЖНА изменять ресурсы или элементы, которые содержат элементы-модификаторы с неясной семантикой
A system SHALL NOT modify a resource or element that contains "modifier" extensions it doesn't understand</li>
 <li>Приложения ДОЛЖНЫ игнорировать нераспознанные расширения, если только это не расширения-модификаторы.
Applications SHOULD ignore extensions that they do not recognize if they are not "modifier" extensions</li>
</ul>
<p>
То, в какой степени приложения должны сохранять неизвестные элементы-расширения зависит от функциий, которые они 
выполняют: FHIR-сервер общего назначения или промежуточная платформа (middleware engine) сохраняют все расширения, в то 
время, как приложения, используемые для управления данными пациентов (последством пользовательского интерфейса) 
при регистрации, сохраняют только те, из неизвестных расширений, которые входят в набор информации, 
непосредственно обрабатываемой пользователем.
The degree to which a system can retain unknown extensions is a function of the type of system
it is: a general purpose FHIR server, or a middleware engine would be expected to retain
all extensions, while an application that manages patient registration through a user
interface can only retain extensions to the degree that the information in them is part of the
set managed by the user. Other applications will fall somewhere between these two extremes.
</p>

<a name="Summary2"></a>
<h3>Summary: Handling extensions</h3>
<p>
Используйте следующие правила в качестве руководства для обработки ресурсов:
Use the following rules as a guideline for handling resources:
</p>
<ul>
 <li>При написании расширений убедитесь, что они имеют [формализованное] описание и находятся в открытом доступе
When writing extensions, make sure they are defined and published</li>
 <li>При чтении, навигации или поиску по элементам, которые могут иметь расширения-модификаторы, проверяйте их на наличие расширений-модификаторов
When reading, navigating through or searching on elements that can have modifier extensions, check whether there are any modifier extensions present</li>
 <li>При чтении элементов читайте и обрабатывайте расширения, которые вам известны, и игнорируйте другие расширения <b>кромер расширений-модификаторов</b>
When reading elements, read and process the extensions you know and use, and ignore other extensions <b>except for modifier extensions</b></li>
 <li>Фиксируйте расширения, где это возможно
Retain extensions whenever you can</li>
</ul>

</div>

[%file newfooter%]


  <script src="external/jquery/jquery.js"> </script>
<script src="jquery-ui.min.js"> </script>
<script>
 try {
   var currentTabIndex = sessionStorage.getItem('fhir-resource-tab-index');
 } catch(exception){
 }
 if (!currentTabIndex)
   currentTabIndex = '0';

$( '#tabs-Extension' ).tabs({ active: currentTabIndex, activate: function( event, ui ) { store(ui.newTab.index()); } });


function store(currentTab) {
  document.activeElement.blur();
  try {
    sessionStorage.setItem('fhir-resource-tab-index', currentTab);
  } catch(exception){
  }
  $( '#tabs-Extension' ).tabs('option', 'active', currentTab);
}
</script>

</body>
</html>
