<!DOCTYPE HTML>


[%settitle Обмен сообщениями с помощью FHIR-ресурсов%]
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
[%file newheader%]
</head>
<body>
[%file newnavbar%]

<div class="col-12">

<h1>Обмен сообщениями с помощью FHIR-ресурсов</h1>
<table class="cols"><tr><td id="wg"><a _target="blank" href="[%wg fhir%]">[%wgt fhir%]</a> Рабочая группа</td><td id="fmm"><a href="versions.html#maturity">Уровень зрелости</a>: 3</td><td id="ballot"><a href="versions.html#levels">Статус голосования</a>: <a href="versions.html#std-process">Пробное использование</a></td></tr></table>

<p>
FHIR-ресурсы могут использоваться в контексте традиционного обмена сообщениями подобно <a href="http://www.hl7.org/implement/standards/product_brief.cfm?product_id=185">HL7 v2</a> (см. <a href="comparison-v2.html">детальное сравнение</a>).. Приложения, декларирующие соответствие этому фреймворку, заявляют о совместимости с "обменом сообщениями в FHIR" (см. <a href="conformance-rules.html">Conformance</a>).
</p>

<p>
В FHIR-обмене сообщениями "сообщение-запрос (request message)" отправляется из приложения-источника в приложение-получатель, когда происходит некоторое событие. События в основном соответствуют явлениям реального мира. Сообщение-запрос состоит из <a href="bundle.html">Bundle</a> с указанным <a href="bundle-definitions.html#Bundle.type">типом</a> "message", первым в комплекте идет ресурс <a href="messageheader.html">MessageHeader</a>. Ресурс MessageHeader содержит код - событие сообщения - который определяет природу происхождения сообщения-запроса, а также несет в себе дополнительные метаданные запроса. Остальные ресурсы в комплекте зависят от типа этого запроса.
</p>
<p>
События, поддержанные спецификацией FHIR наряду с ресурсами, которые в них входят, описаны ниже.
</p>
<p>
Приложение-получатель обрабатывает запрос и возвращает один или несколько ответных сообщений, также являющихся <a href="bundle.html">комплектом</a> ресурсов с указанным <a href="bundle-definitions.html#Bundle.type">типом</a> "message", первым в комплекте идет ресурс <a href="messageheader.html">MessageHeader</a> с разделом для ответа, в котором передаются результаты обработки сообщения и все требуемые дополнительные ответные ресурсы.
</p>
<ul>
 <li>Example Request Message: <A href="message-request-link.xml.html" /> </li>
 <li>Example Response Message: <A href="message-response-link.xml.html" /> </li>
</ul>

<a name="basic"> </a>

<h2>Основные допущения при передаче сообщений (Basic Messaging Assumptions)</h2>

<p>
Данная спецификация предполагает, что содержимое будет доставлено из одного приложения в другое некоторым механизмом доставки, а затем один или несколько ответов будут возвращены приложению-источнику. Описание самого механизма передачи неуместно в данной спецификации, но может включать передачу файлов, передачу на основе HTTP, MLLP (HL7-протокол минимального нижнего уровня), серию сообщений MQ или любые другие. Единственное требование к уровню передачи состоит в том, чтобы запросы отправлялись в указанное место, а ответы возвращались к источнику запроса. Данная спецификация рассматривает приложение-источник и приложение-приемник в качестве логических сущностей, а нахождение соответствия между логическими источником и приемником и специфичными для реализаций адресами лежит вне этой спецификации, хотя спецификация и предоставляет прямой механизм доставки ниже.
</p>
<p>
Соглашения о содержимом сообщений и поведении двух приложений образуют "контракт", который описывает этот обмен. Такой контракт будет добавлять региональные и локальные соглашения к правилам, установленным в этой спецификации.
</p>
<p>
Данная спецификация игнорирует существование интерфейсных механизмов и агентов передачи сообщений, которые существуют между <i>источником</i> и <i>назначением</i>. 
Либо они прозрачны для содержимого сообщения/транзакции и независимы от данной спецификации, либо они активно вовлечены в оперирование содержимым сообщений (в частности, заголовки источника и назначения часто меняются). Если эти промежуточные агенты модифицируют содержимое сообщения, тогда они становятся ответственными за исполнение контракта, который применяется (включая подходящие профили) в обоих направлениях.
</p>
<p>
Ключевой аспект сообщения составляет влияние его содержания:
</p>
[%codelist http://hl7.org/fhir/message-significance-category%]
<p>
Некоторые события, определенные FHIR, отнесены к одной из описанных категорий, но остальные не возможно категоризировать заранее, поэтому категория должна определяться содержимым или контекстом.
</p>

<a name="synchronous"> </a>
<a name="patterns"> </a>
<h3>Схемы обмена сообщениями</h3>
<p>
Каждое сообщение с FHIR-запросом имеет одно или несколько ответных сообщений. Должно быть по крайней мере одно ответное сообщение, чтобы отправитель мог узнать, что сообщение было должным образом получено. Сообщения с несколькими ответами НЕ ДОЛЖНЫ возвращаться для сообщений типа consequence, а также его НЕ СЛЕДУЕТ возвращать для уведомлений.
</p>
<p>
В принципе, приложениям-источникам не требуется дожидаться ответа на транзакцию для запуска новой транзакции. Однако во многих случаях сообщения в данном потоке зависят друг от друга и должны отправляться и обрабатываться по порядку.  К тому же некоторые методы передачи могут требовать последовательной доставки сообщений.
</p>
<p>
По этой причине схема синхронного обмена - где отправитель отсылает сообщение и ждет на этом же канале одиночного ответа, а затем высылает новое сообщение - самая простая для понимания и управления. Таким образом работает <a href="#process">$process-message</a> <a href="operations.html">операция</a>, описанная ниже.
</p>
<p>
Однако синхронный обмен сообщениями не обслуживает множественные ответные сообщения, которые может возникнуть при обработке запросов, а также налагает ограничения пропускной способности, которые при высоких объемах могут стать значительными. К тому же ожидание ответных сообщений может быть непрактично или неуместно. В таких случаях следует использовать асинхронную схему обмена сообщениями, <a href="#async">описанную ниже</a>.
</p>


<h3>MessageHeader Identifiers</h3>
<p>
Входящее сообщение имеет два идентификатора: Bundle.id и <a href="messageheader.html">MessageHeader</a>.id. 
Каждый раз при создании нового сообщения ему ДОЛЖЕН быть присвоен идентификатор (MessageHeader.id), являющийся уникальным в потоке этого сообщения. Обратите внимание, что так как потоки сообщений часто объединяются с другими потоками, рекомендуется, чтобы этот идентификатор был глобально уникальным. Этого можно достигнуть использованием  UUID или OID. Каждый раз, как сообщение отправляется, значение Bundle.id следует менять на новое.
</p>
<p>
 Когда получатель получает и обрабатывает сообщение, он отвечает новым сообщением с новым идентификатором, обернутым в комплект, который также имеет новый идентификатор. Ответное сообщение также цитирует MessageHeader.id в 
MessageHeader.response.identifier запроса, для того чтобы система-источник могла установить связь между ответом и его запросом.
</p>

<a name="reliable"> </a>
<h3>Отсутствие безотказного обмена сообщениями</h3>
<p>
Некоторые из упомянутых выше механизмов доставки сообщений являются безотказными системами доставки - сообщение всегда доставляется, либо источнику возвращается соответствующая ошибка. Однако большинство реализаций используют методы, которые не обеспечивают безотказного обмена сообщениями, и либо запрос, либо ответ могут потеряться при передаче. Обмен сообщениями в FHIR описывает простой подход,  которому СЛЕДУЕТ соответствовать получателям, чтобы справляться с отсутствием безотказного обмена сообщениями, поддерживающего предсказуемую функциональность.
</p>
<p>
Если отправитель сообщения применяет безотказный обмен сообщениями, он ДОЛЖЕН сделать следующее, если не получил ответа на сообщение в течение заданного времени ожидания на основе значения, указанного в 
<a href="capabilitystatement.html">CapabilityStatement</a> <code>messaging.event.category</code>
для события, ассоциированного с этим сообщением:
</p>
<table class="grid">
 <tr><td>Consequence</td><td>Отправить это же сообщение повторно (с тем же MessageHeader.id) с тем же Bundle.id</td></tr>
 <tr><td>Currency</td><td>Отправить это же сообщение повторно (с тем же MessageHeader.id) с другим Bundle.id</td></tr>
 <tr><td>Notification</td><td>Отправить это же сообщение повторно (с тем же MessageHeader.id) с другим Bundle.id</td></tr>
</table>
<p>
Когда получатель использует безотказный обмен сообщениями, он ДОЛЖЕН проверять входящие Bundle.id и MessageHeader.id на наличие среди кешированных предыдущих полученных сообщений. Корректное действие, которое ему следует предпринять, зависит от результатов этой проверки:
</p>
<table class="grid">
 <tr><td>Такие Bundle.id и MessageHeader.id ещё не были получены</td><td>Это нормальный случай, и сообщение следует обработать</td></tr>
 <tr><td>Такие обертка (envelope) и сообщение уже были получены</td><td>Первоначальный ответ был потерян (не удалось вернуть отправителю запроса), и первоначальный ответ ДОЛЖЕН быть выслан повторно</td></tr>
 <tr><td>Такой MessageHeader.id уже был получен, а Bundle.id новый</td><td>Предыдущее полученное сообщение было отправлено на обработку еще раз. Сервер может либо повторно обработать, либо отклонить это сообщение</td></tr>
 <tr><td>Такой Bundle.id уже был получен, а MessageHeader.id новый</td><td>Это ошибка - значения Bundle.id никогда не должны использоваться повторно</td></tr>
</table>
<p>
Очень длинная продолжительность периода кеширования обычно не требуется. он может быть как минимум на 1 минуту больше тайм-аута системы отправки, хотя, возможно, потребуется его увеличить в зависимости от политики повторной отправки системы-отправителя.
</p>
<p>
Приложения, реализующие безотказный обмен сообщениями, объявляют свой достоверный период кеширования в своих <a href="capabilitystatement.html">Capability Statement</a>.
</p>

<h4>Пример: Consequence</h4>
<p>
В этом первом примере Clinical EHR выпускает ордер на совершение пациенту определенного томографического обследования. Полагается, что это будет сообщение типа Следствие (Consequence): не следует создавать многочисленные ордера (на практике имеются обычно процессы обзора человеком, которые охватывают несколько ордеров, но повторяющиеся ордера создают энтропию в системе, что является опасным). EHR отправляет сообщение, где Bundle.id - это UUID 1 (72edc4e0-6708-42ab-9734-f56721882c10) и
MessageHeader.id - это UUID 2 (dad53a57-dcb4-4f18-b066-7239eb4b5229).
</p>
<p>
EHR-система так и не получает ответа на это сообщение; она не знает, либо запрос потерялся, либо система управления изображениями не смогла обработать запрос, либо она успешно обработала сообщение, а ответ потерялся. В этом случает EHR-система отправляет сообщение повторно с этими же двумя идентификаторами.
</p>
<p>
В этом случае система управления изображениями успешно получает сообщение и обрабатывает его. Так как она получает повторный ордер через 1 минуту (что в пределах её 15-минутного времени кеширования), и оба UUID 1 и 2 совпадают с сообщением, которое она уже обработала, она знает, что уже обработала этот ордер и просто возвращает предыдущий ответ. В случае дополнительно высланных повторных запросов приложение продолжает отправлять первоначальный ответ, хотя может также сообщить системным администраторам о том, что одно и тоже первоначальное сообщение продолжает пересылаться, так как потерянные сообщения должны быть редким явлением.
</p>
<p>
Когда EHR-система наконец получает сообщение, она понимает, как ответила система управления изображениями; она может быть уверена в этом, потому что идентификатор сообщения из первоначального запроса отражается в ответной части возвращенного сообщения.
</p>


<h4>Пример: Currency</h4>
<p>
В этом втором примере Clinical EHR необходимо узнать, какие интервалы приема доступны для определенной процедуры исследования. Это сообщение типа <b>Currency</b>: доступные слоты в любой момент могут исчезнуть, и заказ слота, который только что стал недоступным, является пустой тратой времени для вовлеченных людей и систем. EHR высылает сообщение с Bundle.id - UUID 3 (4c7f5cb2-5964-4d42-b719-e0227461818c), с MessageHeader.id - UUID 4 (63ed7d68-b2cc-421d-ba1c-a6c7785581f2).
</p>
<p>
EHR-система так и не получает ответа на это сообщение; она не знает, либо запрос потерялся, либо система управления изображениями не смогла обработать запрос, либо она успешно обработала сообщение, а ответ потерялся. В этом случает EHR-система отправляет повторно сообщение с тем же MessageHeader.id (UUID 4), но создает новый Bundle.id: (c7c17fe4-9560-49c7-b2ae-42636476fb86).
</p>
<p>
В этом случае система управления изображениями (imaging system) успешно получает сообщение и обрабатывает его. Когда она получает повторный ордер через 1 минуту (что  в пределах её 15-минутного времени кеширования), она видит, что, хотя идентификатор сообщения тот же самый, Bundle.id изменился, обрабатывает сообщение снова и отправляет новый ответ.
</p>
<p>
Когда EHR-система наконец получает сообщение, она узнает о текущей доступности слотов в ответившей системе управления изображениями ( imaging management system).
</p>
<p>
Обратите внимание, что существование активных посредников (или промежуточного программного обеспечения) создает необходимость в таком протоколе - исходный отправитель подбирает ответ на запрос на основе MessageHeader.id, поэтому активный посредник, который решит повторно инициировать запрос, который он ранее ретранслировал, не может менять MessageHeader.id. В этом протоколе избегается необходимость изменения MessageHeader.id, и требуется менять только Bundle.id, что никогда не является основой для контекстного связывания вне непосредственного протокола обмена сообщениями, описанного здесь.
</p>

<a name="conf"> </a>

<h2>Capability Statement</h2>
<p>
Приложения могут утверждать о соответствии "FHIR-обмену сообщениями", только если они публикуют <a href="capabilitystatement.html">Capability statement</a>, чтобы это утверждение можно было подтвердить. Заявление о возможностях перечисляет все поддерживаемые события обмена сообщениями (либо как отправитель, либо получатель) и для каждого события профиль, который указывает, какие ресурсы будут собраны в комплект (отправитель), либо должны войти в комплект (получатель), и все правила об информационном содержимом каждого ресурса.
</p>

<a name="process"> </a>
<h2>$process-message</h2>
<p>
Простейшим способом обработки сообщений там, где есть <a href="http.html">RESTful-взаимодействия</a>, будет использование <a href="messageheader-operations.html">$process-message</a>. 
Эта операция принимает сообщение, обрабатывает его в соответствии с определением события в заголовке сообщения и возвращает один или несколько ответных сообщений.
Например, в дополнение к обработке события сообщения сервер может сохранить все или некоторые из ресурсов и сделать их доступными через RESTful интерфейс, однако это не является обязательным.
<!--
The simplest way to handle messages where there are also <a href="http.html">RESTful interactions</a>
occurring is to use the <a href="messageheader-operations.html">$process-message</a>. 
This operation accepts a message, processes it according to the definition of the event in the message header, and returns a one or more response messages. 
For example, in addition to processing the message event, a server
may choose to retain all or some the resources and make them available on a RESTful interface, but
is not required to do so.
-->
</p>
<p>
При обработке сообщений сервер может вернуть один из нескольких статус-кодов:
</p>
<ul>
  <li><b>200 OK</b>: Indicates that the message has been fully processed.  If an application-level response is expected for the
    submitted message, that response SHALL be returned as the body of the 200 response.</li>
  <li><b>202 Accepted</b>: Indicates that the receiving system has accepted custody of the message</li>
  <li><b>204 No Content</b>: Indicates that the message has been fully processed and would normally have had an application-level response,
    but because of instructions from the sender (e.g. the
    <a href="extension-messageheader-response-request.html">messageheader-response-request</a> extension), no response is being provided</li>
  <li><b>300+</b>: Indicates that the message was not successfully processed.  The server MAY return an
    <a href="operationoutcome.html">OperationOutcome</a> with additional information, and SHOULD
    do so if the response code is 400 or greater.<br/>
    The client SHALL interpret a 4xx response to indicate that there is no point resubmitting the unaltered
    message, and a 5xx response to indicate an unexpected error occurred on the part of the server, with
    the implication that it may be appropriate to resubmit the original message. Doing so SHOULD NOT result
    in a duplicate message response. Repeated failures indicate either a fatal problem with the submission
    or a problem with the receiving application.</li>
</ul>
<p>
The following rules apply when using $process-message:
</p>
<ul>
 <li>Операция принимает только POST-транзакции - любой другой HTTP-метод приведет к HTTP-ошибке</li>
 <li>Тип содержимого переданного запроса - это всегда <a href="bundle.html">комплект</a> с типом "message" , содержащий первым ресурсом <a href="messageheader.html">MessageHeader</a></li>
 <li>Тип содержимого возвращаемого ответа - это всегда <a href="bundle.html">Bundle</a> с типом "message", содержащий первым ресурсом <a href="messageheader.html">Message Header</a>, либо HTTP-ошибка</li>
 <li>Если ответом является ошибка, телом ДОЛЖЕН быть ресурс <a href="operationoutcome.html">Errors &amp; Warning</a> со всеми подробностями</li>
 <li>Почтовый ящик может быть аутентифицирован с помощью стандартных HTTP-методов аутентификации, включая OAuth</li>
</ul>
<p>
Операция $process-message может использоваться любой HTTP-точкой взаимодействия, которая принимает FHIR-сообщения, а не только FHIR RESTful-серверами.
</p>
<p>
Когда сообщения обрабатываются с помощью данной операции, для гарантии непротиворечивости обработки необходимо следовать <a href="#reliable">логическим правилам касательно обработки Bundle.id и идентификатора сообщения, описанным выше</a>.
</p>

<p>
The <a href="messageheader-operations.html">$process-message</a> operation may be used 
synchronously, or asynchronously.
</p>
<h3>Synchronous Operation</h3>
<p>
Synchronous messaging is the easiest to understand; the sender sends a message to the 
receiver (the server), the server processes it, and then returns a response. Usually
(though not always) the sender waits for the response to the current message before  
sending the next message. This kind of messaging exchange is the most common because
it's the simplest to understand.
</p>
<p>
The following rules apply when using the $process-message operation synchronously:
</p>
<ul>
 <li>The URL (http://server/base/$process-message) has no parameters</li>
 <li>It is an error if the sender POSTs a message that requires multiple response messages</li>
 <li>Servers SHALL accept multiple concurrent message submissions and process them correctly (they are allowed to process them sequentially internally, but multiple concurrent submissions is not an error in its own right)</li>
</ul>
<h3>Asynchronous Operation</h3>
<p>
In Asynchronous messaging, the server acknowledges receipt of the message immediately,
and responds to the sender separately. The server may respond more than once to any
given message. 
</p>
<p>
The following rules apply when using the $process-message operation synchronously:
</p>
<ul>
 <li>The URL has at least one parameter: http://server/base/$process-message?async=true</li>
 <li>The server acknowledges the message with a 200 OK with no body, or returns an HTTP error if the message cannot be processed. An <a href="operationoutcome.html">OperationOutcome</a> SHOULD be returned in such a case</li>
 <li>Accepting the message means that the server has understood the message enough to know where to respond</li>
 <li>By default, the server responds by invoking the $process-message using the sender's stated end-point in the message: POST [MessageHeader.source.endpoint]/$process-messages]</li>
 <li>Since the source end-point may be manipulated by message transfer engines, an alternative response address may be specified using the parameter "response-url": http://server/base/$process-message?async=true&amp;response-url=http://server2.com/base/anything. 
   The endpoint at the specified URL SHALL implement the signature of the $process-message operation (parameter async=true, accept a Bundle, return a 200 OK or an error)</li>
 <li>The server submits response messages to the appropriate end-point with the parameter async=true. There is no response message for the response messages</li>
</ul>
<p>
When a message is received, a receiver can determine from the content of the message header whether it's a new message to process, or a response to a message that has already been sent. 
Note that asynchronous messaging is less reliable than synchronous messaging; more can go wrong. 
This specification does not dictate any particular error handling protocols or responsibilities; these are left to trading partner agreements between implementers.
</p>

<a name="endpoints"> </a>
<h2>Связь между системой обмена сообщениями и REST</h2>

<p>
Помимо системы обмена сообщениями, описанной здесь, FHIR также определяет <a href="http.html">RESTful API</a>. Система обмена сообщениями и RESTful-система связаны тем, что оба разделяют один и тот же набор ресурсов, которым они оперируют.
По сути, базовый ресурс <a href="messageheader.html">MessageHeader</a>, на котором построена система обмена сообщениями, сам по себе является ресурсом, который может обрабатываться в RESTful-подходе.
<!--
As well as this messaging framework documented here, FHIR also defines a
<a href="http.html">RESTful API</a>. The messaging and RESTful frameworks
are related in that both share the same set of resources on which they operate.
In fact, the basic <a href="messageheader.html">MessageHeader</a> resource
that the messaging framework is implemented is itself a resource that can treated in a RESTful approach.
-->

</p>
<p>
Функциональные возможности, которые предлагают RESTful API и система обмена сообщениями, очень похожи; их основное различие носит архитектурный характер.
<!--
The kinds of functionality that the RESTful API and the messaging framework
offer are very similar; their primary difference is architectural in nature.
-->
</p>
<p>
К примеру, система обмена сообщениями определяет событие по оповещению о том, что ресурс administration был создан или обновлен; REST API предлагает подобные сервисы (<a href="http.html#history">history</a> and <a href="subscription.html">Subscription</a>).
С другой стороны, имеются и различия в предлагаемых возможностях: в то время как слияние записей пациента может быть реализовано в виде серии RESTful-операций, совершаемых клиентом, который обновляет все ресурсы, связанные с этим пациентом, а при обработке сообщения-команды на слияние записей пациента всю работу выполнит сервер, притом он сможет выполнить слияние в таких областях, которые не доступны RESTful API.
Однако REST API предоставляет набор базовых операций для всех ресурсов, которые не предоставлены в системе обмена сообщениями и потребовали бы особых определений.
<!--
For instance, the messaging framework defines an event for notifying that
a administration resource has been created or updated; the REST API offers
similar services (<a href="http.html#history">history</a> and <a href="subscription.html">Subscription</a>).
On the other hand, there are differences in the capabilities offered - while
a patient merge can be implemented as a series of RESTful operations performed
by the client that update all resources linked to the patient, when a message
command to merge patient records is processed, the server will do all
the work, and is also able to merge in areas not exposed on the RESTful API.
The REST API, however, provides a set of basic operations on all resources
that would need special definitions in the messaging framework - definitions that
are not provided.
-->
</p>
<p>
Не ожидается, что RESTful-системам потребуется поддерживать систему обмена сообщениями или наоборот, хотя системам может оказаться полезным поддерживать оба набора функциональностей, чтобы удовлетворять более широкому спектру реализаторов.
</p>
<p>
Как ресурс, который может использоваться в RESTful-системе, MessageHeader имеет обычную точку взаимодействия (/MessageHeader), которая используется для управления набором статических ресурсов сообщений. Её можно использовать для создания архива доступных прошлых сообщений. <b>Создание или обновление таким образом ресурсов MessageHeader не отражает фактического наступления никакого события и не может привести в действие никакую логику, связанную с реальным событием.</b> Это только для управления набором ресурсов заголовков сообщений.
</p>

<a name="rest"> </a>
<h3>Asynchronous Messaging using the RESTful API</h3>

<p>
It is possible to exchange messages using the RESTful 
end-point as a central point of exchange. This is not 
particularly efficient compared to other methods, but 
is useful for low-volume asynchronous exchange.
</p>
<p>
To send a message, a sender posts the message bundle to the 
/Bundle end-point, with a uri that identifies the receiver 
at <a href="messageheader-definitions.html#MessageHeader.destination.endpoint">MessageHeader.destination.endpoint</a>.
The RESTful server accepts the bundle,
stores it as a single bundle, and indexes it on the 
<a href="messageheader.html">MessageHeader</a>.
</p>
<p>
To receive messages, a receiver searches for all messages
destined for itself, since its last check:
</p>
<pre>
 GET [base]/Bundle?message.destination-uri=[rcv]&amp;_lastUpdated=>2015-03-01T02:00:02+01:00
</pre>
<p>
The receiver works through the response, processing each message.
As each message is processed, the receiver creates a response 
message, reversing the source and destination, and posts it back
to the server.
</p>
<p>
To check for responses, the original sender searches for 
response messages destined for itself, since its last check:
</p>
<pre>
 GET [base]/Bundle?message.destination-uri=[snd]&amp;message.response-id:missing=false
      &amp;_lastUpdated=>2015-03-03T06:03:522+01:00
</pre>
<p>
This lightweight protocol needs ongoing administration to 
ensure that multiple parties do not interfere with each other
by re-using the same system identifier (and against malicious 
attack).
</p>




<a name="Events"> </a>
<a name="events"> </a>
<h2>Перечень событий</h2>

<p>
Элемент <i>message.code</i> передает <a href="datatypes.html#Coding">Coding</a>, который идентифицирует событие, которое передает сообщение.
В данной таблице перечислены коды событий сообщений, определенные в этой спецификации (значением системы для них является "<a href="valueset-message-events.html">http://hl7.org/fhir/message-events</a>""):
</p>

[%events%]

<p>
Описание колонок "запрос" и "ответ": значением этих колонок является либо ресурс, который входит в состав ответа, либо элемент, который ссылается на другой ресурс, что означает, что цель таких ссылок ДОЛЖНА также присутствовать в этом сообщении. 
В этой таблице колонки "запрос" и "ответ" перечисляют центровой ресурс для события наряду с другими ресурсами, которые также должны передаваться в сообщении непосредственно (если они существуют).
</p>
<p>
Additional events may be defined using the <a href="messagedefinition.html">MessageDefinition</a> resource.
</p>

<a name="operations"> </a>
<h2>Invoking Operations via Messages</h2>

<p>
A message can be used to invoke an operation as defined for a RESTful interface using
an operation definition. To invoke an operation using a message:
</p>
<ul>
 <li>The requester sends a message (a bundle with type = message, and a message header resource)</li>
 <li>The message header has an event.system of <code>urn:ietf:rfc:3986</code></li>
 <li>The event.code is the URL from the operation definition <code>OperationDefinition.url</code></li>
 <li>The <code>MessageHeader.data</code> refers to a <a href="parameters.html">Parameters</a> resource</li>
 <li>The parameters resource is populated appropriately as specified by the nominated operation definition</li>
</ul>
<p>
The recipient executes the operation as specified, and then:
</p>
<ul>
 <li>The receiver sends a message (a bundle with type = message, and a message header resource)</li>
 <li>The message header has the same event as the original message</li>
 <li>The MessageHeader contains a response that refers to the original request message, and a code for the outcome, with details if the operation failed</li>
 <li>The <code>MessageHeader.data</code> refers to a <a href="parameters.html">Parameters</a> resource</li>
 <li>The parameters resource is populated appropriately as specified for the response by the nominated operation definition</li>
 <li>If the operation definition specifies a single return, then this is returned as the target of the MesssageHeader.data directly</li>
</ul>
<p>
Here's an example:
</p>
<pre class="xml">
&lt;Bundle xmlns=&quot;http://hl7.org/fhir&quot;&gt;
  &lt;id value=&quot;urn:uuid:77831928-2a35-4c08-9496-8232323bf48c&quot;/&gt;
  &lt;!-- normal bundle stuff --&gt;
  &lt;entry&gt;
    &lt;fullUrl value=&quot;urn:uuid:6080d4a7-5e05-45dc-96d5-f75329564d1f&quot;/&gt;
    &lt;resource&gt;
      &lt;MessageHeader&gt;
			  &lt;id value="cac8143e-6138-4f45-b086-bb8ebf976aae"&gt;
        &lt;!-- normal message header stuff --&gt;
        &lt;event&gt;
          &lt;system value=&quot;urn:ietf:rfc:3986&quot;/&gt;
          &lt;!-- value set expansion --&gt;
          &lt;code value=&quot;http://hl7.org/fhir/OperationDefinition/ValueSet-expand&quot;/&gt; 
        &lt;/event&gt;
        &lt;!-- more normal message header stuff --&gt;
        &lt;data&gt;
          &lt;reference value=&quot;urn:uuid:00213637-dc7c-40d2-a7de-f4ef1eea5685&quot;/&gt;
        &lt;/data&gt;
      &lt;/MessageHeader&gt;
    &lt;/resource&gt;
  &lt;/entry&gt;
  &lt;entry&gt;
    &lt;fullUrl value=&quot;urn:uuid:00213637-dc7c-40d2-a7de-f4ef1eea5685&quot;/&gt;
    &lt;resource&gt;
      &lt;Parameters&gt;
        &lt;parameter&gt;
          &lt;name value=&quot;identifier&quot;/&gt;
          &lt;valueUri value=&quot;http://hl7.org/fhir/ValueSet/identifier-type&quot;/&gt;
        &lt;/parameter&gt; 
      &lt;/Parameters&gt;
    &lt;/resource&gt;
  &lt;/entry&gt;
&lt;/Bundle&gt;
</pre>
<p>
Note that there's no way to anchor the execution of the operation against a URL.
The only operations that can be executed in this way are defined to be executed
at the System or Resource level for a particular resource.
</p>

<a name="search"> </a>
<h3>Invoking Search via Messages</h3>
<p>
In the same way that a defined operation can be invoked, a regular search operation
can be invoked. This also uses the <a href="parameters.html">Parameters</a> resource,
with the following rules:
</p>
<ul>
 <li>The event code is "search-type" or "search-system" in the system http://hl7.org/fhir/restful-interaction</li>
 <li>If the event type is "search-type" there SHALL be a parameter "resourceType" with specifies the type of resource being searched</li>
 <li>The search parameters are converted to FHIR data types according to the following table</li>
</ul>
<table class="grid">
 <tr>
  <td><b>Search Parameter Type</b></td>
  <td><b>Data Type</b></td>
 </tr>
 <tr>
  <td>number</td>
  <td>integer</td>
 </tr>
 <tr>
  <td>date</td>
  <td>dateTime</td>
 </tr>
 <tr>
  <td>string</td>
  <td>string</td>
 </tr>
 <tr>
  <td>token</td>
  <td>string or Coding (split the system and code apart)</td>
 </tr>
 <tr>
  <td>reference</td>
  <td>uri</td>
 </tr>
 <tr>
  <td>composite</td>
  <td>string</td>
 </tr>
 <tr>
  <td>quantity</td>
  <td>string or Quantity (split the syntax out)</td>
 </tr>
 <tr>
  <td>uri</td>
  <td>uri</td>
 </tr>
</table>
<p>
Here's an example:
</p>

<pre class="xml">
&lt;Bundle xmlns=&quot;http://hl7.org/fhir&quot;&gt;
  &lt;id value=&quot;urn:uuid:77831928-2a35-4c08-9496-8232323bf48c&quot;/&gt;
  &lt;!-- normal bundle stuff --&gt;
  &lt;entry&gt;
    &lt;fullUrl value=&quot;urn:uuid:c466754c-09c0-4f59-9f76-a48bd0ea27c9&quot;/&gt;
    &lt;resource&gt;
      &lt;MessageHeader&gt;
        &lt;!-- normal message header stuff --&gt;
        &lt;event&gt;
          &lt;system value=&quot;http://hl7.org/fhir/restful-interaction&quot;/&gt;
          &lt;!-- Search against Patient --&gt;
          &lt;code value=&quot;search-type&quot;/&gt; 
        &lt;/event&gt;
        &lt;!-- more normal message header stuff --&gt;
        &lt;data&gt;
          &lt;reference value=&quot;urn:uuid:59a17a19-46eb-42d9-821a-f93a0c530cac&quot;/&gt;
        &lt;/data&gt;
      &lt;/MessageHeader&gt;
    &lt;/resource&gt;
  &lt;/entry&gt;
  &lt;entry&gt;
    &lt;fullUrl value=&quot;urn:uuid:59a17a19-46eb-42d9-821a-f93a0c530cac&quot;/&gt;
    &lt;resource&gt;
      &lt;Parameters&gt;
        &lt;parameter&gt;
          &lt;name value=&quot;resourceType&quot;/&gt;
          &lt;valueString value=&quot;Patient&quot;/&gt;
        &lt;/parameter&gt; 
        &lt;parameter&gt;
          &lt;name value=&quot;gender&quot;/&gt;
          &lt;valueString value=&quot;m&quot;/&gt;
        &lt;/parameter&gt; 
      &lt;/Parameters&gt;
    &lt;/resource&gt;
  &lt;/entry&gt;
&lt;/Bundle&gt;
</pre>












</div>

[%file newfooter%]
    
    
</body>
</html>


